\section{Windows フォーム・WPF アプリケーションでの利用}

本章では FK システムを、Windows フォームおよび WPF で利用する方法を述べる。
FK の CLI 版は GUI コントロール上にビューポートを描画する機能を提供しており、
これを用いることで、フォームデザイナで作成した GUI や Xaml で記述したビューと、
FK システムによる描画を併用することができる。

\subsection{Windows フォームでの利用}

まずは Windows フォームアプリケーションのプロジェクトを作成し、
フォームデザイナでコントロールを配置する。
利用するコントロールは何でも構わないが、画面上で占める領域を明示でき、
処理が重くなるような副作用が少ないものとして、Panel コントロールを推奨する。
ここでは panel1 という名前で配置したものとして説明する。

コンポーネントの初期化が済んだところで、fk\_Viewport クラスのインスタンスを生成する。
fk\_Viewport のコンストラクタには、ビューポート領域として利用するコントロールを指定する。
\\
\begin{screen}
\begin{verbatim}
    var viewport = new fk_Viewport(panel1);
\end{verbatim}
\end{screen}
~

この時点で該当コントロール上での描画処理が行われるようになる。

\subsection{WPF での利用}

WPF で FK システムを利用する場合は、WindowsFormsHost によってフォームコントロールをホストし、
その領域をビューポートとして用いるかたちになる。
このため WPF アプリケーションプロジェクトの初期状態に対して、
System.Windows.Forms と WindowsFormsIntegration アセンブリを参照に追加する必要がある。

ここでは WPF のメインウィンドウ上に FK システムのビューポートを表示する方法を解説する。
次に示すのは、MainWindow.xaml に対して Panel コントロールを配置する変更を加えた Xaml である。
\\
\begin{screen}
\begin{verbatim}
<Window x:Class="FK_CLI_WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:wf="clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms"
        Title="MainWindow" Height="350" Width="525">
    <Grid>
        <WindowsFormsHost>
            <wf:Panel x:Name="ViewportPanel" />
        </WindowsFormsHost>
    </Grid>
</Window>
\end{verbatim}
\end{screen}
~

ポイントになるのは、Window コントロールの属性に追加する
\\
\begin{screen}
\begin{verbatim}
        xmlns:wf="clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms"
\end{verbatim}
\end{screen}
~ \\
System.Windows.Forms 名前空間のエイリアス定義と、Grid コントロール内に追加する
\\
\begin{screen}
\begin{verbatim}
        <WindowsFormsHost>
            <wf:Panel x:Name="ViewportPanel" />
        </WindowsFormsHost>
\end{verbatim}
\end{screen}
~ \\
WindowsFormsHost と、フォームコントロールである Panel を記述することである。
Panel コントロールに x:Name 属性で指定した名前を用いて、
コードビハインドである MainWindow.xaml.cs からアクセスすることができる。
WPF や Xaml の作法についての詳細は、別途書籍や資料を参照して欲しい。

コンポーネントの初期化が済んだところで、fk\_WpfViewport クラスのインスタンスを生成する。
fk\_WpfViewport のコンストラクタには、Xaml 上で名前を付けたパネルコントロールを指定する。
\\
\begin{screen}
\begin{verbatim}
    var viewport = new fk_WpfViewport(ViewportPanel);
\end{verbatim}
\end{screen}
~

fk\_Viewport と fk\_WpfViewport は使用するタイマーの処理が異なるだけで、
ユーザーに対して公開している機能は同一である。以降の文中で fk\_Viewport に関する記述は
すべて fk\_WpfViewport に関しても同様である。

\subsection{ビューポートの利用}

後は fk\_Window と同じようにシーンをセットして、描画したいモデルをエントリーすればよい。
シーンの登録には Scene プロパティを用いる。
\\
\begin{screen}
\begin{verbatim}
    var scene = new fk_Scene();
    viewport.Scene = scene;
\end{verbatim}
\end{screen}
~

fk\_Window や fk\_AppWindow を利用する場合と異なり、
Windows フォームや WPF ではメッセージループを記述することはできない。
このため、毎フレーム実行したい処理はイベントハンドラに登録する。
fk\_Viewport は PreDraw, PostDraw イベントを公開しており、
それぞれ描画処理を行う前後に呼び出される。
一般的には PreDraw イベントに処理を登録するのが妥当であろう。
モデルを回転させるアニメーション処理を、ラムダ式で直接記述する例を次に示す。
\\
\begin{screen}
\begin{verbatim}
    viewport.PreDraw += (s, e)
    {
        model.LoAngle(0.01, 0.0, 0.0);
    };
\end{verbatim}
\end{screen}
~

もちろんクラスのメソッドとして実装したものを登録しても構わない。
引数として object と EventArgs が渡されるが、利用できる情報はないので無視してよい。

fk\_Viewport は、デフォルトでは 16ms 間隔で描画処理を実行し、
60fps をキープするように動作している。これを変更するには DrawInterval プロパティを用いる。
次のコードは描画間隔を 33ms に設定し、30fps とするものである。
\\
\begin{screen}
\begin{verbatim}
    viewport.DrawInterval = 33;
\end{verbatim}
\end{screen}
~

アプリケーションの用途によってはリアルタイムな描画は不要で、
描画要素の更新があった時だけ明示的に描画を指示したいケースもある。
そのような場合は IsDrawing プロパティに false を設定してタイマー描画を停止し、
任意に Draw()メソッドを呼び出すことで描画を制御することもできる。
ただし、コンストラクタで指定したコントロールが再描画されるたびに、
ビューポートも再描画を行うのは抑制できない。

\subsection{デバイス情報の取得について}

fk\_Viewport クラスはマウスやキーに関する機能を提供しないので、
使用しているフレームワークが提供しているイベントハンドラを利用する。
マウスイベントに関しては、Windows フォームも WPF も同じく、
ビューポート領域として利用しているコントロールのハンドラを用いることができる。
詳細は System.Windows.Forms.Panel クラスのリファレンスを参照すること。

キー入力に関してはフォーカスの扱いが異なるため、異なるアプローチが必要になる。

\subsubsection{Windows フォームの場合}

Windows フォームのコントロールでキーイベントを受け取ることができるのは、
ボタンやテキストボックスなどの明示的にキー入力を受け付けるものに限られる。
しかし、それらのコントロールはカーソルやフォーカス枠の描画を伴うなど副作用が多く、
ビューポートの下地には適さない。

このため、確実にキーイベントを受け取れるのは、フォームの KeyPreview を true に設定した上で、
フォームに対する KeyDown, KeyUp イベントを処理するのが妥当であろう。

※具体的なコードをここに示す

\subsubsection{WPFの場合}

WPF を利用する場合は、WindowsFormsHost がフォーカスを受け取れるため、
これに名前を付けて KeyDown, KeyUp などのイベントを利用するとよい。

※具体的なコードをここに示す

\subsection{座標変換やピック処理について}

※具体的なコードをここに示す
