\chapter{サンプルプログラム} \label{chap:sample}
\section{基本的形状の生成と親子関係}
次に掲載するプログラムは、原点付近に1個の直方体と2本の線分を作成し
表示するプログラムである。ただ表示するだけでは面白くないので、線分を
直方体の子モデルにし、直方体を回転させると線分も一緒に回転することを
試してみる。また、視点も最初は遠方に置いて段々近づけていき、ある程度まで
接近したらひねりを加えてみる。

\begin{center}
詳細解説
\end{center}

\begin{itemize}

\item 6 行目の using 文は、FK システムを使用する場合に必ず記述する必要がある。

\item 17 行目でウィンドウの生成を行っている。

\item 20 行目で標準組込マテリアルの初期化を行っている。

\item 23 行目では、直方体モデルの生成を行っている。

\item 24 行目では直方体形状の生成を行い、25 行目でその形状情報を blockModel に登録している。

\item 26 行目では、直方体モデルのマテリアルとして Yellow を設定している。

\item 27 行目では、直方体モデルをウィンドウの表示対象として登録を行っている。

\item 30 行目では、線分形状の端点となる各点の位置ベクトルを配列として生成している。
	この時点では pos 内の各変数のインスタンスはまだ確保されていないため、
	31,32 行目のように new によってインスタンスを生成する必要があることに注意する。
	33,34 行目の「=」演算子は、新たなインスタンスが生成されて代入されるので、
	事前に new をしておく必要はない。

\item 35,36 行目ではそれぞれ線分形状と線分モデルを配列として生成している。
	これも前述した pos と同様、38 行目や 40 行目にあるようにインスタンスを new で

\item 42 行目では、lineModel[i] の親モデルを blockModel に設定している。
	親子関係は、このように Parent プロパティに親モデルとなる fk\_Model 型インスタンスを
	設定する方法がもっとも標準的なものである。
	これにより、各線分モデルは直方体モデルの動きに追従するようになる。
	しかし、親子関係は表示属性にはなんら影響はしないため、
	各線分を表示するためには 43 行目にあるようにウィンドウへの登録が必要となる。
	
\item 46、47 行目で、線分に対して色設定を行っている。
	どのような形状であっても、線に対して色を設定する場合は
	LineColor プロパティを用いる。

\item 43、44 行目で、線分を直方体の子モデルに設定している。これにより、
	直方体を移動すると線分も追従して移動していくようになる。

\item 47 〜 51 行目で、各モデルをシーンへ登録している。

\item 50 〜 54 行目で、カメラ(視点)モデルの設定を行っている。
	カメラモデルは通常の fk\_Model インスタンスを準備すればよく、
	このサンプルの場合は位置を	\((0,0, 2000)\)、方向を原点に向け、
	ウィンドウの上方向が \((0, 1, 0)\) になるように設定している。
	ある fk\_Model 型インスタンスをカメラモデルとして設定するには、
	54 行目にあるように fk\_AppWindow クラスの CameraModel プロパティに
	設定を行えばよい。設定後にカメラモデルを動作させれば視点も動的に変化し、
	任意のタイミングで別のインスタンスに変更することも可能である。
	
\item 57 行目は実際にウィンドウを表示するためのメソッドである。

\item 61 行目の for 文中にある Update() メソッドは2つの働きがある。
	まず、現在のモデル設定に従って画面の描画を更新する。
	また、そのタイミングでウィンドウが消去されていないかをチェックし、
	もし消去されていた場合は false を返し、正常な場合は true を返す。

	ウィンドウは、画面上で「ESC」ボタンが押されていたり、
	ウィンドウが OS 内の機能で強制的に閉じられた場合に消去される。

 \item 62 行目で、視点位置を \((0, 0, -1)\) 移動している。
 \item 63 行目で、直方体 (と子モデルである線分) を Y 軸中心に
	回転させている。回転角度は、\(\pi/300 = 0.6 ^{\circ}\) である。
	ここにある「FK.PI」は FK のプログラム上で円周率を用いる場合に利用するものであるが、
	C\# の標準機能にある「Math.PI」を用いても問題はない。
 \item 65 行目で、もし視点が原点を越えてしまった場合に注視点を
	原点に向かせるようにしている。
 \item 66 行目で、描画カウント i が 1000 を超えた場合に
	視点にひねりを加えている。
\end{itemize} ~
\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Box
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             int i;
15: 
16:             // ウィンドウ生成
17:             var win = new fk_AppWindow();
18: 
19:             // 組込マテリアル初期化
20:             fk_Material.InitDefault();
21: 
22:             // 直方体モデル生成
23:             var blockModel = new fk_Model();
24:             var block = new fk_Block(50.0, 70.0, 40.0);
25:             blockModel.Shape = block;
26:             blockModel.Material = fk_Material.Yellow;
27:             win.Entry(blockModel);
28: 
29:             // 線分モデル生成
30:             var pos = new fk_Vector[4];
31:             pos[0] = new fk_Vector(0.0, 100.0, 0.0);
32:             pos[1] = new fk_Vector(100.0, 0.0, 0.0);
33:             pos[2] = -pos[0];
34:             pos[3] = -pos[1];
35:             var line = new fk_Line[2];
36:             var lineModel = new fk_Model[2];
37:             for(i = 0; i < 2; i++) {
38:                 line[i] = new fk_Line();
39:                 line[i].PushLine(pos[2*i], pos[2*i + 1]);
40:                 lineModel[i] = new fk_Model();
41:                 lineModel[i].Shape = line[i];
42:                 lineModel[i].Parent = blockModel;
43:                 win.Entry(lineModel[i]);
44:             }
45: 
46:             lineModel[0].LineColor = new fk_Color(1.0, 0.0, 0.0);
47:             lineModel[1].LineColor = new fk_Color(0.0, 1.0, 0.0);
48: 
49:             // カメラモデル生成
50:             var camera = new fk_Model();
51:             camera.GlMoveTo(0.0, 0.0, 2000.0);
52:             camera.GlFocus(0.0, 0.0, 0.0);
53:             camera.GlUpvec(0.0, 1.0, 0.0);
54:             win.CameraModel = camera;
55: 
56:             // ウィンドウ生成
57:             win.Open();
58: 
59:             var origin = new fk_Vector(0.0, 0.0, 0.0);
60: 
61:             for(i = 0; win.Update() == true; i++) {
62:                 camera.GlTranslate(0.0, 0.0, -1.0);
63:                 blockModel.GlRotateWithVec(origin, fk_Axis.Y, FK.PI/300.0);
64:                 var cPos = camera.Position;
65:                 if(cPos.z < -FK.EPS) camera.GlFocus(origin);
66:                 if(i >= 1000) camera.LoRotateWithVec(origin, fk_Axis.Z, FK.PI/500.0);
67:             }
68:         }
69:     }
70: }
\end{verbatim}
\end{small}
\end{breakbox}
~

また、以下のソースコードは、同様のプログラムを F\# で記述したものである。
C\# 版のコードと比較することで大体の F\# の文法を把握できるだろう。\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: open System
 2: open FK_CLI
 3: 
 4: module FK_Box =
 5: 
 6:     // ウィンドウ生成
 7:     let win = new fk_AppWindow()
 8: 
 9:     // マテリアル初期化
10:     fk_Material.InitDefault()
11: 
12:     // 直方体モデル生成
13:     let blockModel = new fk_Model()
14:     let block = new fk_Block(50.0, 70.0, 40.0)
15:     blockModel.Shape <- block
16:     blockModel.Material <- fk_Material.Yellow
17:     win.Entry(blockModel)
18: 
19:     // 線分モデル生成
20:     let pos : fk_Vector array = Array.init 4 (fun i -> new fk_Vector())
21:     pos.[0].Set(0.0, 100.0, 0.0)
22:     pos.[1].Set(100.0, 0.0, 0.0)
23:     pos.[2] <- -pos.[0]
24:     pos.[3] <- -pos.[1]
25: 
26:     let line : fk_Line array = Array.init 2 (fun i -> new fk_Line())
27:     let lineModel : fk_Model array = Array.init 2 (fun i -> new fk_Model())
28: 
29:     for i = 0 to 1 do
30:         line.[i].PushLine(pos.[2*i], pos.[2*i + 1])
31:         lineModel.[i].Shape <- line.[i]
32:         lineModel.[i].Parent <- blockModel
33:         win.Entry(lineModel.[i])
34: 
35:     lineModel.[0].LineColor <- new fk_Color(1.0, 0.0, 0.0)
36:     lineModel.[1].LineColor <- new fk_Color(0.0, 1.0, 0.0)
37: 
38:     // カメラモデル生成
39:     let camera = new fk_Model()
40:     camera.GlMoveTo(0.0, 0.0, 2000.0) |> ignore
41:     camera.GlFocus(0.0, 0.0, 0.0) |> ignore
42:     camera.GlUpvec(0.0, 1.0, 0.0) |> ignore
43:     win.CameraModel <- camera
44: 
45:     // ウィンドウ生成
46:     win.Open()
47: 
48:     let org = new fk_Vector(0.0, 0.0, 0.0)
49:     let i = ref 0
50:     while win.Update() = true do
51:         incr i
52:         camera.GlTranslate(0.0, 0.0, -1.0) |> ignore
53:         blockModel.GlRotateWithVec(org, fk_Axis.Y, FK.PI/300.0) |> ignore
54:         if camera.Position.z < 0.0 then camera.GlFocus(org) |> ignore
55:         if !i >= 1000 then camera.LoRotateWithVec(org, fk_Axis.Z, FK.PI/500.0) |> ignore
\end{verbatim}
\end{small}
\end{breakbox}

\section{LOD 処理とカメラ切り替え}
次のサンプルは、ボールが弾む様子を描いたプログラムである。このプログラムを
実行すると、ボールが2回弾む間は鳥瞰的なカメラ視点だが、その後に青色の
ブロックからボールを見る視点に切り替わる。プログラムのおおまかな流れは
自分で解析して頂きたいが、ここでは最初のサンプルにはなかった概念に
関して説明する。

まず、10 行目にて Ball クラスを定義し、この中で fk\_Model や fk\_Sphere の
インスタンスを管理している。本マニュアルでは C\# の文法については触れないため、
クラスの詳細については別の文献を参照して頂きたいが、自作のクラスを作成する際の
参考となるであろう。


29 〜 31 行目にて球を分割数を変えて 3 種類定義しているが、これは
71 行目からの LOD() メソッド内で Ball の実際の形状を動的に選択できるように
するためである。「LOD (Level Of Detail) 処理」とは、視点とオブジェクトの
距離によって形状の精密さを動的に変化させるテクニックである。たとえば、
多くのポリゴンでできている形状は精密で迫力があるが、視点から
とても遠くて非常に小さく表示されているような場合は無駄に処理されている
ことになる。そこで、遠くにあって小さく表示されている場合は粗い形状を
表示して処理の高速化を計るのが LOD 処理の目的である。このサンプルの
LOD 処理はわかりやすくするために露骨に変化が見られるが、実際に
プログラムを作成するときはわかりにくくなるように視点距離との関係を
調整すべきである。
\\
\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using FK_CLI;
  7: 
  8: namespace FK_CLI_Ball
  9: {
 10:     public class Ball
 11:     {
 12:         private const double    DOWN_ACCEL      = 0.05;     // 降下時の加速度
 13:         private const double    RISE_ACCEL      = 0.053;    // 上昇時の減速度
 14:         private const int       DOWN_MODE       = 0;        // 降下モード
 15:         private const int       RISE_MODE       = 1;        // 上昇モード
 16:         private const int       LOD4_HIGH       = 200;      // 四分割距離 (鳥瞰)
 17:         private const int       LOD3_HIGH       = 300;      // 三分割距離 (鳥瞰)
 18:         private const int       LOD4_LOW        = 90;       // 四分割距離 (ブロック)
 19:         private const int       LOD3_LOW        = 120;      // 三分割距離 (ブロック)
 20:         private const double    TOP_BALL_POS    = 300.0;    // ボール始点高さ
 21:         private const double    BTM_BALL_POS    = 18.0;     // ボール跳ね返り高さ
 22:         private const double    BALL_SIZE       = 12.0;     // ボール半径
 23: 
 24:         private int direction;          // ボールの状態(DOWN_MODE or RISE_MODE)
 25:         private int view_mode;          // 視点モード
 26:         private int bound_count;        // バウンド回数を数える変数
 27:         private double y_trs;           // ボールのｙ座標移動量
 28:         private fk_Model ball_model;    // ボールのモデル
 29:         private fk_Sphere BALL2;        // 二分割形状
 30:         private fk_Sphere BALL3;        // 三分割形状
 31:         private fk_Sphere BALL4;        // 四分割形状
 32: 
 33:         public const int LOW_MODE       = 0;        // ブロック視点モード
 34:         public const int HIGH_MODE      = 1;        // 鳥瞰モード
 35: 
 36:         public Ball()
 37:         {
 38:             BALL2 = new fk_Sphere(6, BALL_SIZE);
 39:             BALL3 = new fk_Sphere(8, BALL_SIZE);
 40:             BALL4 = new fk_Sphere(10, BALL_SIZE);
 41:             ball_model = new fk_Model();
 42:             Init();
 43:         }
 44: 
 45:         public void Init()
 46:         {
 47:             direction   = DOWN_MODE;
 48:             y_trs       = 0.1;
 49:             view_mode   = HIGH_MODE;
 50:             bound_count = 1;
 51:             ball_model.GlMoveTo(0.0, TOP_BALL_POS, 0.0);
 52:             ball_model.Shape = BALL2;
 53:         }
 54: 
 55:         public fk_Model Model
 56:         {
 57:             get
 58:             {
 59:                 return ball_model;
 60:             }
 61:         }
 62: 
 63:         public fk_Vector Pos
 64:         {
 65:             get
 66:             {
 67:                 return ball_model.Position;
 68:             }
 69:         }
 70: 
 71:         public void LOD(fk_Vector argPos)
 72:         {
 73:             double  Distance = (ball_model.Position - argPos).Dist();
 74:             switch(view_mode) {
 75:                 case HIGH_MODE:
 76:                     if(Distance < LOD4_HIGH) {
 77:                         ball_model.Shape = BALL4;
 78:                     } else if(Distance < LOD3_HIGH) {
 79:                         ball_model.Shape = BALL3;
 80:                     } else {
 81:                         ball_model.Shape = BALL2;
 82:                     }
 83:                     break;
 84: 
 85:                 case LOW_MODE:
 86:                     if(Distance < LOD4_LOW) {
 87:                         ball_model.Shape = BALL4;
 88:                     } else if(Distance < LOD3_LOW) {
 89:                         ball_model.Shape = BALL3;
 90:                     } else {
 91:                         ball_model.Shape = BALL2;
 92:                     }
 93:                     break;
 94: 
 95:                 default:
 96:                     break;
 97:             }
 98:         }
 99: 
100:         public void Accel()
101:         {
102:             switch(direction) {
103:                 case DOWN_MODE:
104:                     y_trs += DOWN_ACCEL;
105:                     ball_model.GlTranslate(0.0, -y_trs, 0.0);
106:                     break;
107: 
108:                 case RISE_MODE:
109:                     y_trs -= RISE_ACCEL;
110:                     ball_model.GlTranslate(0.0, y_trs, 0.0);
111:                     break;
112: 
113:                 default:
114:                     break;
115:             }
116:         }
117: 
118:         public void Bound()
119:         {
120:             if(ball_model.Position.y < BTM_BALL_POS) {
121:                 direction = RISE_MODE;
122:             } else if(y_trs < 0.01) {
123:                 if(direction == RISE_MODE) {
124:                     if(bound_count % 4 < 2) {
125:                         view_mode = HIGH_MODE;
126:                     } else {
127:                         view_mode = LOW_MODE;
128:                     }
129:                     bound_count++;
130:                 }
131:                 direction = DOWN_MODE;
132:             }
133:         }
134: 
135:         public int Draw(fk_Vector argPos)
136:         {
137:             LOD(argPos);
138:             Bound();
139:             Accel();
140:             //４回跳ね返ると初期化
141:             if(bound_count > 4) Init();
142:             return view_mode;
143:         }
144:     }
145: 
146:     class Program
147:     {
148:         static void Main(string[] args)
149:         {
150:             var win = new fk_AppWindow();
151:             win.Size = new fk_Dimension(600, 600);
152:             win.ClearModel(false); // デフォルト光源消去
153: 
154:             int view_mode = Ball.HIGH_MODE;
155:     
156:             var ball = new Ball();
157:             
158:             var viewModel = new fk_Model();
159:             var lightModel = new fk_Model();
160:             var groundModel = new fk_Model();
161:             var blockModel = new fk_Model();
162: 
163:             var light = new fk_Light();
164:             var ground = new fk_Circle(4, 100.0);
165:             var block = new fk_Block(10.0, 10.0, 10.0);
166: 
167: 
168:             fk_Material.InitDefault();
169: 
170:             // ### VIEW POINT ###
171:             // 上の方から見た視点
172:             viewModel.GlMoveTo(0.0, 400.0, 80.0);
173:             viewModel.GlFocus(0.0, 30.0, 0.0);
174:             viewModel.GlUpvec(0.0, 1.0, 0.0);
175: 
176:             // ### LIGHT ###
177:             light.Type = fk_LightType.POINT;
178:             light.SetAttenuation(0.0, 0.0);
179:             lightModel.Shape = light;
180:             lightModel.Material = fk_Material.White;
181:             lightModel.GlTranslate(-60.0, 60.0, 0.0);
182: 
183:             // ### GROUND ###
184:             groundModel.Shape = ground;
185:             groundModel.Material = fk_Material.LightGreen;
186:             groundModel.SmoothMode = true;
187:             groundModel.LoRotateWithVec(0.0, 0.0, 0.0, fk_Axis.X, -FK.PI/2.0);
188: 
189:             // ### VIEW BLOCK ###
190:             blockModel.Shape = block;
191:             blockModel.Material = fk_Material.Blue;
192:             blockModel.GlMoveTo(60.0, 30.0, 0.0);
193:             blockModel.Parent = groundModel;
194: 
195:             // ### BALL ###
196:             ball.Model.Material = fk_Material.Red;
197:             ball.Model.SmoothMode = true;
198:     
199:             // ### Model Entry ###
200:             win.CameraModel = viewModel;
201:             win.Entry(lightModel);
202:             win.Entry(ball.Model);
203:             win.Entry(groundModel);
204:             win.Entry(blockModel); 
205: 
206:             win.Open();
207: 
208:             while(win.Update() == true) {
209: 
210:                 // ボールを弾ませて, カメラの状態を取得。
211:                 view_mode = ball.Draw(viewModel.Position);
212: 
213:                 if(view_mode == Ball.HIGH_MODE) {
214:                     // カメラを上からの視点にする。
215:                     viewModel.GlMoveTo(0.0, 400.0, 80.0);
216:                     viewModel.GlFocus(0.0, 30.0, 0.0);
217:                     viewModel.GlUpvec(0.0, 1.0, 0.0);
218:                 } else {
219:                     // カメラをブロックからの視点にする。
220:                     viewModel.GlMoveTo(blockModel.InhPosition);
221:                     viewModel.GlTranslate(0.0, 10.0, 0.0);
222:                     viewModel.GlFocus(ball.Pos);
223:                     viewModel.GlUpvec(0.0, 1.0, 0.0);
224:                 }
225: 
226:                 // 地面をくるくる回転させましょう。
227:                 groundModel.GlRotateWithVec(0.0, 0.0, 0.0, fk_Axis.Y, 0.02);
228:             }
229:         }
230:     }
231: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{Boid アルゴリズムによる群集シミュレーション}
Boid アルゴリズムとは、群集シミュレーションを実現するための最も基本的なアルゴリズムである。
このアルゴリズムでは、群を構成する各エージェントは以下の3つの動作規則を持つ。

\begin{description}
\item[分離 (Separation):] ~ \\
	エージェントが、他のエージェントとぶつからないように距離を取る。
	\myfig{Fig:Boid-Sep}{./Fig/Boid-Sep.eps}{scale=3.0}{分離の概念図}{0mm}

\item[整列 (Alignment):] ~ \\
	エージェントが周囲のエージェントと方向ベクトルと速度ベクトルを合わせる。
	\myfig{Fig:Boid-Ali}{./Fig/Boid-Ali.eps}{scale=3.0}{整列の概念図}{0mm}

\item[結合 (Cohesion):] ~ \\
	エージェントは、群れの中心方向に集まるようにする。
	\myfig{Fig:Boid-Coh}{./Fig/Boid-Coh.eps}{scale=3.0}{結合の概念図}{0mm}

\end{description}
これを実現するための計算式は、以下の通りである。
なお、\(n\)個のエージェントの識別番号を\(i \; (0, 1, \cdots, n-1)\) とし、
それぞれの位置ベクトル、速度ベクトルを \(\bP_i, \bV_i\) とする。

\begin{description}
 \item[分離:] ~ \\
エージェント\(i\)が\(j\)から離れたければ、元の速度ベクトルに対し
\(\lvec{\bP_j\bP_i} = \bP_i - \bP_j\) を合わせれば良いので、
\(\alpha\)をやや小さめの適当な数値として
\begin{equation}
	{\bV_i}' = \bV_i + \alpha \frac{\bP_i - \bP_j}{|\bP_i - \bP_j|}
\end{equation}
とすればよい。これを近隣にあるエージェント全てにおいて計算すればよい。
近隣エージェントの番号集合を\(N\)とすれば、
\begin{equation}
	{\bV_i}' = \bV_i + \alpha \sum_{j \in N}\frac{\bP_i - \bP_j}{|\bP_i - \bP_j|}
\end{equation}
となる。

\item[整列:] ~ \\
周囲のエージェントの速度ベクトルの平均を出し、その分を自身の速度ベクトルに足せばよい。
数式としては以下の通り。
\begin{equation}
	{\bV_i}' = \frac{\bV_i + \beta\sum_{j \in N}\bV_j}{|\bV_i + \beta\sum_{j \in N}\bV_j|} .
\end{equation}

\item[結合:] ~ \\
群れ全体の重心\(\bG\)を算出し、そこに向かうようなベクトルを速度ベクトルに追加する。
\begin{equation}
	{\bV_i}' = \bV_i + \gamma (\frac{\sum\bP_i}{n} - \bP_i) .
\end{equation}
\end{description}

以下、C\# と F\# によるサンプルプログラムを掲載する。
これらついての詳細な解説は割愛するが、
各エージェントを表す「Agent」クラスと、群を表す「Boid」クラスを構築することにより、
メインループがかなりシンプルになっていることがわかる。また、
「S」「A」「C」キーを押すと、それぞれ「分離」「整列」「結合」規則を無効にするように
なっているので、各規則がどのようにエージェントの動作に影響しているかがわかるだろう。

F\# は C\# に比べるとかなりコンパクトなコードになっている。
F\# は、配列やリストに対しての各種操作で強力な機能を持つ文法となっており、
今回のようなシミュレーションプログラムの記述には大きな威力を発揮することがわかる。

\begin{center}
C\#版
\end{center}
\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using FK_CLI;
  7: 
  8: namespace FK_CLI_Boid
  9: {
 10:     // エージェント用クラス
 11:     class Agent
 12:     {
 13:         private fk_Model model;
 14:         private fk_Vector newVec;
 15: 
 16:         public Agent(double argSize, Random argRand)
 17:         {
 18:             // コンストラクタ
 19:             // 各モデルの位置と方向をランダムに設定する。
 20:             model = new fk_Model();
 21:             model.Material = fk_Material.Red;
 22:             model.GlVec(argRand.NextDouble()*2.0 - 1.0, argRand.NextDouble()*2.0 - 1.0, 0.0);
 23:             model.GlMoveTo(argRand.NextDouble() * argSize * 2.0 - argSize,
 24:                            argRand.NextDouble() * argSize * 2.0 - argSize, 0.0);
 25:         }
 26: 
 27:         // 位置ベクトルプロパティ
 28:         public fk_Vector Pos
 29:         {
 30:             get
 31:             {
 32:                 return model.Position;
 33:             }
 34:         }
 35: 
 36:         // 方向ベクトルプロパティ
 37:         public fk_Vector Vec
 38:         {
 39:             set
 40:             {
 41:                 newVec = value;
 42:             }
 43:             get
 44:             {
 45:                 return model.Vec;
 46:             }
 47:         }
 48: 
 49:         // 形状インスタンスプロパティ
 50:         public fk_Shape Shape
 51:         {
 52:             set
 53:             {
 54:                 model.Shape = value;
 55:             }
 56:         }
 57: 
 58:         // ウィンドウ登録メソッド
 59:         public void Entry(fk_AppWindow argWin)
 60:         {
 61:             argWin.Entry(model);
 62:         }
 63: 
 64:         // 前進メソッド
 65:         public void Forward()
 66:         {
 67:             model.GlVec(newVec);
 68:             model.LoTranslate(0.0, 0.0, -0.05);
 69:         }
 70:     }
 71: 
 72:     // 群衆用クラス
 73:     class Boid {
 74:         private Agent [] agent;
 75:         private fk_Cone cone;
 76:         private const int IAREA = 15;
 77:         private const double AREASIZE = (double)(IAREA);
 78: 
 79:         private double paramA, paramB, paramC, paramLA, paramLB;
 80: 
 81:         // コンストラクタ
 82:         public Boid(int argNum)
 83:         {
 84:             // 乱数発生器の初期化
 85:             var rand = new Random();
 86: 
 87:             // 形状インスタンスの性生
 88:             fk_Material.InitDefault();
 89:             cone = new fk_Cone(16, 0.4, 1.0);
 90:             if(argNum < 0) return;
 91: 
 92:             // エージェント配列作成
 93:             agent = new Agent[argNum];
 94: 
 95:             // エージェントインスタンスの作成
 96:             for(int i = 0; i < argNum; ++i) {
 97:                 agent[i] = new Agent(AREASIZE, rand);
 98:                 agent[i].Shape = cone;
 99:             }
100: 
101:             // 各種パラメータ設定
102:             paramA = 0.2;
103:             paramB = 0.02;
104:             paramC = 0.01;
105:             paramLA = 3.0;
106:             paramLB = 5.0;
107:         }
108: 
109:         // パラメータ設定メソッド
110:         public void SetParam(double argA, double argB, double argC,
111:                              double argLA, double argLB)
112:         {
113:             paramA = argA;
114:             paramB = argB;
115:             paramC = argC;
116:             paramLA = argLA;
117:             paramLB = argLB;
118:         }
119: 
120:         // ウィンドウへのエージェント登録メソッド
121:         public void SetWindow(fk_AppWindow argWin)
122:         {
123:             foreach(Agent M in agent) {
124:                 M.Entry(argWin);
125:             }
126:         }
127: 
128:         // 各エージェント動作メソッド
129:         public void Forward(bool argSMode, bool argAMode, bool argCMode)
130:         {
131:             var gVec = new fk_Vector();
132:             fk_Vector diff = new fk_Vector();
133:             fk_Vector [] pArray = new fk_Vector[agent.Length]; // 位置ベクトル格納用配列
134:             fk_Vector [] vArray = new fk_Vector[agent.Length]; // 方向ベクトル格納用配列
135: 
136:             // 全体の重心計算
137:             for(int i = 0; i < agent.Length; i++) {
138:                 pArray[i] = agent[i].Pos;
139:                 vArray[i] = agent[i].Vec;
140:                 gVec += pArray[i];
141:             }
142:             gVec /= (double)(agent.Length);
143: 
144:             // エージェントごとの動作算出演算
145:             for(int i = 0; i < agent.Length; i++) {
146:                 fk_Vector vec = new fk_Vector(vArray[i]);
147: 
148:                 for(int j = 0; j < agent.Length; j++) {
149:                     if(i == j) continue;
150:                     diff = pArray[i] - pArray[j];
151:                     double dist = diff.Dist();
152: 
153:                     // 分離 (Separation) 処理
154:                     if(dist < paramLA && argSMode) {
155:                         vec += paramA * diff / (dist*dist);
156:                     }
157: 
158:                     // 整列 (Alignment) 処理
159:                     if(dist < paramLB && argAMode) {
160:                         vec += paramB * vArray[j];
161:                     }
162:                 }
163: 
164:                 // 結合 (Cohesion) 処理 (スペースキーが押されていたら無効化)
165:                 if(argCMode == true) {
166:                     vec += paramC * (gVec - pArray[i]);
167:                 }
168: 
169:                 // 領域の外側に近づいたら方向修正
170:                 if(Math.Abs(pArray[i].x) > AREASIZE && pArray[i].x * vArray[i].x > 0.0) {
171:                     vec.x -= vec.x * (Math.Abs(pArray[i].x) - AREASIZE)*0.2;
172:                 }
173:                 if(Math.Abs(pArray[i].y) > AREASIZE && pArray[i].y * vArray[i].y > 0.0) {
174:                     vec.y -= vec.y * (Math.Abs(pArray[i].y) - AREASIZE)*0.2;
175:                 }
176: 
177:                 // 最終的な方向ベクトル演算結果を代入
178:                 vec.z = 0.0;
179:                 agent[i].Vec = vec;
180:             }
181: 
182:             // 全エージェントを前進
183:             foreach(Agent M in agent) {
184:                 M.Forward();
185:             }
186:         }
187:     }
188: 
189:     class Program {
190:         static void Main(string[] args)
191:         {
192:             var win = new fk_AppWindow();
193:             var boid = new Boid(200);
194: 
195:             boid.SetWindow(win);
196: 
197:             win.Size = new fk_Dimension(600, 600);
198:             win.BGColor = new fk_Color(0.6, 0.7, 0.8);
199:             win.ShowGuide(fk_GuideMode.GRID_XY);
200:             win.CameraPos = new fk_Vector(0.0, 0.0, 80.0);
201:             win.CameraFocus = new fk_Vector(0.0, 0.0, 0.0);
202:             win.FPS = 0;
203: 
204:             win.Open();
205: 
206:             while(win.Update() == true) {
207:                 bool sMode = win.GetKeyStatus('S', fk_SwitchStatus.RELEASE);
208:                 bool aMode = win.GetKeyStatus('A', fk_SwitchStatus.RELEASE);
209:                 bool cMode = win.GetKeyStatus('C', fk_SwitchStatus.RELEASE);
210:                 boid.Forward(sMode, aMode, cMode);
211:             }
212: 
213:         }
214:     }
215: }
\end{verbatim}
\end{small}
\end{breakbox}
\begin{center}
F\#版
\end{center}
\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: open System
  2: open FK_CLI
  3: 
  4: // エージェント用クラス
  5: type Agent(argID:int) = class
  6:     // コンストラクタ
  7:     let model = new fk_Model()
  8:     let newVec = new fk_Vector()
  9:     let id = argID
 10: 
 11:     do
 12:         model.Material <- fk_Material.Red
 13: 
 14:     // (ここまでがコンストラクタ)
 15: 
 16:     // ID プロパティ
 17:     member this.ID with get() = id
 18: 
 19:     // 位置ベクトルプロパティ
 20:     member this.Pos with get() = model.Position
 21: 
 22:     // 方向ベクトルプロパティ
 23:     member this.Vec with get() = model.Vec
 24:                     and set(v:fk_Vector) = newVec.Set(v.x, v.y, v.z)
 25: 
 26:     // 形状プロパティ
 27:     member this.Shape with get() = model.Shape
 28:                       and set(s:fk_Shape) = model.Shape <- s 
 29: 
 30:     // 初期化メソッド
 31:     member this.Init(argSize: double, argRand: Random) =
 32:         model.GlVec(argRand.NextDouble()*2.0 - 1.0,
 33:                     argRand.NextDouble()*2.0 - 1.0,
 34:                     0.0) |> ignore
 35:         model.GlMoveTo(argRand.NextDouble() * argSize * 2.0 - argSize,
 36:                        argRand.NextDouble() * argSize * 2.0 - argSize,
 37:                        0.0) |> ignore
 38: 
 39:     // ウィンドウ登録メソッド
 40:     member this.Entry(argWin: fk_AppWindow) =
 41:         argWin.Entry(model)
 42: 
 43:     // 前進メソッド
 44:     member this.Forward() =
 45:         model.GlVec(newVec) |> ignore
 46:         model.LoTranslate(0.0, 0.0, -0.05) |> ignore
 47:         model.GlMoveTo(this.Pos.x, this.Pos.y, 0.0) |> ignore
 48: end;;
 49: 
 50: // 群集クラス
 51: type Boid(argNum) = class
 52:     // コンストラクタ
 53:     do
 54:         fk_Material.InitDefault()
 55: 
 56:     // 乱数発生器生成
 57:     let rand = new Random()
 58: 
 59:     // エージェント配列生成
 60:     let agent : Agent array = [|for i in 0 .. argNum - 1 -> new Agent(i)|]
 61: 
 62:     // 形状生成
 63:     let cone = new fk_Cone(16, 0.4, 1.0)
 64: 
 65:     // 各種パラメータ設定
 66:     let IAREA = 15
 67:     let AREASIZE = double(IAREA)
 68:     let paramA = 0.2
 69:     let paramB = 0.02
 70:     let paramC = 0.01
 71:     let paramLA = 3.0
 72:     let paramLB = 5.0
 73:     do
 74:         // 各エージェントの初期化
 75:         agent |> Array.iter (fun a -> a.Init(AREASIZE, rand))
 76:         agent |> Array.iter (fun a -> a.Shape <- cone)
 77: 
 78:     // (ここまでがコンストラクタ)
 79: 
 80:     // ウィンドウ登録メソッド
 81:     member this.SetWindow(argWin: fk_AppWindow) =
 82:         agent |> Array.iter (fun a -> a.Entry(argWin))
 83: 
 84:     // 各エージェント動作メソッド
 85:     member this.Forward(argSMode: bool, argAMode: bool, argCMode: bool) =
 86:         let pA = agent |> Array.map (fun a -> a.Pos) // 位置ベクトル配列
 87:         let vA = agent |> Array.map (fun a -> a.Vec) // 方向ベクトル配列
 88:         let iA = agent |> Array.map (fun a -> a.ID)  // ID配列
 89:         let vArray = Array.zip3 pA vA iA             // 結合リスト作成
 90: 
 91:         let newV0 = vArray |> Array.map (fun (p1, v1, i) ->
 92:             let mutable tmpV = v1
 93:             for j = 0 to vArray.Length - 1 do
 94:                 if i <> j then
 95:                     let diff = p1 - pA.[j]
 96:                     let dist = diff.Dist()
 97:                     // 分離ルール
 98:                     if dist < paramLA && argSMode then
 99:                         tmpV <- tmpV + paramA * diff / (dist*dist)
100: 
101:                     // 整列ルール
102:                     if dist < paramLB && argAMode then
103:                         tmpV <- tmpV + paramB * vA.[j]
104:             tmpV
105:         )
106: 
107:         // 重心計算
108:         let gVec = (Array.reduce (fun x y -> x + y) pA) / (double pA.Length)
109: 
110:         // 結合ルール
111:         let calcG (p, v) = v + paramB * (gVec - p)
112:         let newV1 =
113:             if argCMode then
114:                 Array.zip pA newV0 |> Array.map calcG
115:             else
116:                 Array.copy newV0
117: 
118:         // 領域外判定用メソッド
119:         let xOut (p:fk_Vector, v:fk_Vector) = Math.Abs(p.x) > AREASIZE && p.x * v.x > 0.0
120:         let yOut (p:fk_Vector, v:fk_Vector) = Math.Abs(p.y) > AREASIZE && p.y * v.y > 0.0
121: 
122:         // 反転メソッド
123:         let vNegate (p:double, v:double) = v - v * (Math.Abs(p) - AREASIZE) * 0.2
124: 
125:         // 領域の外側に近づいたら方向修正するメソッド
126:         let xNegate (p:fk_Vector, v:fk_Vector) =
127:             if xOut (p, v) then
128:                 new fk_Vector(vNegate(p.x, v.x), v.y, 0.0)
129:             else
130:                 v
131: 
132:         let yNegate (p: fk_Vector, v:fk_Vector) =
133:             if yOut (p, v) then
134:                 new fk_Vector(v.x, vNegate(p.y, v.y), 0.0)
135:             else
136:                 v
137: 
138:         // 方向修正を行ったエージェントリストを取得
139:         let newV2 = Array.zip pA newV1 |> Array.map xNegate
140:         let newV3 = Array.zip pA newV2 |> Array.map yNegate
141: 
142:         // エージェントに新速度設定
143:         let newAgent = Array.zip agent newV3
144:         newAgent |> Array.iter (fun (a, v) -> (a.Vec <- v))
145: 
146:         // エージェント前進
147:         agent |> Array.iter (fun a -> a.Forward())
148: 
149: end;;
150: 
151: 
152: module FK_Boid =
153:     let win = new fk_AppWindow()
154:     let boid = new Boid(150)
155: 
156:     boid.SetWindow(win)
157: 
158:     win.Size <- new fk_Dimension(600, 600)
159:     win.BGColor <- new fk_Color(0.6, 0.7, 0.8)
160:     win.ShowGuide(fk_GuideMode.GRID_XY)
161:     win.CameraPos <- new fk_Vector(0.0, 0.0, 80.0)
162:     win.CameraFocus <- new fk_Vector(0.0, 0.0, 0.0)
163:     win.FPS <- 0
164: 
165:     win.Open()
166:     while win.Update() = true do
167:         let sMode = win.GetKeyStatus('s', fk_SwitchStatus.RELEASE)
168:         let aMode = win.GetKeyStatus('a', fk_SwitchStatus.RELEASE)
169:         let cMode = win.GetKeyStatus('c', fk_SwitchStatus.RELEASE)
170:         boid.Forward(sMode, aMode, cMode)
\end{verbatim}
\end{small}
\end{breakbox}

\section{形状の簡易表示とアニメーション} \label{sec:sampleviewer}

次のサンプルは、fk\_ShapeViewer クラスの典型的な利用法を示したものである。

このサンプルプログラムでは、23〜40行目がメッシュ形状を生成する処理を記述し、
45〜53行目がアニメーションを実現している処理となっている。


\begin{center}
詳細解説
\end{center}

\begin{itemize}
 \item 23 〜 28 行目で 11 行 11 列の行列として並んでいる状態の
	座標を計算している。その際、\(z = \dfrac{x^2 - y^2}{10}\)
	として \(z\) 成分は計算されている。

 \item 次に、31 〜 38 行目でインデックスフェースセットを表す
	配列を作成している。インデックスフェースセットに関しては、
	第 \ref{sec:solidGen1} 節を参照すること。

 \item 40 行目で実際に形状を生成する。この部分の解説も、
	第 \ref{sec:solidGen1} 節に記述がある。

 \item 41 行目では、作成した形状を描画形状として登録している。
	今回は登録する形状が一つだけなので Shape プロパティに代入することで登録を
	行っているが、複数の形状を同時に表示したい場合は fk\_ShapeViewer クラスの
	SetShape() メソッドを用いるとよい。

 \item 42,43 行目では、表裏の両面及び稜線を描画するように設定している。

 \item 45 行目では for ループ中で描画が行われるよう記述されている。
	これにより、46 〜 52 行目が実行される度に描画処理が行われるようになる。

 \item 48 行目では、アニメーションの際の頂点移動量が計算されている。
	移動は \(z\) 方向のみ行われ、移動量は
	\(\sin\frac{counter + 10j}{5\pi}\)である。counter はループの度に
	45 行目で 10 ずつ追加されているので、描画の度に移動量が異なる
	ことになる。

 \item 49 行目で初期位置に移動量が足され、50 行目で実際に各頂点を移動している。
\end{itemize}

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Viewer
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             var viewer = new fk_ShapeViewer(600, 600);
15:             var shape = new fk_IndexFaceSet();
16:             var pos = new fk_Vector[121];
17:             var moveVec = new fk_Vector();
18:             var movePos = new fk_Vector();
19:             var IFSet = new int[4*100];
20:             int i, j;
21:             double x, y;
22: 
23:             for(i = 0; i <= 10; ++i) {
24:                 for(j = 0; j <= 10; ++j) {
25:                     x = (double)(i-5);
26:                     y = (double)(j-5);
27:                     pos[i*11+j] = new fk_Vector(x, y, (x*x - y*y)/10.0);
28:                 }
29:             }
30: 
31:             for(i = 0; i < 10; i++) {
32:                 for(j = 0; j < 10; j++) {
33:                     IFSet[(i*10 + j)*4 + 0] = i*11 + j;
34:                     IFSet[(i*10 + j)*4 + 1] = (i+1)*11 + j;
35:                     IFSet[(i*10 + j)*4 + 2] = (i+1)*11 + j+1;
36:                     IFSet[(i*10 + j)*4 + 3] = i*11 + j+1;
37:                 }
38:             }
39: 
40:             shape.MakeIFSet(100, 4, IFSet, 121, pos);
41:             viewer.Shape = shape;
42:             viewer.DrawMode = fk_DrawMode.FRONTBACK_POLYMODE | fk_DrawMode.LINEMODE;
43:             viewer.Scale = 10.0;
44: 
45:             for(int counter = 0; viewer.Draw() == true; counter += 10) {
46:                 for(i = 0; i <= 10; i++) {
47:                     for(j = 0; j <= 10; j++) {
48:                         moveVec.Set(0.0, 0.0, Math.Sin((double)(counter + j*40)*0.05/FK.PI));
49:                         movePos = moveVec + pos[i*11+j];
50:                         shape.MoveVPosition(i*11+j, movePos);
51:                     }
52:                 }
53:             }
54:         }
55:     }
56: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{パーティクルアニメーション}
パーティクルアニメーションとは、粒子の移動によって気流や水流などを
表現する手法である。FK システムでは、パーティクルアニメーションを作成する
ためのクラスとして fk\_Particle 及び fk\_ParticleSet クラスを用意している。
これらの細かな仕様に関しては\ref{sec:particle} 節に記述してあるが、
ここではサンプルプログラムを用いておおまかな利用法を説明する。

fk\_ParticleSet クラスは、これまで紹介したクラスとはやや利用手法が
異なっている。まず、fk\_ParticleSet クラスを継承したクラスを作成し、
いくつかの仮想関数に対して再定義を行う。あとは、getShape() 関数を
利用して fk\_Model に形状として設定したり、fk\_ShapeViewer を利用して
描画することができる。

ここでは、サンプルとして円柱の周囲を流れる水流のシミュレーションの様子を
描画するプログラムを紹介する。
\begin{center}
詳細解説
\end{center}
\begin{itemize}
 \item 10 〜 88 行目は、fk\_ParticleSet クラスを継承した「MyParticle」という
	クラスを定義している。
	継承したクラスに対し、GenMethod()、AllMethod()、IndivMethod() の
	各メソッドを再定義(上書き)することで、パーティクルの挙動を制御することなる。

 \item 17 〜 31 行目は MyParticle クラスのコンストラクタである。ここで、
	パーティクルの初期設定を行う。

 \item 19 行目の MaxSize プロパティは fk\_ParticleSet クラスのメンバで、
	パーティクル個数の最大値を設定する。もしパーティクルの個数が
	この値と等しくなったときは、NewParticle() メソッドを呼んでも
	パーティクルは新たに生成されなくなる。

 \item 20,21 行目はそれぞれ個別処理、全体処理に対するモード設定である。
	ここで true に設定しない場合、IndivMethod() や AllMethod() の
	記述は無視される。

 \item 22 〜 25 行目は、各パーティクルの色パレットを設定しているものである。
	今回は、パーティクル ID と色 ID を完全に一対一対応することにし、
	パーティクルの個数だけ色を用意している。

 \item 35 〜 44 行目では、新たにパーティクルが生成された際の処理を記述する。
	引数の P に新パーティクルのインスタンスが入っており、これに対して
	様々な設定を行う。40 行目では初期位置を、43 行目では色 ID を設定
	している。

 \item 47 〜 54 行目では、AllMethod() メソッドを再定義している。
	AllMethod() メソッドには、パーティクル集合全体に対しての処理を記述する。
	ここではランダムにパーティクルの生成を行っているだけであるが、
	パーティクル全体に対して一括の処理を記述することもできる。

 \item 57 〜 88 行目では、IndivMethod() メソッドを再定義している。
	IndivMethod 関数には、個別のパーティクルに対する処理を記述する。

 \item IndivMethod() 中では、64 〜 72 行目で速度ベクトルの設定を行っている。
	中心が原点で、\(z\) 軸に平行な半径 \(R\) の円柱の周囲を
	速度 \((-V_x, 0, 0)\) の水流が流れているとする。このとき、各地点
	\((x, y, z)\) での水流を表す偏微分方程式は以下のようなものである。
	\begin{equation}
		\frac{\partial}{\partial t}\bP =
		\bV + \frac{R^3}{2}
		\left(\frac{\bV}{r^3} -
		\frac{3 \bV \cdot \bP}{r^5} \bP \right) .
	\end{equation}
	ただし、
	\begin{equation}
		\bV = (-V_x, 0, 0), \qquad
		\bP = (x, y, 0), \qquad r = |\bP|
	\end{equation}
	である。今回は、\(\bV = (0.2, 0, 0)\)(60行目の「water」変数)、
	\(R = 15\)(61行目の「R」変数) として算出している。この式から、
	各パーティクルの速度ベクトルを算出し、72 行目で設定している。

 \item パーティクルの色は、速度が minSpeed 未満の場合は青、
	maxSpeed 以上の場合は赤とし、その中間の場合は
	赤色と青色をブレンドした色となるように設定している。
	その色値の算出と設定を 76 〜 81 行目で行っている。
	パーティクルの速度 \(s\) が \(m < s < M\) を満たすとき、
	\begin{equation}
		t = \frac{s - m}{M - m}
	\end{equation}
	とし、赤色値を\(R\)、青色値を\(B\)としたとき
	\begin{equation}
		 C = (1-t)B + tR
	\end{equation}
	という式で色値\(C\)を決定している。

 \item 84 〜 86 行目でパーティクル削除判定を行っている。
	パーティクルが \(x = -50\) よりも左へ流れてしまった場合には
	85 行目で削除を行っている。

 \item 99,102 行目では、パーティクル集合を fk\_ShapeViewer で表示するために
	SetShape() メソッドを用いている。それぞれを別 ID として登録することで、
	2つの形状を同時に表示できる。

 \item 108 行目にあるように、Handle() メソッドを用いることで
	パーティクル全体に 1 ステップ処理が行われる。その際には、設定した
	速度や加速度にしたがって各パーティクルが移動する。特に再設定
	しない限り、加速度は処理終了後も保存される。
	今回のプログラムではパーティクルの加速度は一切設定していないため、
	IndivMethod() メソッド内の 72 行目の速度設定のみが
	パーティクルの動作を決定する要因となる。

\end{itemize}

\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using FK_CLI;
  7: 
  8: namespace FK_CLI_Particle
  9: {
 10:     class MyParticle : fk_ParticleSet {
 11:         private Random rand;
 12:         private fk_Color red, blue;
 13:         private double maxSpeed, minSpeed;
 14: 
 15:         // コンストラクタ。
 16:         // ここに様々な初期設定を記述しておく。
 17:         public MyParticle()
 18:         {
 19:             MaxSize = 1000;                      // パーティクルの最大数設定
 20:             IndivMode = true;                    // 個別処理 (IndivMethod) を有効にしておく。
 21:             AllMode = true;                      // 全体処理 (AllMethod) を有効にしておく。
 22:             for(int i = 0; i < MaxSize; i++) {
 23:                 // 各パーティクルごとの初期色を設定
 24:                 SetColorPalette(i, 0.0, 1.0, 0.6);
 25:             }
 26:             rand = new Random();                 // 乱数発生器の初期化
 27:             red = new fk_Color(1.0, 0.0, 0.0);
 28:             blue = new fk_Color(0.0, 0.0, 0.5);
 29:             maxSpeed = 0.3;                      // これより速いパーティクルは全て赤
 30:             minSpeed = 0.1;                      // これより遅いパーティクルは全て青
 31:         }
 32:         
 33:         // ここにパーティクル生成時の処理を記述する。
 34:         // 引数 P には新たなパーティクルインスタンスが入る。
 35:         public override void GenMethod(fk_Particle P)
 36:         {
 37:             // 生成時の位置を(ランダムに)設定
 38:             double y = rand.NextDouble()*50.0 - 25.0;
 39:             double z = rand.NextDouble()*50.0 - 25.0;
 40:             P.Position = new fk_Vector(50.0, y, z);
 41: 
 42:             // パーティクルの色IDを設定
 43:             P.ColorID = P.ID;
 44:         }
 45: 
 46:         // ここの毎ループ時の全体処理を記述する。
 47:         public override void AllMethod()
 48:         {
 49:             for(int i = 0; i < 5; i++) {
 50:                 if(rand.NextDouble() < 0.3) {   // 発生確率は 30% (を5回)
 51:                     NewParticle();              // パーティクル生成処理
 52:                 }
 53:             }
 54:         }
 55: 
 56:         // ここに毎ループ時のパーティクル個別処理を記述する。
 57:         public override void IndivMethod(fk_Particle P)
 58:         {
 59:             fk_Vector pos, vec, tmp1, tmp2;
 60:             var water = new fk_Vector(-0.2, 0.0, 0.0);
 61:             double R = 15.0;
 62:             double r;
 63: 
 64:             pos = P.Position;        // パーティクル位置取得。
 65:             pos.z = 0.0;
 66:             r = pos.Dist();          // |p| を r に代入。
 67: 
 68:             // パーティクルの速度ベクトルを計算
 69:             tmp1 = water/(r*r*r);
 70:             tmp2 = ((3.0 * (water * pos))/(r*r*r*r*r)) * pos;
 71:             vec = water + ((R*R*R)/2.0) * (tmp1 - tmp2);
 72:             P.Velocity = vec;
 73: 
 74:             // パーティクルの色を計算。パーティクル速度が
 75:             // minSpeed ～ maxSpeed の場合は青と赤をブレンドする。
 76:             double speed = vec.Dist();
 77:             double t = (speed - minSpeed)/(maxSpeed - minSpeed);
 78:             if(t > 1.0) t = 1.0;
 79:             if(t < 0.0) t = 0.0;
 80:             fk_Color newCol = (1.0 - t)*blue + t*red;  // 色値の線形補間
 81:             SetColorPalette(P.ID, newCol);
 82: 
 83:             // パーティクルの x 成分が -50 以下になったら消去
 84:             if(pos.x < -50.0) {
 85:                 RemoveParticle(P);
 86:             }
 87:         } 
 88:     }           
 89: 
 90: 
 91:     class Program
 92:     {
 93:         static void Main(string[] args)
 94:         {
 95:             fk_ShapeViewer viewer = new fk_ShapeViewer(600, 600);
 96:             MyParticle particle = new MyParticle();
 97:             fk_Prism prism = new fk_Prism(40, 15.0, 15.0, 50.0);
 98: 
 99:             viewer.SetShape(1, prism);
100:             viewer.SetPosition(1, 0.0, 0.0, 25.0);
101:             viewer.SetDrawMode(1, fk_DrawMode.POLYMODE);
102:             viewer.SetShape(2, particle.Shape);
103:             viewer.SetDrawMode(2, fk_DrawMode.POINTMODE);
104:             viewer.Scale = 10.0;
105:  
106:             while(viewer.Draw() == true) {
107:                 for(int i = 0; i < 3; ++i) { // 3倍速再生
108:                     particle.Handle(); // パーティクルを 1 ステップ実行する。
109:                 }
110:             }
111: 
112:         }
113:     }
114: }
\end{verbatim}
\end{small}
\end{breakbox}



\section{音再生}

FK では音再生用の機能として fk\_AudioWavBuffer, fk\_AudioOggBuffer, fk\_AudioStream の
3種のクラスが用意されている。詳細はここでは解説しないが、fk\_AudioWavBuffer は WAV 形式の音データを、
fk\_AudioOggBuffer と fk\_AudioStream は Ogg-Vorbis 形式の音データを入力できる。
また、fk\_AudioWavBuffer と fk\_AudioOggBuffer は入力時にデータ全てをメモリ上に展開するのに対し、
fk\_AudioStream はストリーミング再生を行う仕様となっている。
サンプルプログラムでは、さらに「MyBGM」と「MySE」という2種のクラスを作成し、
より容易に音再生処理を制御できるように工夫している。

「MyBGM」クラスは BGM (Back Ground Music) を再生するためのクラスで、
コンストラクタで BGM ファイルの指定、
Start() で再生開始、Gain プロパティで音量制御というシンプルなものとなっている。

「MySE」は効果音(Sound Effect, 以下「SE」)を再生するためのものである。
SE は BGM とは異なり任意のタイミングで再生が開始となること、
複数の SE が同時に発生することがあること、リピート再生が行われないことなどの
差異があるため、BGM とは別クラスとして作成してある。
このクラスの機能としては、コンストラクタで入力する SE のファイル数、
LoadData() で SE ファイルの指定、StartSE() で各 SE の再生開始というものとなっている。

近年のリアルタイム 3DCG と音を同時に扱うプログラムでは、
音再生の安定性を向上するため、音再生処理はメインループとは別のスレッドにして、
マルチスレッドプログラムによって制御することが多い。
今回紹介するプログラムも、C\# でマルチスレッドを行うための仕組みの一つである
「Task」という仕組みを利用している。Task に関する解説はここでは割愛するが、
このサンプルにある機能で十分な場合はこれをコピーして利用しても差し支えない。
また、より高機能を必要とする場合は MyBGM や MySE クラスをさらに拡張して用いるとよいだろう。
\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using System.Threading;
  7: using FK_CLI;
  8: 
  9: namespace FK_CLI_Audio
 10: {
 11:     // BGM用クラス
 12:     class MyBGM : IDisposable
 13:     {
 14:         public bool EndStatus { get; set; } // 終了指示用プロパティ
 15:         private fk_AudioStream bgm;
 16:         private bool openStatus;
 17: 
 18:         // コンストラクタ 引数は音源ファイル名 (Ogg 形式)
 19:         public MyBGM(string argFileName)
 20:         {
 21:             EndStatus = false;
 22:             bgm = new fk_AudioStream();
 23:             openStatus = bgm.Open(argFileName);
 24:             if(openStatus == false)
 25:             {
 26:                 Console.WriteLine("Audio File Open Error.");
 27:             }
 28:         }
 29: 
 30:         // BGM再生処理
 31:         public void Start()
 32:         {
 33:             if(openStatus == false) return;
 34:             bgm.LoopMode = true;
 35:             bgm.Gain = 0.5;
 36:             while(EndStatus == false)
 37:             {
 38:                 bgm.Play();
 39:                 Thread.Sleep(50);
 40:             }
 41:         }
 42: 
 43:         // 音量用プロパティ
 44:         public double Gain
 45:         {
 46:             set
 47:             {
 48:                 bgm.Gain = value;
 49:             }
 50:         }
 51: 
 52:         // スレッド終了時処理
 53:         public void Dispose()
 54:         {
 55:             bgm.Dispose();
 56:         }
 57:     }
 58: 
 59:     // Sound Effect (SE) 用クラス
 60:     class MySE : IDisposable
 61:     {
 62:         public bool EndStatus { get; set; } // 終了指示用プロパティ
 63:         private fk_AudioWavBuffer [] se;
 64:         private bool [] openStatus;
 65:         private bool [] playStatus;
 66: 
 67:         // コンストラクタ 引数は音源の個数
 68:         public MySE(int argNum)
 69:         {
 70:             EndStatus = false;
 71:             if(argNum < 1) return;
 72:             se = new fk_AudioWavBuffer [argNum];
 73:             openStatus = new bool [argNum];
 74:             playStatus = new bool [argNum];
 75: 
 76:             for(int i = 0; i < argNum; i++)
 77:             {
 78:                 se[i] = new fk_AudioWavBuffer();
 79:                 openStatus[i] = false;
 80:                 playStatus[i] = false;
 81:             }
 82:         }
 83: 
 84:         // SE音源読み込みメソッド (WAV 形式)
 85:         public bool LoadData(int argID, string argFileName)
 86:         {
 87:             if(argID < 0 || argID >= se.Length)
 88:             {
 89:                 return false;
 90:             }
 91: 
 92:             openStatus[argID] = se[argID].Open(argFileName);
 93:             if(openStatus[argID] == false)
 94:             {
 95:                 Console.WriteLine("Audio File ({0}) Open Error.", argFileName);
 96:             }
 97:             se[argID].LoopMode = false;
 98:             se[argID].Gain = 0.5;
 99:             return true;
100:         }
101: 
102:         // SE開始メソッド
103:         public void StartSE(int argID)
104:         {
105:             if(argID < 0 || argID >= se.Length) return;
106:             playStatus[argID] = true;
107:             se[argID].Seek(0.0);
108:         }
109: 
110:         // SE再生処理
111:         public void Start()
112:         {
113:             int i;
114: 
115:             for(i = 0; i < se.Length; i++)
116:             {
117:                 if(openStatus[i] == false) return;
118:             }
119: 
120:             while(EndStatus == false)
121:             {
122:                 for(i = 0; i < se.Length; i++)
123:                 {
124:                     if(playStatus[i] == true)
125:                     {
126:                         playStatus[i] = se[i].Play();
127:                     }
128:                 }
129:                 Thread.Sleep(10);
130:             }
131:         }
132: 
133:         // スレッド終了時処理
134:         public void Dispose()
135:         {
136:             for(int i = 0; i < se.Length; i++)
137:             {
138:                 se[i].Dispose();
139:             }
140:         }
141:     }
142: 
143:     class Program
144:     {
145:         static void Main(string[] args)
146:         {
147:             // 組込マテリアル初期化
148:             fk_Material.InitDefault();          
149: 
150:             // ウィンドウの各種設定
151:             var win = new fk_AppWindow();
152:             win.CameraPos = new fk_Vector(0.0, 1.0, 20.0);
153:             win.CameraFocus = new fk_Vector(0.0, 1.0, 0.0);
154:             win.Size = new fk_Dimension(600, 600);
155:             win.BGColor = new fk_Color(0.6, 0.7, 0.8);
156:             win.ShowGuide(fk_GuideMode.GRID_XZ);
157: 
158:             // 立方体の各種設定
159:             var block = new fk_Block(1.0, 1.0, 1.0);
160:             var blockModel = new fk_Model();
161:             blockModel.Shape = block;
162:             blockModel.GlMoveTo(3.0, 3.0, 0.0);
163:             blockModel.Material = fk_Material.Yellow;
164:             win.Entry(blockModel);
165: 
166:             // BGMの各種設定
167:             var bgm = new MyBGM("epoq.ogg");
168:             var bgmTask = new Task(bgm.Start);
169:             double volume = 0.5;
170:             
171:             // SEの各種設定
172:             var se = new MySE(2);
173:             var seTask = new Task(se.Start);
174:             se.LoadData(0, "MIDTOM2.wav");
175:             se.LoadData(1, "SDCRKRM.wav");
176: 
177:             win.Open();
178:             bgmTask.Start(); // BGM スレッド開始
179:             seTask.Start();  // SE スレッド開始
180: 
181:             var origin = new fk_Vector(0.0, 0.0, 0.0);
182: 
183:             while(win.Update())
184:             {
185:                 blockModel.GlRotateWithVec(origin, fk_Axis.Y, FK.PI/360.0);
186: 
187:                 // 上矢印キーで BGM 音量アップ
188:                 if(win.GetSpecialKeyStatus(fk_SpecialKey.UP, fk_SwitchStatus.DOWN) == true)
189:                 {
190:                     if(volume < 1.0) volume += 0.1;
191:                 }
192: 
193:                 // 下矢印キーで BGM 音量ダウン
194:                 if(win.GetSpecialKeyStatus(fk_SpecialKey.DOWN, fk_SwitchStatus.DOWN) == true)
195:                 {
196:                     if(volume > 0.0) volume -= 0.1;
197:                 }
198: 
199:                 // Z キーで 0 番の SE を再生開始
200:                 if(win.GetKeyStatus('Z', fk_SwitchStatus.DOWN) == true)
201:                 {
202:                     se.StartSE(0);
203:                 }
204: 
205:                 // X キーで 1 番の SE を再生開始
206:                 if(win.GetKeyStatus('X', fk_SwitchStatus.DOWN) == true)
207:                 {
208:                     se.StartSE(1);
209:                 }
210: 
211:                 bgm.Gain = volume;
212:             }
213: 
214:             // BGM 変数と SE 変数に終了を指示
215:             bgm.EndStatus = true;
216:             se.EndStatus = true;
217: 
218:             // BGM, SE 両スレッドが終了するまで待機
219:             Task.WaitAll(new[] { bgmTask, seTask });
220:         }
221:     }
222: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{スプライト表示}
\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Sprite
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             fk_Material.InitDefault();
15: 
16:             // 各種変数生成
17:             var window = new fk_AppWindow();
18:             var sprite = new fk_SpriteModel();
19:             var block = new fk_Block(1.0, 1.0, 1.0);
20:             var model = new fk_Model();
21:             var origin = new fk_Vector(0.0, 0.0, 0.0);
22: 
23:             // フォントデータ入力
24:             if(sprite.InitFont("rm1b.ttf") == false) {
25:                 Console.WriteLine("Font Error");
26:             }
27: 
28:             // フォント設定
29:             sprite.Text.MonospaceMode = true;
30:             sprite.Text.MonospaceSize = 12;
31:             window.Entry(sprite);
32: 
33:             // 立方体設定
34:             model.Shape = block;
35:             model.GlMoveTo(0.0, 6.0, 0.0);
36:             model.Material = fk_Material.Yellow;
37:             window.Entry(model);
38: 
39:             // ウィンドウ設定
40:             window.CameraPos = new fk_Vector(0.0, 5.0, 20.0);
41:             window.CameraFocus = new fk_Vector(0.0, 5.0, 0.0);
42:             window.Size = new fk_Dimension(800, 600);
43:             window.BGColor = new fk_Color(0.6, 0.7, 0.8);
44:             window.ShowGuide(fk_GuideMode.GRID_XZ);
45:             window.Open();
46:  
47:             for(int count = 0;  window.Update() == true; count++) {
48:                 // 文字列生成
49:                 string str = "count = " + count.ToString();
50: 
51:                 // 文字列をスプライトに設定
52:                 sprite.DrawText(str, true);
53: 
54:                 // スプライト配置設定
55:                 sprite.SetPositionLT(-240.0, 230.0);
56: 
57:                 // 立方体を回転させる
58:                 model.GlRotateWithVec(origin, fk_Axis.Y, FK.PI/360.0);
59:             }
60:         }
61:     }
62: }
\end{verbatim}
\end{small}
\end{breakbox}
