\chapter{サンプルプログラム} \label{chap:sample}
\section{基本的形状の生成と親子関係}
次に掲載するプログラムは、原点付近に1個の直方体と2本の線分を作成し
表示するプログラムである。ただ表示するだけでは面白くないので、線分を
直方体の子モデルにし、直方体を回転させると線分も一緒に回転することを
試してみる。また、視点も最初は遠方に置いて段々近づけていき、ある程度まで
接近したらひねりを加えてみる。

\begin{center}
詳細解説
\end{center}

\begin{itemize}

\item 2 行目の using 文は、FK システムを使用する場合に必ず記述する必要がある。

\item 11 行目で標準組込マテリアルの初期化を行っている。
      26行目で直方体のマテリアルに組込マテリアルを使用しているが、
      このように組込マテリアルを利用する場合はそれより前に初期化を行う必要がある。

\item 20 行目で FPS (リフレッシュレート) の設定を行っているが、
	FPS プロパティに 0 を代入すると FPS 制御を行わずに最高速で表示する。
	(ただし、環境によっては自動的に FPS 制御が行われる場合がある。)

\item 23 行目以降で直方体の生成を行っている。
      基本的には、モデルと形状を用意し、モデルの Shape プロパティに形状を設定しておき、
      モデルに対して各種の設定を行うというスタイルとなる。
      作成したモデルは 27 行目にあるようにウィンドウに登録を行わないと表示されないので
      注意が必要である。

\item 30 行目では、線分形状の端点となる各点の位置ベクトルを配列として生成している。
	この時点では pos 内の各変数のインスタンスはまだ確保されていないため、
	31,32 行目のように new によってインスタンスを生成する必要があることに注意する。

\item 35,36 行目ではそれぞれ線分形状と線分モデルを配列として生成している。
	これも前述した pos と同様、38 行目や 40 行目にあるようにインスタンスを new で
	用意する必要がある。

\item 42 行目では、lineModel[i] の親モデルを blockModel に設定している。
	親子関係は、このように Parent プロパティに親モデルとなる fk\_Model 型インスタンスを
	設定する方法がもっとも標準的なものである。
	これにより、各線分モデルは直方体モデルの動きに追従するようになる。
	しかし、親子関係は表示属性にはなんら影響はしないため、
	各線分を表示するためには 43 行目にあるようにウィンドウへの登録が必要となる。
	
\item 45、46 行目で、線分に対して色設定を行っている。
	どのような形状であっても、線に対して色を設定する場合は
	LineColor プロパティを用いる。

\item 49 〜 53 行目で、カメラ(視点)モデルの設定を行っている。
	カメラモデルは通常の fk\_Model インスタンスを準備すればよく、
	このサンプルの場合は位置を \((0,0, 2000)\)、方向を原点に向け、
	ウィンドウの上方向が \((0, 1, 0)\) になるように設定している。
	ある fk\_Model 型インスタンスをカメラモデルとして設定するには、
	54 行目にあるように fk\_AppWindow クラスの CameraModel プロパティに
	設定を行えばよい。設定後にカメラモデルを動作させれば視点も動的に変化し、
	任意のタイミングで別のインスタンスに変更することも可能である。
	
\item 58 行目の for 文中にある Update() メソッドは2つの働きがある。
	まず、現在のモデル設定に従って画面の描画を更新する。
	また、そのタイミングでウィンドウが消去されていないかをチェックし、
	もし消去されていた場合は false を返し、正常な場合は true を返す。

	ウィンドウは、画面上で「ESC」ボタンが押されていたり、
	ウィンドウが OS 内の機能で強制的に閉じられた場合に消去される。

 \item 63 行目で、直方体 (と子モデルである線分) を Y 軸中心に
	回転させている。回転角度は、\(\pi/300 = 0.6 ^{\circ}\) である。
	ここにある「Math.PI」は C\# で利用できる円周率を表す。

 \item 65 行目で、常にカメラの注視点が原点に向くように補正を行っている。

 \item 66 行目で、count が 1000 を超えた場合に
	視点にひねりを加えている。
\end{itemize} ~
\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using FK_CLI;
 3: 
 4: namespace FK_CLI_Box
 5: {
 6:     class Program
 7:     {
 8:         static void Main(string[] args)
 9:         {
10:             // マテリアル情報の初期化
11:             fk_Material.InitDefault();
12: 
13:             // ウィンドウ生成
14:             var win = new fk_AppWindow();
15: 
16:             // ウィンドウサイズ設定
17:             win.Size = new fk_Dimension(600, 600);
18: 
19:             // Frame Per Seconds (画面更新速度) の設定
20:             win.FPS = 60;
21: 
22:             // 直方体モデル生成
23:             var blockModel = new fk_Model();
24:             var block = new fk_Block(50.0, 70.0, 40.0);
25:             blockModel.Shape = block;
26:             blockModel.Material = fk_Material.Yellow;
27:             win.Entry(blockModel);
28: 
29:             // 線分モデル生成
30:             fk_Vector[] pos = new fk_Vector[4];
31:             pos[0] = new fk_Vector(0.0, 100.0, 0.0);
32:             pos[1] = new fk_Vector(100.0, 0.0, 0.0);
33:             pos[2] = -pos[0];
34:             pos[3] = -pos[1];
35:             fk_Line[] line = new fk_Line[2];
36:             fk_Model[] lineModel = new fk_Model[2];
37:             for(int i = 0; i < 2; i++) {
38:                 line[i] = new fk_Line();
39:                 line[i].PushLine(pos[2*i], pos[2*i + 1]);
40:                 lineModel[i] = new fk_Model();
41:                 lineModel[i].Shape = line[i];
42:                 lineModel[i].Parent = blockModel;
43:                 win.Entry(lineModel[i]);
44:             }
45:             lineModel[0].LineColor = new fk_Color(1.0, 0.0, 0.0);
46:             lineModel[1].LineColor = new fk_Color(0.0, 1.0, 0.0);
47: 
48:             // カメラモデル設定
49:             var camera = new fk_Model();
50:             camera.GlMoveTo(0.0, 0.0, 2000.0);
51:             camera.GlFocus(0.0, 0.0, 0.0);
52:             camera.GlUpvec(0.0, 1.0, 0.0);
53:             win.CameraModel = camera;
54:             win.Open();
55: 
56:             var origin = new fk_Vector(0.0, 0.0, 0.0);
57: 
58:             for(int count = 0; win.Update() == true; count++) {
59:                 // カメラ前進
60:                 camera.GlTranslate(0.0, 0.0, -1.0);
61: 
62:                 // ブロックを y 軸中心に回転
63:                 blockModel.GlRotateWithVec(origin, fk_Axis.Y, Math.PI/300.0);
64: 
65:                 // カメラの注視点を原点に向ける
66:                 camera.GlFocus(origin);
67: 
68:                 // カウンターが1000を上回ったらカメラをz軸中心に回転
69:                 if (count >= 1000) camera.LoRotateWithVec(origin, fk_Axis.Z, Math.PI/500.0);
70:             }
71:         }
72:     }
73: }
\end{verbatim}
\end{small}
\end{breakbox}
~

また、以下のソースコードは、同様のプログラムを F\# で記述したものである。
C\# 版のコードと比較することで大体の F\# の文法を把握できるだろう。\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: open System
 2: open FK_CLI
 3: 
 4: module FK_Box =
 5: 
 6:     // ウィンドウ生成
 7:     let win = new fk_AppWindow()
 8: 
 9:     // マテリアル初期化
10:     fk_Material.InitDefault()
11: 
12:     // 直方体モデル生成
13:     let blockModel = new fk_Model()
14:     let block = new fk_Block(50.0, 70.0, 40.0)
15:     blockModel.Shape <- block
16:     blockModel.Material <- fk_Material.Yellow
17:     win.Entry(blockModel)
18: 
19:     // 線分モデル生成
20:     let pos : fk_Vector array = Array.init 4 (fun i -> new fk_Vector())
21:     pos.[0].Set(0.0, 100.0, 0.0)
22:     pos.[1].Set(100.0, 0.0, 0.0)
23:     pos.[2] <- -pos.[0]
24:     pos.[3] <- -pos.[1]
25: 
26:     let line : fk_Line array = Array.init 2 (fun i -> new fk_Line())
27:     let lineModel : fk_Model array = Array.init 2 (fun i -> new fk_Model())
28: 
29:     for i = 0 to 1 do
30:         line.[i].PushLine(pos.[2*i], pos.[2*i + 1])
31:         lineModel.[i].Shape <- line.[i]
32:         lineModel.[i].Parent <- blockModel
33:         win.Entry(lineModel.[i])
34: 
35:     lineModel.[0].LineColor <- new fk_Color(1.0, 0.0, 0.0)
36:     lineModel.[1].LineColor <- new fk_Color(0.0, 1.0, 0.0)
37: 
38:     // カメラモデル生成
39:     let camera = new fk_Model()
40:     camera.GlMoveTo(0.0, 0.0, 2000.0) |> ignore
41:     camera.GlFocus(0.0, 0.0, 0.0) |> ignore
42:     camera.GlUpvec(0.0, 1.0, 0.0) |> ignore
43:     win.CameraModel <- camera
44: 
45:     // ウィンドウ生成
46:     win.Open()
47: 
48:     let org = new fk_Vector(0.0, 0.0, 0.0)
49:     let count = ref 0
50:     while win.Update() = true do
51:         incr count
52:         camera.GlTranslate(0.0, 0.0, -1.0) |> ignore
53:         blockModel.GlRotateWithVec(org, fk_Axis.Y, Math.PI/300.0) |> ignore
54:         camera.GlFocus(org) |> ignore
55:         if !count >= 1000 then camera.LoRotateWithVec(org, fk_Axis.Z, Math.PI/300.0) |> ignore
\end{verbatim}
\end{small}
\end{breakbox}

\section{Boid アルゴリズムによる群集シミュレーション}
Boid アルゴリズムとは、群集シミュレーションを実現するための最も基本的なアルゴリズムである。
このアルゴリズムでは、群を構成する各エージェントは以下の3つの動作規則を持つ。

\begin{description}
\item[分離 (Separation):] ~ \\
	エージェントが、他のエージェントとぶつからないように距離を取る。
	\myfig{Fig:Boid-Sep}{./Fig/Boid-Sep.eps}{width=4truecm}{分離の概念図}{0mm}

\item[整列 (Alignment):] ~ \\
	エージェントが周囲のエージェントと方向ベクトルと速度ベクトルを合わせる。
	\myfig{Fig:Boid-Ali}{./Fig/Boid-Ali.eps}{width=4truecm}{整列の概念図}{0mm}

\item[結合 (Cohesion):] ~ \\
	エージェントは、群れの中心方向に集まるようにする。
	\myfig{Fig:Boid-Coh}{./Fig/Boid-Coh.eps}{width=4truecm}{結合の概念図}{0mm}

\end{description}
これを実現するための計算式は、以下の通りである。
なお、\(n\)個のエージェントの識別番号を\(i \; (0, 1, \cdots, n-1)\) とし、
それぞれの位置ベクトル、速度ベクトルを \(\bP_i, \bV_i\) とする。

\begin{description}
 \item[分離:] ~ \\
エージェント\(i\)が\(j\)から離れたければ、元の速度ベクトルに対し
\(\lvec{\bP_j\bP_i} = \bP_i - \bP_j\) を合わせれば良いので、
\(\alpha\)をやや小さめの適当な数値として
\begin{equation}
	{\bV_i}' = \bV_i + \alpha \frac{\bP_i - \bP_j}{|\bP_i - \bP_j|}
\end{equation}
とすればよい。これを近隣にあるエージェント全てにおいて計算すればよい。
近隣エージェントの番号集合を\(N\)とすれば、
\begin{equation}
	{\bV_i}' = \bV_i + \alpha \sum_{j \in N}\frac{\bP_i - \bP_j}{|\bP_i - \bP_j|}
\end{equation}
となる。

\item[整列:] ~ \\
周囲のエージェントの速度ベクトルの平均を出し、その分を自身の速度ベクトルに足せばよい。
数式としては以下の通り。
\begin{equation}
	{\bV_i}' = \frac{\bV_i + \beta\sum_{j \in N}\bV_j}{|\bV_i + \beta\sum_{j \in N}\bV_j|} .
\end{equation}

\item[結合:] ~ \\
群れ全体の重心\(\bG\)を算出し、そこに向かうようなベクトルを速度ベクトルに追加する。
\begin{equation}
	{\bV_i}' = \bV_i + \gamma (\frac{\sum\bP_i}{n} - \bP_i) .
\end{equation}
\end{description}

以下、C\# と F\# によるサンプルプログラムを掲載する。
これらついての詳細な解説は割愛するが、
各エージェントを表す「Agent」クラスと、群を表す「Boid」クラスを構築することにより、
メインループがかなりシンプルになっていることがわかる。また、
「S」「A」「C」キーを押すと、それぞれ「分離」「整列」「結合」規則を無効にするように
なっているので、各規則がどのようにエージェントの動作に影響しているかがわかるだろう。

F\# は C\# に比べるとかなりコンパクトなコードになっている。
F\# は、配列やリストに対しての各種操作で強力な機能を持つ文法となっており、
今回のようなシミュレーションプログラムの記述には大きな威力を発揮することがわかる。

\begin{center}
C\#版
\end{center}
\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using FK_CLI;
  3: 
  4: namespace FK_CLI_Boid
  5: {
  6:     // エージェント用クラス
  7:     class Agent
  8:     {
  9:         private fk_Model model;
 10:         private fk_Vector newVec;
 11:         private const double SPEED = 0.05;   // 速度設定値
 12:         public const double AREASIZE = 15.0; // 移動領域の広さ設定値
 13: 
 14:         // コンストラクタ
 15:         public Agent()
 16:         {
 17:             model = new fk_Model();
 18:             model.Material = fk_Material.Red;
 19:             model.GlVec(fk_Math.DRand(-1.0, 1.0), fk_Math.DRand(-1.0, 1.0), 0.0);
 20:             model.GlMoveTo(fk_Math.DRand(-AREASIZE, AREASIZE),
 21:                            fk_Math.DRand(-AREASIZE, AREASIZE), 0.0);
 22:         }
 23: 
 24:         // 位置ベクトル用プロパティ
 25:         public fk_Vector Pos
 26:         {
 27:             get
 28:             {
 29:                 return model.Position;
 30:             }
 31:         }
 32: 
 33:         // 方向ベクトル用プロパティ
 34:         public fk_Vector Vec
 35:         {
 36:             set
 37:             {
 38:                 newVec = value;
 39:             }
 40:             get
 41:             {
 42:                 return model.Vec;
 43:             }
 44:         }
 45: 
 46:         // 形状参照プロパティ
 47:         public fk_Shape Shape
 48:         {
 49:             set
 50:             {
 51:                 model.Shape = value;
 52:             }
 53:         }
 54: 
 55:         // ウィンドウへのモデル登録
 56:         public void Entry(fk_AppWindow argWin)
 57:         {
 58:             argWin.Entry(model);
 59:         }
 60: 
 61:         // 前進処理
 62:         public void Forward()
 63:         {
 64:             model.GlVec(newVec);
 65:             model.LoTranslate(0.0, 0.0, -SPEED);
 66:         }
 67:     }
 68: 
 69:     // 群衆用クラス
 70:     class Boid
 71:     {
 72:         private Agent [] agent; // エージェント用配列
 73:         private fk_Cone cone;   // 形状 (円錐)
 74: 
 75:         private double paramA, paramB, paramC, paramLA, paramLB;
 76: 
 77:         public Boid(int argNum)
 78:         {
 79:             fk_Material.InitDefault();
 80:             cone = new fk_Cone(16, 0.4, 1.0);
 81:             if(argNum < 0) return;
 82:             agent = new Agent[argNum];
 83: 
 84:             for(int i = 0; i < argNum; ++i)
 85:             {
 86:                 agent[i] = new Agent();
 87:                 agent[i].Shape = cone;
 88:             }
 89: 
 90:             paramA = 0.2;
 91:             paramB = 0.02;
 92:             paramC = 0.01;
 93:             paramLA = 3.0;
 94:             paramLB = 5.0;
 95:         }
 96: 
 97:         public void SetParam(double argA, double argB, double argC, double argLA, double argLB)
 98:         {
 99:             paramA = argA;
100:             paramB = argB;
101:             paramC = argC;
102:             paramLA = argLA;
103:             paramLB = argLB;
104:         }
105: 
106:         public void SetWindow(fk_AppWindow argWin)
107:         {
108:             foreach(Agent M in agent)
109:             {
110:                 M.Entry(argWin);
111:             }
112:         }
113: 
114:         // 群集の更新処理
115:         public void Update(bool argSMode, bool argAMode, bool argCMode)
116:         {
117:             var gVec = new fk_Vector();
118:             var diff = new fk_Vector();
119:             fk_Vector [] pArray = new fk_Vector[agent.Length];
120:             fk_Vector [] vArray = new fk_Vector[agent.Length];
121: 
122:             // 位置ベクトルと速度ベクトルのコピー
123:             for(int i = 0; i < agent.Length; i++)
124:             {
125:                 pArray[i] = agent[i].Pos;
126:                 vArray[i] = agent[i].Vec;
127:                 gVec += pArray[i];
128:             }
129: 
130:             // 群集重心の算出
131:             gVec /= (double)(agent.Length);
132: 
133:             for(int i = 0; i < agent.Length; i++)
134:             {
135:                 fk_Vector p = new fk_Vector(pArray[i]);
136:                 fk_Vector v = new fk_Vector(vArray[i]);
137:                 for(int j = 0; j < agent.Length; j++)
138:                 {
139:                     if(i == j) continue;
140:                     diff = p - pArray[j];
141:                     double dist = diff.Dist();
142: 
143:                     // 分離 (Separation) 処理
144:                     if (dist < paramLA && argSMode == true)
145:                     {
146:                         v += paramA * diff / (dist*dist);
147:                     }
148: 
149:                     // 整列 (Alignment) 処理
150:                     if(dist < paramLB && argAMode == true)
151:                     {
152:                         v += paramB * vArray[j];
153:                     }
154:                 }
155: 
156:                 // 結合 (Cohesion) 処理
157:                 if(argCMode == true)
158:                 {
159:                     v += paramC * (gVec - pArray[i]);
160:                 }
161: 
162:                 // 領域の外側に近づいたら方向修正
163:                 if (Math.Abs(p.x) > Agent.AREASIZE && p.x * v.x > 0.0 && Math.Abs(v.x) > 0.01)
164:                 {
165:                     v.x -= v.x * (Math.Abs(pArray[i].x) - Agent.AREASIZE)*0.2;
166:                 }
167: 
168:                 if(Math.Abs(p.y) > Agent.AREASIZE && p.y * v.y > 0.0 && Math.Abs(v.y) > 0.01)
169:                 {
170:                     v.y -= v.y * (Math.Abs(pArray[i].y) - Agent.AREASIZE)*0.2;
171:                 }
172: 
173:                 v.z = 0.0;
174:                 agent[i].Vec = v;
175:             }
176: 
177:             foreach(Agent M in agent) {
178:                 M.Forward();
179:             }
180:         }
181:     }
182: 
183:     class Program
184:     {
185:         static void Main(string[] args)
186:         {
187:             var win = new fk_AppWindow();
188:             var boid = new Boid(200);
189: 
190:             boid.SetWindow(win);
191: 
192:             // ウィンドウ各種設定
193:             win.Size = new fk_Dimension(800, 800);
194:             win.BGColor = new fk_Color(0.6, 0.7, 0.8);
195:             win.ShowGuide(fk_Guide.GRID_XY);
196:             win.CameraPos = new fk_Vector(0.0, 0.0, 80.0);
197:             win.CameraFocus = new fk_Vector(0.0, 0.0, 0.0);
198:             win.TrackBallMode = true;
199: 
200:             win.Open();
201: 
202:             while(win.Update() == true)
203:             {
204:                 // Sキーで「Separate(分離)」を無効に
205:                 bool sMode = win.GetKeyStatus('S', fk_Switch.RELEASE);
206: 
207:                 // Aキーで「Alignment(整列)」を無効に
208:                 bool aMode = win.GetKeyStatus('A', fk_Switch.RELEASE);
209: 
210:                 // Cキーで「Cohesion(結合)」を無効に
211:                 bool cMode = win.GetKeyStatus('C', fk_Switch.RELEASE);
212: 
213:                 // 群集の更新処理
214:                 boid.Update(sMode, aMode, cMode);
215:             }
216:         }
217:     }
218: }
\end{verbatim}
\end{small}
\end{breakbox}
\begin{center}
F\#版
\end{center}
\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: open System
  2: open FK_CLI
  3: 
  4: // エージェント用クラス
  5: type Agent(argID:int) = class
  6:     // コンストラクタ
  7:     let model = new fk_Model()
  8:     let newVec = new fk_Vector()
  9:     let id = argID
 10: 
 11:     do
 12:         model.Material <- fk_Material.Red
 13: 
 14:     // (ここまでがコンストラクタ)
 15: 
 16:     // ID プロパティ
 17:     member this.ID with get() = id
 18: 
 19:     // 位置ベクトルプロパティ
 20:     member this.Pos with get() = model.Position
 21: 
 22:     // 方向ベクトルプロパティ
 23:     member this.Vec with get() = model.Vec
 24:                     and set(v:fk_Vector) = newVec.Set(v.x, v.y, v.z)
 25: 
 26:     // 形状プロパティ
 27:     member this.Shape with get() = model.Shape
 28:                       and set(s:fk_Shape) = model.Shape <- s 
 29: 
 30:     // 初期化メソッド
 31:     member this.Init(argSize: double, argRand: Random) =
 32:         model.GlVec(argRand.NextDouble()*2.0 - 1.0,
 33:                     argRand.NextDouble()*2.0 - 1.0,
 34:                     0.0) |> ignore
 35:         model.GlMoveTo(argRand.NextDouble() * argSize * 2.0 - argSize,
 36:                        argRand.NextDouble() * argSize * 2.0 - argSize,
 37:                        0.0) |> ignore
 38: 
 39:     // ウィンドウ登録メソッド
 40:     member this.Entry(argWin: fk_AppWindow) =
 41:         argWin.Entry(model)
 42: 
 43:     // 前進メソッド
 44:     member this.Forward() =
 45:         model.GlVec(newVec) |> ignore
 46:         model.LoTranslate(0.0, 0.0, -0.05) |> ignore
 47:         model.GlMoveTo(this.Pos.x, this.Pos.y, 0.0) |> ignore
 48: end;;
 49: 
 50: // 群集クラス
 51: type Boid(argNum) = class
 52:     // コンストラクタ
 53:     do
 54:         fk_Material.InitDefault()
 55: 
 56:     // 乱数発生器生成
 57:     let rand = new Random()
 58: 
 59:     // エージェント配列生成
 60:     let agent : Agent array = [|for i in 0 .. argNum - 1 -> new Agent(i)|]
 61: 
 62:     // 形状生成
 63:     let cone = new fk_Cone(16, 0.4, 1.0)
 64: 
 65:     // 各種パラメータ設定
 66:     let IAREA = 15
 67:     let AREASIZE = double(IAREA)
 68:     let paramA = 0.2
 69:     let paramB = 0.02
 70:     let paramC = 0.01
 71:     let paramLA = 3.0
 72:     let paramLB = 5.0
 73:     do
 74:         // 各エージェントの初期化
 75:         agent |> Array.iter (fun a -> a.Init(AREASIZE, rand))
 76:         agent |> Array.iter (fun a -> a.Shape <- cone)
 77: 
 78:     // (ここまでがコンストラクタ)
 79: 
 80:     // ウィンドウ登録メソッド
 81:     member this.SetWindow(argWin: fk_AppWindow) =
 82:         agent |> Array.iter (fun a -> a.Entry(argWin))
 83: 
 84:     // 各エージェント動作メソッド
 85:     member this.Forward(argSMode: bool, argAMode: bool, argCMode: bool) =
 86:         let pA = agent |> Array.map (fun a -> a.Pos) // 位置ベクトル配列
 87:         let vA = agent |> Array.map (fun a -> a.Vec) // 方向ベクトル配列
 88:         let iA = agent |> Array.map (fun a -> a.ID)  // ID配列
 89:         let vArray = Array.zip3 pA vA iA             // 結合リスト作成
 90: 
 91:         let newV0 = vArray |> Array.map (fun (p1, v1, i) ->
 92:             let mutable tmpV = v1
 93:             for j = 0 to vArray.Length - 1 do
 94:                 if i <> j then
 95:                     let diff = p1 - pA.[j]
 96:                     let dist = diff.Dist()
 97:                     // 分離ルール
 98:                     if dist < paramLA && argSMode then
 99:                         tmpV <- tmpV + paramA * diff / (dist*dist)
100: 
101:                     // 整列ルール
102:                     if dist < paramLB && argAMode then
103:                         tmpV <- tmpV + paramB * vA.[j]
104:             tmpV
105:         )
106: 
107:         // 重心計算
108:         let gVec = (Array.reduce (fun x y -> x + y) pA) / (double pA.Length)
109: 
110:         // 結合ルール
111:         let calcG (p, v) = v + paramB * (gVec - p)
112:         let newV1 =
113:             if argCMode then
114:                 Array.zip pA newV0 |> Array.map calcG
115:             else
116:                 Array.copy newV0
117: 
118:         // 領域外判定用メソッド
119:         let xOut (p:fk_Vector, v:fk_Vector) = Math.Abs(p.x) > AREASIZE && p.x * v.x > 0.0
120:         let yOut (p:fk_Vector, v:fk_Vector) = Math.Abs(p.y) > AREASIZE && p.y * v.y > 0.0
121: 
122:         // 反転メソッド
123:         let vNegate (p:double, v:double) = v - v * (Math.Abs(p) - AREASIZE) * 0.2
124: 
125:         // 領域の外側に近づいたら方向修正するメソッド
126:         let xNegate (p:fk_Vector, v:fk_Vector) =
127:             if xOut (p, v) then
128:                 new fk_Vector(vNegate(p.x, v.x), v.y, 0.0)
129:             else
130:                 v
131: 
132:         let yNegate (p: fk_Vector, v:fk_Vector) =
133:             if yOut (p, v) then
134:                 new fk_Vector(v.x, vNegate(p.y, v.y), 0.0)
135:             else
136:                 v
137: 
138:         // 方向修正を行ったエージェントリストを取得
139:         let newV2 = Array.zip pA newV1 |> Array.map xNegate
140:         let newV3 = Array.zip pA newV2 |> Array.map yNegate
141: 
142:         // エージェントに新速度設定
143:         let newAgent = Array.zip agent newV3
144:         newAgent |> Array.iter (fun (a, v) -> (a.Vec <- v))
145: 
146:         // エージェント前進
147:         agent |> Array.iter (fun a -> a.Forward())
148: 
149: end;;
150: 
151: 
152: module FK_Boid =
153:     let win = new fk_AppWindow()
154:     let boid = new Boid(150)
155: 
156:     boid.SetWindow(win)
157: 
158:     win.Size <- new fk_Dimension(600, 600)
159:     win.BGColor <- new fk_Color(0.6, 0.7, 0.8)
160:     win.ShowGuide(fk_GuideMode.GRID_XY)
161:     win.CameraPos <- new fk_Vector(0.0, 0.0, 80.0)
162:     win.CameraFocus <- new fk_Vector(0.0, 0.0, 0.0)
163:     win.FPS <- 0
164: 
165:     win.Open()
166:     while win.Update() = true do
167:         let sMode = win.GetKeyStatus('s', fk_SwitchStatus.RELEASE)
168:         let aMode = win.GetKeyStatus('a', fk_SwitchStatus.RELEASE)
169:         let cMode = win.GetKeyStatus('c', fk_SwitchStatus.RELEASE)
170:         boid.Forward(sMode, aMode, cMode)
\end{verbatim}
\end{small}
\end{breakbox}

\section{形状の簡易表示とアニメーション} \label{sec:sampleviewer}

次のサンプルは、fk\_ShapeViewer クラスの典型的な利用法を示したものである。

このサンプルプログラムでは、23〜40行目がメッシュ形状を生成する処理を記述し、
45〜53行目がアニメーションを実現している処理となっている。


\begin{center}
詳細解説
\end{center}

\begin{itemize}
 \item 23 〜 28 行目で 11 行 11 列の行列として並んでいる状態の
	座標を計算している。その際、\(z = \dfrac{x^2 - y^2}{10}\)
	として \(z\) 成分は計算されている。

 \item 次に、31 〜 38 行目でインデックスフェースセットを表す
	配列を作成している。インデックスフェースセットに関しては、
	第 \ref{sec:solidGen1} 節を参照すること。

 \item 40 行目で実際に形状を生成する。この部分の解説も、
	第 \ref{sec:solidGen1} 節に記述がある。

 \item 41 行目では、作成した形状を描画形状として登録している。
	今回は登録する形状が一つだけなので Shape プロパティに代入することで登録を
	行っているが、複数の形状を同時に表示したい場合は fk\_ShapeViewer クラスの
	SetShape() メソッドを用いるとよい。

 \item 42,43 行目では、表裏の両面及び稜線を描画するように設定している。

 \item 45 行目では for ループ中で描画が行われるよう記述されている。
	これにより、46 〜 52 行目が実行される度に描画処理が行われるようになる。

 \item 48 行目では、アニメーションの際の頂点移動量が計算されている。
	移動は \(z\) 方向のみ行われ、移動量は
	\(\sin\frac{counter + 10j}{5\pi}\)である。counter はループの度に
	45 行目で 10 ずつ追加されているので、描画の度に移動量が異なる
	ことになる。

 \item 49 行目で初期位置に移動量が足され、50 行目で実際に各頂点を移動している。
\end{itemize}

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Viewer
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             var viewer = new fk_ShapeViewer(600, 600);
15:             var shape = new fk_IndexFaceSet();
16:             var pos = new fk_Vector[121];
17:             var moveVec = new fk_Vector();
18:             var movePos = new fk_Vector();
19:             var IFSet = new int[4*100];
20:             int i, j;
21:             double x, y;
22: 
23:             for(i = 0; i <= 10; ++i) {
24:                 for(j = 0; j <= 10; ++j) {
25:                     x = (double)(i-5);
26:                     y = (double)(j-5);
27:                     pos[i*11+j] = new fk_Vector(x, y, (x*x - y*y)/10.0);
28:                 }
29:             }
30: 
31:             for(i = 0; i < 10; i++) {
32:                 for(j = 0; j < 10; j++) {
33:                     IFSet[(i*10 + j)*4 + 0] = i*11 + j;
34:                     IFSet[(i*10 + j)*4 + 1] = (i+1)*11 + j;
35:                     IFSet[(i*10 + j)*4 + 2] = (i+1)*11 + j+1;
36:                     IFSet[(i*10 + j)*4 + 3] = i*11 + j+1;
37:                 }
38:             }
39: 
40:             shape.MakeIFSet(100, 4, IFSet, 121, pos);
41:             viewer.Shape = shape;
42:             viewer.DrawMode = fk_DrawMode.FRONTBACK_POLYMODE | fk_DrawMode.LINEMODE;
43:             viewer.Scale = 10.0;
44: 
45:             for(int counter = 0; viewer.Draw() == true; counter += 10) {
46:                 for(i = 0; i <= 10; i++) {
47:                     for(j = 0; j <= 10; j++) {
48:                         moveVec.Set(0.0, 0.0, Math.Sin((double)(counter + j*40)*0.05/Math.PI));
49:                         movePos = moveVec + pos[i*11+j];
50:                         shape.MoveVPosition(i*11+j, movePos);
51:                     }
52:                 }
53:             }
54:         }
55:     }
56: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{パーティクルアニメーション}
パーティクルアニメーションとは、粒子の移動によって気流や水流などを
表現する手法である。FK システムでは、パーティクルアニメーションを作成する
ためのクラスとして fk\_Particle 及び fk\_ParticleSet クラスを用意している。
これらの細かな仕様に関しては\ref{sec:particle} 節に記述してあるが、
ここではサンプルプログラムを用いておおまかな利用法を説明する。

fk\_ParticleSet クラスは、これまで紹介したクラスとはやや利用手法が
異なっている。まず、fk\_ParticleSet クラスを継承したクラスを作成し、
いくつかの仮想関数に対して再定義を行う。あとは、getShape() 関数を
利用して fk\_Model に形状として設定したり、fk\_ShapeViewer を利用して
描画することができる。

ここでは、サンプルとして円柱の周囲を流れる水流のシミュレーションの様子を
描画するプログラムを紹介する。
\begin{center}
詳細解説
\end{center}
\begin{itemize}
 \item 10 〜 88 行目は、fk\_ParticleSet クラスを継承した「MyParticle」という
	クラスを定義している。
	継承したクラスに対し、GenMethod()、AllMethod()、IndivMethod() の
	各メソッドを再定義(上書き)することで、パーティクルの挙動を制御することなる。

 \item 17 〜 31 行目は MyParticle クラスのコンストラクタである。ここで、
	パーティクルの初期設定を行う。

 \item 19 行目の MaxSize プロパティは fk\_ParticleSet クラスのメンバで、
	パーティクル個数の最大値を設定する。もしパーティクルの個数が
	この値と等しくなったときは、NewParticle() メソッドを呼んでも
	パーティクルは新たに生成されなくなる。

 \item 20,21 行目はそれぞれ個別処理、全体処理に対するモード設定である。
	ここで true に設定しない場合、IndivMethod() や AllMethod() の
	記述は無視される。

 \item 22 〜 25 行目は、各パーティクルの色パレットを設定しているものである。
	今回は、パーティクル ID と色 ID を完全に一対一対応することにし、
	パーティクルの個数だけ色を用意している。

 \item 35 〜 44 行目では、新たにパーティクルが生成された際の処理を記述する。
	引数の P に新パーティクルのインスタンスが入っており、これに対して
	様々な設定を行う。40 行目では初期位置を、43 行目では色 ID を設定
	している。

 \item 47 〜 54 行目では、AllMethod() メソッドを再定義している。
	AllMethod() メソッドには、パーティクル集合全体に対しての処理を記述する。
	ここではランダムにパーティクルの生成を行っているだけであるが、
	パーティクル全体に対して一括の処理を記述することもできる。

 \item 57 〜 88 行目では、IndivMethod() メソッドを再定義している。
	IndivMethod 関数には、個別のパーティクルに対する処理を記述する。

 \item IndivMethod() 中では、64 〜 72 行目で速度ベクトルの設定を行っている。
	中心が原点で、\(z\) 軸に平行な半径 \(R\) の円柱の周囲を
	速度 \((-V_x, 0, 0)\) の水流が流れているとする。このとき、各地点
	\((x, y, z)\) での水流を表す偏微分方程式は以下のようなものである。
	\begin{equation}
		\frac{\partial}{\partial t}\bP =
		\bV + \frac{R^3}{2}
		\left(\frac{\bV}{r^3} -
		\frac{3 \bV \cdot \bP}{r^5} \bP \right) .
	\end{equation}
	ただし、
	\begin{equation}
		\bV = (-V_x, 0, 0), \qquad
		\bP = (x, y, 0), \qquad r = |\bP|
	\end{equation}
	である。今回は、\(\bV = (0.2, 0, 0)\)(60行目の「water」変数)、
	\(R = 15\)(61行目の「R」変数) として算出している。この式から、
	各パーティクルの速度ベクトルを算出し、72 行目で設定している。

 \item パーティクルの色は、速度が minSpeed 未満の場合は青、
	maxSpeed 以上の場合は赤とし、その中間の場合は
	赤色と青色をブレンドした色となるように設定している。
	その色値の算出と設定を 76 〜 81 行目で行っている。
	パーティクルの速度 \(s\) が \(m < s < M\) を満たすとき、
	\begin{equation}
		t = \frac{s - m}{M - m}
	\end{equation}
	とし、赤色値を\(R\)、青色値を\(B\)としたとき
	\begin{equation}
		 C = (1-t)B + tR
	\end{equation}
	という式で色値\(C\)を決定している。

 \item 84 〜 86 行目でパーティクル削除判定を行っている。
	パーティクルが \(x = -50\) よりも左へ流れてしまった場合には
	85 行目で削除を行っている。

 \item 99,102 行目では、パーティクル集合を fk\_ShapeViewer で表示するために
	SetShape() メソッドを用いている。それぞれを別 ID として登録することで、
	2つの形状を同時に表示できる。

 \item 108 行目にあるように、Handle() メソッドを用いることで
	パーティクル全体に 1 ステップ処理が行われる。その際には、設定した
	速度や加速度にしたがって各パーティクルが移動する。特に再設定
	しない限り、加速度は処理終了後も保存される。
	今回のプログラムではパーティクルの加速度は一切設定していないため、
	IndivMethod() メソッド内の 72 行目の速度設定のみが
	パーティクルの動作を決定する要因となる。

\end{itemize}

\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using FK_CLI;
  7: 
  8: namespace FK_CLI_Particle
  9: {
 10:     class MyParticle : fk_ParticleSet {
 11:         private Random rand;
 12:         private fk_Color red, blue;
 13:         private double maxSpeed, minSpeed;
 14: 
 15:         // コンストラクタ。
 16:         // ここに様々な初期設定を記述しておく。
 17:         public MyParticle()
 18:         {
 19:             MaxSize = 1000;                      // パーティクルの最大数設定
 20:             IndivMode = true;                    // 個別処理 (IndivMethod) を有効にしておく。
 21:             AllMode = true;                      // 全体処理 (AllMethod) を有効にしておく。
 22:             for(int i = 0; i < MaxSize; i++) {
 23:                 // 各パーティクルごとの初期色を設定
 24:                 SetColorPalette(i, 0.0, 1.0, 0.6);
 25:             }
 26:             rand = new Random();                 // 乱数発生器の初期化
 27:             red = new fk_Color(1.0, 0.0, 0.0);
 28:             blue = new fk_Color(0.0, 0.0, 0.5);
 29:             maxSpeed = 0.3;                      // これより速いパーティクルは全て赤
 30:             minSpeed = 0.1;                      // これより遅いパーティクルは全て青
 31:         }
 32:         
 33:         // ここにパーティクル生成時の処理を記述する。
 34:         // 引数 P には新たなパーティクルインスタンスが入る。
 35:         public override void GenMethod(fk_Particle P)
 36:         {
 37:             // 生成時の位置を(ランダムに)設定
 38:             double y = rand.NextDouble()*50.0 - 25.0;
 39:             double z = rand.NextDouble()*50.0 - 25.0;
 40:             P.Position = new fk_Vector(50.0, y, z);
 41: 
 42:             // パーティクルの色IDを設定
 43:             P.ColorID = P.ID;
 44:         }
 45: 
 46:         // ここの毎ループ時の全体処理を記述する。
 47:         public override void AllMethod()
 48:         {
 49:             for(int i = 0; i < 5; i++) {
 50:                 if(rand.NextDouble() < 0.3) {   // 発生確率は 30% (を5回)
 51:                     NewParticle();              // パーティクル生成処理
 52:                 }
 53:             }
 54:         }
 55: 
 56:         // ここに毎ループ時のパーティクル個別処理を記述する。
 57:         public override void IndivMethod(fk_Particle P)
 58:         {
 59:             fk_Vector pos, vec, tmp1, tmp2;
 60:             var water = new fk_Vector(-0.2, 0.0, 0.0);
 61:             double R = 15.0;
 62:             double r;
 63: 
 64:             pos = P.Position;        // パーティクル位置取得。
 65:             pos.z = 0.0;
 66:             r = pos.Dist();          // |p| を r に代入。
 67: 
 68:             // パーティクルの速度ベクトルを計算
 69:             tmp1 = water/(r*r*r);
 70:             tmp2 = ((3.0 * (water * pos))/(r*r*r*r*r)) * pos;
 71:             vec = water + ((R*R*R)/2.0) * (tmp1 - tmp2);
 72:             P.Velocity = vec;
 73: 
 74:             // パーティクルの色を計算。パーティクル速度が
 75:             // minSpeed ～ maxSpeed の場合は青と赤をブレンドする。
 76:             double speed = vec.Dist();
 77:             double t = (speed - minSpeed)/(maxSpeed - minSpeed);
 78:             if(t > 1.0) t = 1.0;
 79:             if(t < 0.0) t = 0.0;
 80:             fk_Color newCol = (1.0 - t)*blue + t*red;  // 色値の線形補間
 81:             SetColorPalette(P.ID, newCol);
 82: 
 83:             // パーティクルの x 成分が -50 以下になったら消去
 84:             if(pos.x < -50.0) {
 85:                 RemoveParticle(P);
 86:             }
 87:         } 
 88:     }           
 89: 
 90: 
 91:     class Program
 92:     {
 93:         static void Main(string[] args)
 94:         {
 95:             fk_ShapeViewer viewer = new fk_ShapeViewer(600, 600);
 96:             MyParticle particle = new MyParticle();
 97:             fk_Prism prism = new fk_Prism(40, 15.0, 15.0, 50.0);
 98: 
 99:             viewer.SetShape(1, prism);
100:             viewer.SetPosition(1, 0.0, 0.0, 25.0);
101:             viewer.SetDrawMode(1, fk_DrawMode.POLYMODE);
102:             viewer.SetShape(2, particle.Shape);
103:             viewer.SetDrawMode(2, fk_DrawMode.POINTMODE);
104:             viewer.Scale = 10.0;
105:  
106:             while(viewer.Draw() == true) {
107:                 for(int i = 0; i < 3; ++i) { // 3倍速再生
108:                     particle.Handle(); // パーティクルを 1 ステップ実行する。
109:                 }
110:             }
111: 
112:         }
113:     }
114: }
\end{verbatim}
\end{small}
\end{breakbox}



\section{音再生}

FK では音再生用の機能として fk\_AudioWavBuffer, fk\_AudioOggBuffer, fk\_AudioStream の
3種のクラスが用意されている。詳細はここでは解説しないが、fk\_AudioWavBuffer は WAV 形式の音データを、
fk\_AudioOggBuffer と fk\_AudioStream は Ogg-Vorbis 形式の音データを入力できる。
また、fk\_AudioWavBuffer と fk\_AudioOggBuffer は入力時にデータ全てをメモリ上に展開するのに対し、
fk\_AudioStream はストリーミング再生を行う仕様となっている。
サンプルプログラムでは、さらに「MyBGM」と「MySE」という2種のクラスを作成し、
より容易に音再生処理を制御できるように工夫している。

「MyBGM」クラスは BGM (Back Ground Music) を再生するためのクラスで、
コンストラクタで BGM ファイルの指定、
Start() で再生開始、Gain プロパティで音量制御というシンプルなものとなっている。

「MySE」は効果音(Sound Effect, 以下「SE」)を再生するためのものである。
SE は BGM とは異なり任意のタイミングで再生が開始となること、
複数の SE が同時に発生することがあること、リピート再生が行われないことなどの
差異があるため、BGM とは別クラスとして作成してある。
このクラスの機能としては、コンストラクタで入力する SE のファイル数、
LoadData() で SE ファイルの指定、StartSE() で各 SE の再生開始というものとなっている。

近年のリアルタイム 3DCG と音を同時に扱うプログラムでは、
音再生の安定性を向上するため、音再生処理はメインループとは別のスレッドにして、
マルチスレッドプログラムによって制御することが多い。
今回紹介するプログラムも、C\# でマルチスレッドを行うための仕組みの一つである
「Task」という仕組みを利用している。Task に関する解説はここでは割愛するが、
このサンプルにある機能で十分な場合はこれをコピーして利用しても差し支えない。
また、より高機能を必要とする場合は MyBGM や MySE クラスをさらに拡張して用いるとよいだろう。
\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
  1: using System;
  2: using System.Collections.Generic;
  3: using System.Linq;
  4: using System.Text;
  5: using System.Threading.Tasks;
  6: using System.Threading;
  7: using FK_CLI;
  8: 
  9: namespace FK_CLI_Audio
 10: {
 11:     // BGM用クラス
 12:     class MyBGM : IDisposable
 13:     {
 14:         public bool EndStatus { get; set; } // 終了指示用プロパティ
 15:         private fk_AudioStream bgm;
 16:         private bool openStatus;
 17: 
 18:         // コンストラクタ 引数は音源ファイル名 (Ogg 形式)
 19:         public MyBGM(string argFileName)
 20:         {
 21:             EndStatus = false;
 22:             bgm = new fk_AudioStream();
 23:             openStatus = bgm.Open(argFileName);
 24:             if(openStatus == false)
 25:             {
 26:                 Console.WriteLine("Audio File Open Error.");
 27:             }
 28:         }
 29: 
 30:         // BGM再生処理
 31:         public void Start()
 32:         {
 33:             if(openStatus == false) return;
 34:             bgm.LoopMode = true;
 35:             bgm.Gain = 0.5;
 36:             while(EndStatus == false)
 37:             {
 38:                 bgm.Play();
 39:                 Thread.Sleep(50);
 40:             }
 41:         }
 42: 
 43:         // 音量用プロパティ
 44:         public double Gain
 45:         {
 46:             set
 47:             {
 48:                 bgm.Gain = value;
 49:             }
 50:         }
 51: 
 52:         // スレッド終了時処理
 53:         public void Dispose()
 54:         {
 55:             bgm.Dispose();
 56:         }
 57:     }
 58: 
 59:     // Sound Effect (SE) 用クラス
 60:     class MySE : IDisposable
 61:     {
 62:         public bool EndStatus { get; set; } // 終了指示用プロパティ
 63:         private fk_AudioWavBuffer [] se;
 64:         private bool [] openStatus;
 65:         private bool [] playStatus;
 66: 
 67:         // コンストラクタ 引数は音源の個数
 68:         public MySE(int argNum)
 69:         {
 70:             EndStatus = false;
 71:             if(argNum < 1) return;
 72:             se = new fk_AudioWavBuffer [argNum];
 73:             openStatus = new bool [argNum];
 74:             playStatus = new bool [argNum];
 75: 
 76:             for(int i = 0; i < argNum; i++)
 77:             {
 78:                 se[i] = new fk_AudioWavBuffer();
 79:                 openStatus[i] = false;
 80:                 playStatus[i] = false;
 81:             }
 82:         }
 83: 
 84:         // SE音源読み込みメソッド (WAV 形式)
 85:         public bool LoadData(int argID, string argFileName)
 86:         {
 87:             if(argID < 0 || argID >= se.Length)
 88:             {
 89:                 return false;
 90:             }
 91: 
 92:             openStatus[argID] = se[argID].Open(argFileName);
 93:             if(openStatus[argID] == false)
 94:             {
 95:                 Console.WriteLine("Audio File ({0}) Open Error.", argFileName);
 96:             }
 97:             se[argID].LoopMode = false;
 98:             se[argID].Gain = 0.5;
 99:             return true;
100:         }
101: 
102:         // SE開始メソッド
103:         public void StartSE(int argID)
104:         {
105:             if(argID < 0 || argID >= se.Length) return;
106:             playStatus[argID] = true;
107:             se[argID].Seek(0.0);
108:         }
109: 
110:         // SE再生処理
111:         public void Start()
112:         {
113:             int i;
114: 
115:             for(i = 0; i < se.Length; i++)
116:             {
117:                 if(openStatus[i] == false) return;
118:             }
119: 
120:             while(EndStatus == false)
121:             {
122:                 for(i = 0; i < se.Length; i++)
123:                 {
124:                     if(playStatus[i] == true)
125:                     {
126:                         playStatus[i] = se[i].Play();
127:                     }
128:                 }
129:                 Thread.Sleep(10);
130:             }
131:         }
132: 
133:         // スレッド終了時処理
134:         public void Dispose()
135:         {
136:             for(int i = 0; i < se.Length; i++)
137:             {
138:                 se[i].Dispose();
139:             }
140:         }
141:     }
142: 
143:     class Program
144:     {
145:         static void Main(string[] args)
146:         {
147:             // 組込マテリアル初期化
148:             fk_Material.InitDefault();          
149: 
150:             // ウィンドウの各種設定
151:             var win = new fk_AppWindow();
152:             win.CameraPos = new fk_Vector(0.0, 1.0, 20.0);
153:             win.CameraFocus = new fk_Vector(0.0, 1.0, 0.0);
154:             win.Size = new fk_Dimension(600, 600);
155:             win.BGColor = new fk_Color(0.6, 0.7, 0.8);
156:             win.ShowGuide(fk_GuideMode.GRID_XZ);
157: 
158:             // 立方体の各種設定
159:             var block = new fk_Block(1.0, 1.0, 1.0);
160:             var blockModel = new fk_Model();
161:             blockModel.Shape = block;
162:             blockModel.GlMoveTo(3.0, 3.0, 0.0);
163:             blockModel.Material = fk_Material.Yellow;
164:             win.Entry(blockModel);
165: 
166:             // BGMの各種設定
167:             var bgm = new MyBGM("epoq.ogg");
168:             var bgmTask = new Task(bgm.Start);
169:             double volume = 0.5;
170:             
171:             // SEの各種設定
172:             var se = new MySE(2);
173:             var seTask = new Task(se.Start);
174:             se.LoadData(0, "MIDTOM2.wav");
175:             se.LoadData(1, "SDCRKRM.wav");
176: 
177:             win.Open();
178:             bgmTask.Start(); // BGM スレッド開始
179:             seTask.Start();  // SE スレッド開始
180: 
181:             var origin = new fk_Vector(0.0, 0.0, 0.0);
182: 
183:             while(win.Update())
184:             {
185:                 blockModel.GlRotateWithVec(origin, fk_Axis.Y, Math.PI/360.0);
186: 
187:                 // 上矢印キーで BGM 音量アップ
188:                 if(win.GetSpecialKeyStatus(fk_SpecialKey.UP, fk_SwitchStatus.DOWN) == true)
189:                 {
190:                     if(volume < 1.0) volume += 0.1;
191:                 }
192: 
193:                 // 下矢印キーで BGM 音量ダウン
194:                 if(win.GetSpecialKeyStatus(fk_SpecialKey.DOWN, fk_SwitchStatus.DOWN) == true)
195:                 {
196:                     if(volume > 0.0) volume -= 0.1;
197:                 }
198: 
199:                 // Z キーで 0 番の SE を再生開始
200:                 if(win.GetKeyStatus('Z', fk_SwitchStatus.DOWN) == true)
201:                 {
202:                     se.StartSE(0);
203:                 }
204: 
205:                 // X キーで 1 番の SE を再生開始
206:                 if(win.GetKeyStatus('X', fk_SwitchStatus.DOWN) == true)
207:                 {
208:                     se.StartSE(1);
209:                 }
210: 
211:                 bgm.Gain = volume;
212:             }
213: 
214:             // BGM 変数と SE 変数に終了を指示
215:             bgm.EndStatus = true;
216:             se.EndStatus = true;
217: 
218:             // BGM, SE 両スレッドが終了するまで待機
219:             Task.WaitAll(new[] { bgmTask, seTask });
220:         }
221:     }
222: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{スプライト表示}
この節では、第\ref{sec:spritemodel}節で紹介したスプライトモデルを用いた
文字列表示のサンプルを示す。ここではフォントファイルとして
「rm1b.ttf」というファイル名のフォントデータを利用している。
これはビルド時に生成される exe ファイルと同一の場所に置かれている必要がある。

29,30 行目で Text プロパティに様々な設定を行っているが、
この Text プロパティは fk\_TextImage 型であり、fk\_TextImage が持つ様々な設定を
変更することで色やフォントサイズなど、様々な設定を変更することができる。

55行目の SetPositionLT() メソッドは表示位置を指定するものである。
文字列設定の度に位置の再設定を行っている理由は、
文字列を表すテクスチャ画像の幅が変更されたときに再設定を行わないと、
表示位置がずれてしまうためである。
表示文字列が変更されていない場合や、
文字列テクスチャの幅が変わっていないことが保証されている場合は、
このメソッドを呼ぶ必要はない。\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Sprite
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             fk_Material.InitDefault();
15: 
16:             // 各種変数生成
17:             var window = new fk_AppWindow();
18:             var sprite = new fk_SpriteModel();
19:             var block = new fk_Block(1.0, 1.0, 1.0);
20:             var model = new fk_Model();
21:             var origin = new fk_Vector(0.0, 0.0, 0.0);
22: 
23:             // フォントデータ入力
24:             if(sprite.InitFont("rm1b.ttf") == false) {
25:                 Console.WriteLine("Font Error");
26:             }
27: 
28:             // フォント設定
29:             sprite.Text.MonospaceMode = true;
30:             sprite.Text.MonospaceSize = 12;
31:             window.Entry(sprite);
32: 
33:             // 立方体設定
34:             model.Shape = block;
35:             model.GlMoveTo(0.0, 6.0, 0.0);
36:             model.Material = fk_Material.Yellow;
37:             window.Entry(model);
38: 
39:             // ウィンドウ設定
40:             window.CameraPos = new fk_Vector(0.0, 5.0, 20.0);
41:             window.CameraFocus = new fk_Vector(0.0, 5.0, 0.0);
42:             window.Size = new fk_Dimension(800, 600);
43:             window.BGColor = new fk_Color(0.6, 0.7, 0.8);
44:             window.ShowGuide(fk_GuideMode.GRID_XZ);
45:             window.Open();
46:  
47:             for(int count = 0;  window.Update() == true; count++) {
48:                 // 文字列生成
49:                 string str = "count = " + count.ToString();
50: 
51:                 // 文字列をスプライトに設定
52:                 sprite.DrawText(str, true);
53: 
54:                 // スプライト配置設定
55:                 sprite.SetPositionLT(-240.0, 230.0);
56: 
57:                 // 立方体を回転させる
58:                 model.GlRotateWithVec(origin, fk_Axis.Y, Math.PI/360.0);
59:             }
60:         }
61:     }
62: }
\end{verbatim}
\end{small}
\end{breakbox}

\section{四元数}
この節では、第\ref{sec:quaternion}節で紹介した四元数を用いて、
姿勢補間を行うサンプルプログラムを示す。
3DCGのプログラミングでは、ベクトル、行列、オイラー角、四元数といった多くの
代数要素を扱う必要があるが、このサンプルプログラムはそれらの利用方法を
コンパクトにまとめたものとなっている。

四元数は姿勢を表現する手段として強力な数学手法であるが、
四元数の成分を直接扱うことは現実的ではなく、
通常はオイラー角を介して制御を行う。
このサンプルプログラムでも、まず2種類の姿勢を angle1, angle2 という変数で
設定(24,25行目)してから、それを四元数に変換(52,53行目)している。
そして、59行目で球面線形補間を行った四元数を算出し、
それを62行目でモデルの姿勢として設定している。\\ ~

\begin{breakbox}
\begin{small}
\begin{verbatim}
 1: using System;
 2: using System.Collections.Generic;
 3: using System.Linq;
 4: using System.Text;
 5: using System.Threading.Tasks;
 6: using FK_CLI;
 7: 
 8: namespace FK_CLI_Quaternion
 9: {
10:     class Program
11:     {
12:         static void Main(string[] args)
13:         {
14:             // 各種変数生成
15:             fk_Material.InitDefault();
16:             var win = new fk_AppWindow();
17:             var model = new fk_Model();
18:             var pointM = new fk_Model();
19:             var cone = new fk_Cone(3, 4.0, 15.0);
20:             var pos = new fk_Vector(0.0, 0.0, -15.0);
21:             var poly = new fk_Polyline();
22: 
23:             // オイラー角の初期値設定
24:             var angle1 = new fk_Angle(0.0, 0.0, 0.0);
25:             var angle2 = new fk_Angle(Math.PI/2.0, Math.PI/2.0 - 0.01, 0.0);
26: 
27:             // 四元数変数作成
28:             var q1 = new fk_Quaternion();
29:             var q2 = new fk_Quaternion();
30:             fk_Quaternion q;
31: 
32:             // 三角錐モデルの設定
33:             model.Shape = cone;
34:             model.Material = fk_Material.Yellow;
35:             model.GlAngle(angle1);
36: 
37:             // 軌跡用ポリラインモデルの設定
38:             pointM.Shape = poly;
39:             pointM.LineColor = new fk_Color(1.0, 0.0, 0.0);
40: 
41:             // ウィンドウ設定
42:             win.Size = new fk_Dimension(500, 500);
43:             win.BGColor = new fk_Color(0.3, 0.4, 0.5);
44:             win.Entry(model);
45:             win.Entry(pointM);
46:             win.TrackBallMode = true;
47:             win.ShowGuide();
48: 
49:             win.Open();
50: 
51:             // オイラー角の初期値を四元数に設定
52:             q1.Euler = angle1;
53:             q2.Euler = angle2;
54: 
55:             for(int i = 0;  win.Update() == true; i++) {
56:                 double t = i / 200.0;
57:                 if(t < 1.0) {
58:                     // パラメータ t で球面線形補間
59:                     q = fk_Math.QuatInterSphere(q1, q2, t);
60: 
61:                     // q をモデルの姿勢(オイラー角)に変換
62:                     model.GlAngle(q.Euler);
63: 
64:                     // 軌跡用に点を追加
65:                     poly.PushVertex(model.Matrix * pos);
66:                 }
67:             }
68:         }
69:     }
70: }
\end{verbatim}
\end{small}
\end{breakbox}
