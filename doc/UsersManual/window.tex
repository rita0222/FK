\chapter{ウインドウとイベント処理} \label{sec:window} ~

FK システムでは、ウィンドウを制御するクラスとして fk\_AppWindow クラスと
fk\_Window クラスを提供している。fk\_AppWindow は簡易に様々な機能を
実現できるものであり、実装を容易に行うことを優先したものとなっている。
fk\_Window は fk\_AppWindow よりも利用方法はやや複雑であるが、
多くの高度な機能を持っており、マルチウィンドウや GUI と組み合わせた
プログラムを作成することができる。

本章では、まず fk\_AppWindow による機能を紹介し、
その後に fk\_Window 固有の機能について解説を行う。

\section{ウィンドウの生成}
ウィンドウは、一般的なウィンドウシステムにおいて描画を
するための画面単位である。FK システムでは、fk\_AppWindow クラスの
オブジェクトを作成することによって1つのウィンドウを生成できる。
\\
\begin{screen}
\begin{verbatim}
    fk_AppWindow       window;
\end{verbatim}
\end{screen}
~

fk\_AppWindow に対して最低限必要な設定は大きさの設定である。
以下のように、setSize() 関数を使ってピクセル単位で大きさを指定する。
\\
\begin{screen}
\begin{verbatim}
    window.setSize(600, 600);
\end{verbatim}
\end{screen}
~

また、背景色を設定するには setBGColor() を用いる。
\\
\begin{screen}
\begin{verbatim}
    window.setBGColor(0.3, 0.5, 0.2);
\end{verbatim}
\end{screen}
~ \\
setBGColor() は fk\_Color 型変数を引数に取ることもできる。

これらの設定を行った後、open() 関数を呼ぶことで実際にウィンドウが画面に表示される。
\\
\begin{screen}
\begin{verbatim}
    window.open();
\end{verbatim}
\end{screen}
\section{ウィンドウの描画}
ウィンドウの描画は、ウィンドウ用の変数(インスタンス)で update() 関数を呼び出すことで行われる。
この関数が呼ばれた時点で、リンクされているシーンに登録されている物体が描画される。

update() 関数は、ウィンドウが正常に描画された場合に true を、
そうでない場合は false を返す。
false を返すケースは、ウィンドウが閉じられた場合となる。
そのため
\\
\begin{screen}
\begin{verbatim}
    while(window.update() == true) {
                  :
    }
\end{verbatim}
\end{screen}
~ \\
というコードでは、ウィンドウが閉じられると while ループを脱出するようになる。
これを踏まえ、実際の描画ループは次のようになる。
\\
\begin{breakbox}
\begin{verbatim}
        fk_AppWindow        window;

        window.setSize(600, 600);
        window.setBGColor(0.1, 0.2, 0.3);
        window.open();
        while(window.update() == true) {
                    :
                    :       // モデルの制御
                    :
        }       
\end{verbatim}
\end{breakbox}

\section{座標軸やグリッドの表示}
fk\_AppWindow には座標軸やグリッドを表示する機能が備わっている。
座標軸とは、原点から座標軸方向に描画される線分のことである。
また、グリッドとは座標平面上に表示されるメッシュのことである。

座標軸とグリッドの表示は共に showGuide() 関数を用いて行われる。
表示したい対象を以下のように並べて指定する。
\\
\begin{screen}
\begin{verbatim}
    window.showGuide(FK_AXIS_X | FK_AXIS_Y | FK_AXIS_Z | FK_GRID_XZ);
\end{verbatim}
\end{screen}
~ \\
showGuide() で指定できる項目は以下の通りである。

\begin{table}[H]
\caption{座標軸・グリッドの指定項目}
\label{tbl:fkAxisGrid}
\begin{center}
\begin{tabular}{|c|l|}
\hline
FK\_AXIS\_X & \(x\)軸 \\ \hline
FK\_AXIS\_Y & \(y\)軸 \\ \hline
FK\_AXIS\_Z & \(z\)軸 \\ \hline
FK\_GRID\_XY & \(xy\) 平面上のグリッド \\ \hline
FK\_GRID\_YZ & \(yz\) 平面上のグリッド \\ \hline
FK\_GRID\_XZ & \(xz\) 平面上のグリッド \\ \hline
\end{tabular}
\end{center}
\end{table}

なお、引数を省略した場合は \(x,y,z\) 各座標軸と \(xz\) 平面グリッドが表示される。

座標軸の長さやグリッドの幅、数などは以下の関数によって制御可能である。

\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{hideGuide()} \\
	\> \> \begin{tabular}{p{15cm}}
		座標軸・グリッドを消去する。
	\end{tabular} \\ \\

\> \textbf{setGuideAxisWidth(double w)} \\
	\> \> \begin{tabular}{p{15cm}}
		座標軸の線幅を w に設定する。
	\end{tabular} \\ \\

\> \textbf{setGuideGridWidth(double w)} \\
	\> \> \begin{tabular}{p{15cm}}
		グリッドの線幅を w に設定する。
	\end{tabular} \\ \\

\> \textbf{setGuideScale(double s)} \\
	\> \> \begin{tabular}{p{15cm}}
		グリッドの幅を s に設定する。
	\end{tabular} \\ \\

\> \textbf{setGuideNum(int n)} \\
	\> \> \begin{tabular}{p{15cm}}
		グリッドの分割数を n に設定する。
	\end{tabular}
\end{tabbing}
\section{ウィンドウでのイベント}
fk\_AppWindow 上でのマウスやキーボードの状態を調べるため、fk\_AppWindow クラスは
様々なメンバ関数を提供している。ここでは、それらの使用法を説明する。
\subsection*{getKeyStatus() メンバ関数}
この関数は、キーボード上の文字キーが現在押されているか
どうかを調べるための関数である。たとえば、'g' というキーが押されているか
どうかを調べたければ、
\\
\begin{screen}
\begin{verbatim}
        if(window.getKeyStatus('g', FK_SW_PRESS) == true) {
                :       // キーが押された時の処理を行う。
        }
\end{verbatim}
\end{screen}
~ \\
という記述を行う。この関数は、1番目の引数にキーを表す文字を代入する。
2番目の引数はどのようなキーの状態を検知するかを設定するもので、
以下のような種類がある。

\begin{table}[H]
\caption{キーの状態設定}
\label{tbl:fkSwitchStatus}
\begin{center}
\begin{tabular}{|c|l|}
\hline
FK\_SW\_RELEASE & 離しっぱなしの状態 \\ \hline
FK\_SW\_UP & 離した瞬間 \\ \hline
FK\_SW\_DOWN & 押した瞬間 \\ \hline
FK\_SW\_PRESS & 押しっぱなしの状態 \\ \hline
\end{tabular}
\end{center}
\end{table}

上記のサンプルプログラムは「押した状態にあるかどうか」を検知するものであるが、
「押した瞬間」であるかどうかを検知する場合は「FK\_SW\_PRESS」のかわりに
「FK\_SW\_DOWN」を第2引数に入力する。

\subsection*{getSpecialKeyStatus() 関数}
この関数は、文字ではない特殊キーが押されているか
どうかを調べるための関数である。たとえば、左シフトキーが押されているか
どうかを調べたければ、
\\
\begin{screen}
\begin{verbatim}
        if(window.getSpecialKeyStatus(FK_SHIFT_L, FK_SW_PRESS) == true) {
                :       // キーが押されている時の処理を行う。
        }
\end{verbatim}
\end{screen}
~ \\
といったような記述を行う。特殊キーと関数の引数の対応は以下の
表 \ref{tbl:fkSpecialKey} のとおりである。

\begin{table}[H]
\caption{特殊キーと引数値の対応}
\label{tbl:fkSpecialKey}
\begin{center}
\begin{tabular}{|p{3cm}|p{3cm}||p{3cm}|p{3cm}|}
\hline
引数名 & 対応特殊キー & 引数名 & 対応特殊キー \\ \hline \hline
FK\_SHIFT\_R	& 右シフトキー &
	FK\_CAPS\_LOCK	& Caps Lock キー \\ \hline
FK\_SHIFT\_L	& 左シフトキー &
	FK\_PAGE\_UP	& Page Up キー \\ \hline
FK\_CTRL\_R	& 右コントロールキー &
	FK\_PAGE\_DOWN	& Page Down キー \\ \hline
FK\_CTRL\_L	& 左コントロールキー &
	FK\_HOME	& Home キー \\ \hline
FK\_ALT\_R	& 右 ALT キー &
	FK\_END		& End キー \\ \hline
FK\_ALT\_L	& 左 ALT キー &
	FK\_INSERT	& Insert キー \\ \hline
FK\_ENTER	& 改行キー &
	FK\_RIGHT	& 右矢印キー \\ \hline
FK\_BACKSPACE	& Back Space キー &
	FK\_LEFT	& 左矢印キー \\ \hline
FK\_DELETE	& Del キー &
	FK\_UP		& 上矢印キー \\ \hline
FK\_TAB		& Tab キー &
	FK\_DOWN	& 下矢印キー \\ \hline
FK\_F1 〜 FK\_F12 & F1 〜 F12 キー &
		& \\ \hline
\end{tabular}
\end{center}
\end{table}

また、2番目の引数は前述の getKeyStatus() 関数と同様にマウスポインタが
fk\_AppWindow 上にあるかどうかを条件に加えるフラグである。

\subsection*{getMousePosition() 関数}
この関数は、現在のマウスポインタの位置を調べる時に使用する。使い方は、
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector       pos;
        fk_AppWindow    window;
                :
                :
        pos = window.getMousePosition();
\end{verbatim}
\end{breakbox}
~ \\
というように、fk\_Vector 型の変数にマウスポインタのウィンドウ座標系による現在位置を得られる。
ウィンドウ座標系では、描画領域の左上部分が原点となり、\(x\)成分は右方向、\(y\)成分は下方向に正となり、
数値単位はピクセルとなる。

\subsection*{getMouseStatus() 関数}
この関数は、現在マウスボタンが押されているかどうかを調べる時に使用する。
引数値として左ボタンが FK\_MOUSE1、中ボタンが FK\_MOUSE2、右ボタンが
FK\_MOUSE3 に対応しており、
\\
\begin{breakbox}
\begin{verbatim}
        fk_AppWindow       window;

        if(window.getMouseStatus(FK_MOUSE1, FK_SW_PRESS) == true) {
                :       // 左ボタンが押されている。
                :
        }
\end{verbatim}
\end{breakbox}
~ \\
といった様にして現在のボタン状態を調べることができる。この関数も他と
同様に、fk\_AppWindow 上にマウスポインタがない場合は常に false が
返ってくる。

\section{ウィンドウ座標と3次元座標の相互変換}
3D のアプリケーションを構築する際、ウィンドウ中のある場所が、
3次元空間ではどのような座標になるのかを知りたいということが
しばしば見受けられる。あるいは逆に、3次元空間中の点が実際にウィンドウの
どの位置に表示されるのかをプログラム中で参照したいということも
よくある。FK でこれを実現する方法としてh、fk\_AppWindow クラスに
getWindowPosition(), getProjectPosition() というメンバ関数が
準備されている。以下に、3次元からウィンドウへの変換、
ウィンドウから3次元への変換を述べる。

\subsection{3次元座標からウィンドウ座標への変換}
3次元空間中のある座標は、fk\_AppWindow クラスの
getWindowPosition() というメンバ関数を用いることで、ウィンドウ中で
実際に表示される位置を知ることができる。引数として入力、出力を
表す fk\_Vector 型の変数を取る。以下に例を示す。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector       in, out;
        fk_AppWindow    window;
                :
                :
        win.getWindowPosition(in, &out);
\end{verbatim}
\end{breakbox}
~ \\
ここで、in には元となる3次元空間の座標を設定しておく。
出力となる2番目の引数は getMousePosition() の場合と同様に
アドレス渡しをする必要がある。
これにより、
out の \(x\) 成分、\(y\) 成分にそれぞれウィンドウ座標が設定される。
なお、この場合の out の \(z\) 成分には 0 から 1 までのある値が入るように
なっており、カメラから遠いほど高い値が設定される。

\subsection{ウィンドウ座標から3次元座標への変換}
3次元→ウィンドウの場合と比べて、ウィンドウ座標から3次元座標への
変換はやや複雑である。というのも、3次元座標からウィンドウ座標へ
変換する場合は、結果が一意に定まるのであるが、
その逆の場合は単にウィンドウ座標だけでは
3次元空間中の位置が決定しないからである。もう少し具体的に述べると、
本来得たい空間中の位置とカメラ位置を結ぶ直線
(以下これを「指定直線」と呼ぶ)が求まるが、
その直線上のどこなのかを特定するには
もう1つの基準を与えておく必要がある。FK ではこの基準として
\begin{itemize}
 \item カメラからの距離
 \item 任意平面
\end{itemize}
の2種類を用意している。

まずカメラからの距離によって指定する方法を紹介する。
3次元空間上の座標を取得するには getProjectPosition() メンバ関数を
利用する。引数は以下の通りである。
\\
\begin{screen}
\begin{verbatim}
        getProjectPosition(ウィンドウx座標, ウィンドウy座標, 距離、出力変数);
\end{verbatim}
\end{screen}
~ \\
例えば、以下の例は現在のマウスが指す3次元空間の座標を得るプログラムである。
このプログラム中ではカメラからの距離を 500 としている。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector       pos, out;
        fk_AppWindow    window;
        fk_Vector       
                :
                :
        pos = win.getMousePosition();
        win.getProjectPosition(pos.x, pos.y, 500.0, &out);
\end{verbatim}
\end{breakbox}
~ \\
もう1つの方法として、平面を指定する方法がある。前述の指定直線と
与えた平面が平行でないならば、その交点を出力することになる。これは、
例えば \(xy\) 平面上の点や部屋の壁のようなものを想定するような場合に
便利である。

まずは平面を作成する必要があるが、これは fk\_Plane というクラスの変数を
利用する。平面指定の方法として、
\begin{itemize}
 \item 平面上の任意の1点と平面の法線ベクトルを指定する。
 \item 平面上の(同一直線上にない)任意の3点を指定する。
 \item 平面上の任意の1点と、平面上の互いに
	平行ではない2つのベクトルを指定する。
\end{itemize}
の3種類があり、以下のように指定する。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Plane    plane;  // 平面を表す変数
            :
            :
        // 1点 + 法線ベクトルのパターン
        //   pos ... 平面上の任意の1点で、fk_Vector 型
        //   norm .. 平面の法線ベクトルで、fk_Vector 型
        plane.setPosNormal(pos, norm);

        // 3点のパターン (3点は同一直線上にあってはならない)
        //   pos1 〜 pos3 ... 平面上の任意の点で、全て fk_Vector 型
        plane.set3Pos(pos1, pos2, pos3);

        // 1点 + 2つのベクトルのパターン
        //   pos ... 平面上の任意の1点で、fk_Vector 型
        //   uVec .. 平面に平行なベクトル (fk_Vector型)
        //   vVec .. 平面に平行なベクトルで、uVec に平行でないもの (fk_Vector 型)
        plane.setPosUVVec(pos, uVec, vVec);
\end{verbatim}
\end{breakbox}
~ \\
これにより、平面が生成できたら、以下の形式で3次元空間中の座標を取得
することができる。
\\
\begin{screen}
\begin{verbatim}
        getProjectPosition(ウィンドウx座標成分, ウィンドウy座標成分, 平面、出力変数);
\end{verbatim}
\end{screen}
~ \\
ちなみに、平面と出力変数はアドレス渡しにしておく必要がある。以下の例は、
マウス位置が指している場所の \(xy\) 平面上の座標を得るサンプルである。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector       outPos;                 // 出力用変数
        fk_AppWindow    win;                    // ウィンドウ変数
        fk_Vector       pos;                    // マウス座標用変数
        fk_Plane        plane;                  // 平面を表す変数
        fk_Vector       planePos, planeNorm;    // 平面生成用変数
                :
                :

        // 平面の任意点と法線ベクトルを設定する。
        planePos.set(0.0, 0.0, 0.0);
        planeNorm.set(0.0, 0.0, 1.0);

        // 情報を平面に設定
        plane.setPosNormal(planePos, planeNorm);

        // ウィンドウからマウス座標を得る。
        pos = win.getMousePosition();

        // ウィンドウ座標と平面から、3次元空間中の座標を得る。
        win.getProjectPosition(pos.x, pos.y, &plane, &outPos);
\end{verbatim}
\end{breakbox}
