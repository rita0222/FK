\chapter{テクスチャマッピングと画像処理} \label{sec:imagetexture} ~

この章では、画像を 3D 空間上に表示する「テクスチャマッピング」と呼ばれる
技術の利用方法と、画像処理機能の使用方法を述べる。
基本的に、テクスチャマッピングは \ref{sec:shape} 章で述べてきた
形状の一種であり、利用方法は他の形状クラスとあまりかわらない。
しかし、画像情報を扱うため独特の機能を多く保持するため、独立した章で解説を行う。

\section{テクスチャマッピング} \label{subsec:texture}
テクスチャマッピングとは、2次元画像の全部及び一部を3次元空間上に
配置して表示する技術である。テクスチャマッピングは、細かな質感を
簡単に表現できることや、高速な表示機能が搭載されているハードウェアが
普及してきていることから、非常に有用な技術である。FK システムでは、
現在「矩形テクスチャ」、「三角形テクスチャ」、「IFSテクスチャ」の
3種類のテクスチャマッピング方法をサポートしている。
現在、入力可能な画像フォーマットは Windows Bitmap 形式、PNG 形式、
JPEG 形式の3種類である。

\subsection{矩形テクスチャ}
最初に紹介するのは「矩形テクスチャ」と呼ばれるものである。これは、
2次元画像全体をそのまま(つまり長方形の状態で)表示するための機能で、
非常に簡単に利用できる。クラスとしては、「fk\_RectTexture」というものを
利用することになる。

\subsubsection{基本的な利用方法}
生成は、他の形状オブジェクトと同様に普通に変数を定義するだけでよい。
\\
\begin{screen}
\begin{verbatim}
        fk_RectTexture    texture;
\end{verbatim}
\end{screen}
~ \\
画像ファイルの入力は、Windows Bitmap 形式の場合 readBMP() 関数を用いる。
この関数は、入力に
成功した場合は true を、入力に失敗した場合は false を返す。
\\
\begin{breakbox}
\begin{verbatim}
        if(texture.readBMP("samp.bmp") == false) {
            fl_alert("Image File Read Error!");
        }
\end{verbatim}
\end{breakbox}
~ \\
PNG 形式の画像ファイルを読み込みたい場合は、上記の readBMP() を
readPNG() 関数に置き換える。

また、テクスチャの3次元空間上での大きさの指定には setTextureSize()
関数を用いる。
\\
\begin{screen}
\begin{verbatim}
        texture.setTextureSize(50.0, 30.0);
\end{verbatim}
\end{screen}
~ \\
この状態で、中心を原点、向きを \(+z\) 方向としたテクスチャが生成される。

\subsubsection{画像中の一部分の切り出し}
fk\_RectTexture クラスでは、画像の一部分を切り出して表示することも可能である。
切り出し部分の指定方法として、「テクスチャ座標系」と呼ばれる座標系を用いる。
テクスチャ座標系というのは、
画像ファイルのうち一番左下の部分を \((0, 0)\)、右上の部分を \((1, 1)\) と
して、画像の任意の位置をパラメータとして表す座標系のことである。
例えば、画像の中心を表わすテクスチャ座標は \((0.5, 0.5)\) となる。
また、\(100 \times 100\) の画像の
左から 70 ピクセル、下から 40 ピクセルの位置のテクスチャ座標は
\((0.7, 0.4)\) ということになる。

切り出す部分は、切り出し部分の左下と右上のテクスチャ座標を設定することになる。
指定には setTextureCoord() 関数を利用する。以下は、
左下のテクスチャ座標として \((0.2, 0.3)\)、右上のテクスチャ座標として
\((0.5, 0.6)\) を指定するサンプルである。
\\
\begin{screen}
\begin{verbatim}
        texture.setTextureCoord(0.2, 0.3, 0.5, 0.6);
\end{verbatim}
\end{screen}

\subsubsection{リピートモード}
ビルの外壁や地面を表すテクスチャを生成するときに、1枚の画像を
タイルのように行列状に並べて配置したい場合がある。これを全て別々の
テクスチャとして生成するのはかなり処理時間に負担がかかってしまう。
このようなとき、fk\_RectTexture の「リピートモード」を用いると便利である。
リピートモードとは、テクスチャを1枚だけ張るのではなく、タイル状に
並べて配置するモードである。これを用いるには、次のようにすればよい。
\\
\begin{screen}
\begin{verbatim}
        texture.setTextureSize(100.0, 100.0);
        texture.setRepeatMode(true);
        texture.setRepeatParam(5.0, 10.0);
\end{verbatim}
\end{screen}
~ \\
setRepeatMode 関数はリピートモードを用いるかどうかを設定するメンバ関数で、
引数に true を代入するとリピートモードとなる。次の setRepeatParam メンバ関数は
並べる個数を設定するもので、例の場合は横方向に 5 枚、縦方向に 10 枚の合計
50 枚を並べることになる。それら全体のサイズが 100x100 なので、1枚のサイズは
20x10 ということになる。ただし、リピートモードを用いる場合には画像サイズに
制限があり、縦幅と横幅はいずれも \(2^n\) (\(n\) は整数) である必要があり、
現在のサポートは \(2^{6} = 64\) から \(2^{16} = 65536\) までの間の
いずれかのピクセル幅でなければならない。
(ただし、縦幅と横幅は一致する必要はない。)
従って、リピートモードを用いるときはあらかじめ画像ファイルを補正しておく
必要がある。

また、リピートモードを用いた場合は一部の切り出しに関する設定は無効となる。

\subsection{三角形テクスチャ}
次に紹介するのは「三角形テクスチャ」である。これは、入力した画像の
一部分を三角形に切り出して表示する機能を持つ。これは、
「fk\_TriTexture」というクラスを利用する。テクスチャ用変数の
定義や画像ファイル読み込みに関しては fk\_RectTexture と同様である。
\\
\begin{screen}
\begin{verbatim}
        fk_TriTexture    texture;
        texture.readBMP("samp.bmp");
\end{verbatim}
\end{screen}
~ \\
fk\_TriTexture の場合も、fk\_RectTexture と同様に readBMP() を
readPNG() に置き換えることで、PNG 形式の画像ファイルを入力できる。

次に、画像のどの部分を切り出すかを指定する。
指定の方法は、前節で述べた「テクスチャ座標系」を
利用する。切り出す部分は、このテクスチャ座標系を利用して
3点それぞれを指定することになる。
指定には setTextureCoord() 関数を利用する。
最初の引数は、各頂点の ID を表わし、0, 1, 2 の順番で反時計回りとなるように
設定する。2番目、3番目の引数はテクスチャ座標の \(x, y\) 座標を入力する。
\\
\begin{screen}
\begin{verbatim}
        texture.setTextureCoord(0, 0.0, 0.0);
        texture.setTextureCoord(1, 1.0, 0.0);
        texture.setTextureCoord(2, 0.5, 0.5);
\end{verbatim}
\end{screen}
~ \\
次に、3点の3次元空間上での座標を設定する。設定には setVertexPos() 関数を
利用する。最初の引数が頂点 ID、2,3,4 番目の引数で 3 次元座標を指定する。
\\
\begin{screen}
\begin{verbatim}
        texture.setVertexPos(0, 0.0, 0.0, 0.0);
        texture.setVertexPos(1, 50.0, 0.0, 0.0);
        texture.setVertexPos(2, 20.0, 30.0, 0.0);
\end{verbatim}
\end{screen}
~ \\
setVertexPos() 関数は、fk\_Vector 型の変数を引数に持たせることも可能である。
\\
\begin{screen}
\begin{verbatim}
        fk_Vector    vec(100.0, 0.0, 0.0);
        texture.setVertexPos(0, vec);
\end{verbatim}
\end{screen}

\subsection{IFSテクスチャ} \label{subsubsec:ifstexture}
次に紹介する「IFSテクスチャ」は、多数の三角形テクスチャをひとまとめに
扱うための機能を持つクラスで、クラス名は「fk\_IFSTexure」である。
このクラスでは、Metasequoia によって作成したテクスチャ付きの MQO ファイルと、
D3DX ファイルの 2 種類のデータからの入力が可能となっている。
MQO ファイルは readMQOFile() 関数、D3DX ファイルは readD3DXFile() 関数で
形状データを入力することができる。なお、アニメーションに関しての機能が
\ref{subsubsec:d3dxanimation} 節に記述してあるので、
そちらも合わせて参照してほしい。

readMQOFile() 関数の引数構成は、以下のようになっている。
\\
\begin{screen}
\begin{verbatim}
  readMQOFile(string fileName, string objName, int matID, bool contFlg);
\end{verbatim}
\end{screen}
~ \\
「fileName」には MQO のファイル名、「objName」はファイル中のオブジェクト名を
入力する。「matID」は、特定のマテリアルを持つ面のみを抽出する場合はその ID を
指定する。全ての要素を読み込みたい場合は matID に -1 を入力する。

最後の「contFlg」はテクスチャ断絶のための設定である。
これは、テクスチャ座標が不連続な箇所に対し、形状の位相を断絶する操作を行うための
ものである。これを true にした場合断絶操作が行われ、テクスチャ座標が不連続な箇所が
幾何的にも不連続に表示されるようになる。ほとんどの場合、この操作を行った場合の方が
より適した描画となる。注意しなければならないのは、この断絶操作によって
MQOデータ中の位相構造とは異なる位相状態が内部で形成されることである。
そのため、頂点、稜線、面といった位相要素は MQO データよりも若干増加する。

なお、「matID」と「contFlg」はそれぞれ「-1」と「true」というデフォルト引数が
設定されており、このままで良いのであれば省略可能である。

readD3DXFile() 関数の仕様に関しては、\ref{subsec:d3dxread} 節での内容と同じであるので、
そちらを参照してほしい。
また、\ref{subsec:mqodata} 節と同様の用途として、readMQOData() 関数も利用できる。
引数の仕様は最初の引数が unsigned char のポインタ型になる以外は
上記 readMQOFile() 関数とと同様である。

以下の例は MQO ファイルからの読み込みのサンプルで、
テクスチャ用画像ファイル名(Windows Bitmap 形式)が「sample.bmp」、
MQO ファイル名が「sample.mqo」、
ファイル中のオブジェクト名が「obj1」であることを想定している。
\\
\begin{breakbox}
\begin{verbatim}
        fk_IFSTexture  texture;

        if(texture.readBMP("sample.bmp") == false) {
            fl_alert("Image File Read Error!");
        }

        if(texture.readMQOFile("sample.mqo", "obj1") == false) {
            fl_alert("Shape File Read Error!");
        }
\end{verbatim}
\end{breakbox} ~

ちなみに、ここで読み込んだ形状データは \ref{subsec:smooth} 節で
述べているスムースシェーディングの制御に対応している。

fk\_IFSTexture クラスが持つその他のメンバ関数として、以下のようなものがある。
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{bool init(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		テクスチャデータ及び形状データの初期化を行う。
	\end{tabular} \\ \\

\> \textbf{fk\_TexCoord getTextureCoord(int triID, int vID)} \\
	\> \> \begin{tabular}{p{15cm}}
		三角形 ID が triID、頂点 ID が vID である頂点に
		設定されているテクスチャ座標を返す。
	\end{tabular} \\ \\

\> \textbf{void setTextureCoord(int triID, int vID, fk\_TexCoord coord)} \\
	\> \> \begin{tabular}{p{15cm}}
		三角形 ID が triID、頂点 ID が vID である頂点に
		coord をテクスチャ座標として設定する。
	\end{tabular} \\ \\

\> \textbf{fk\_IndexFaceSet * getIFS(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		fk\_IFSTexture クラスは、形状データとして
		内部では fk\_IndexFaceSet クラスによる変数を保持しており、
		その中に形状データを格納している。この関数は、
		その変数へのポインタを返すものである。
		これを利用すると、頂点の移動なども fk\_IndexFaceSet の
		機能を用いて可能となる。
	\end{tabular}
\end{tabbing}

\subsection{メッシュテクスチャ}
最後に、「メッシュテクスチャ」を紹介する。メッシュテクスチャは、
前述した三角形テクスチャを複数枚同時に定義できる機能を持っている。
これは、「fk\_MeshTexture」というクラスを用いて実現できる。
このクラスは、前述の \ref{subsubsec:ifstexture}節で述べた
IFSテクスチャとよく似ているが、以下のような点が異なっている。
これらの性質を踏まえて、両方を使い分けてほしい。

\begin{table}[H]
\caption{IFSテクスチャとメッシュテクスチャの比較}
\label{tbl:meshtexture}
\begin{center}
\begin{tabular}{|l||l|l|}
\hline
項目 & IFSテクスチャ & メッシュテクスチャ \\ \hline \hline
形状生成 & ファイル入力のみ & ファイル入力とプログラムによる動的生成 \\ \hline
描画速度 & 高速 & IFSテクスチャより若干低速 \\ \hline
テクスチャ断絶 & 対応 & 非対応 \\ \hline
D3DX アニメーション & 対応 & 非対応 \\ \hline
\end{tabular}
\end{center}
\end{table}

使い方は、まず生成する三角形テクスチャの枚数を setTriNum() 関数で指定する。
その後、fk\_TriTexture と同様に setTextureCoord() 関数で各頂点の
テクスチャ座標を、setVertexPos() で空間上の位置座標を入力していくが、
それぞれの関数の引数の最初に三角形の ID を入力するところだけが異なっている。
\\
\begin{breakbox}
\begin{verbatim}
        fk_MeshTexture  texture;

        texture.setTriNum(2);
        texture.setTextureCoord(0, 0, 0.0, 0.0);
        texture.setTextureCoord(0, 1, 1.0, 0.0);
        texture.setTextureCoord(0, 2, 0.5, 0.5);
        texture.setTextureCoord(1, 0, 0.0, 0.0);
        texture.setTextureCoord(1, 1, 0.5, 0.5);
        texture.setTextureCoord(1, 2, 0.0, 1.0);
        texture.setVertexPos(0, 0, 0.0, 0.0, 0.0);
        texture.setVertexPos(0, 1, 50.0, 0.0, 0.0);
        texture.setVertexPos(0, 2, 20.0, 30.0, 0.0);
        texture.setVertexPos(1, 0, 0.0, 0.0, 0.0);
        texture.setVertexPos(1, 1, 20.0, 30.0, 0.0);
        texture.setVertexPos(1, 2, 0.0, 50.0, 0.0);
\end{verbatim}
\end{breakbox}
~ \\
別の生成方法として、
Metasequoia によって生成したテクスチャ付きの MQO ファイルを
読み込むことも可能である。以下のように、readMQOFile() 関数を利用する。
例では、テクスチャ用画像ファイル名が「sample.bmp」、
MQO ファイル名が「sample.mqo」、
ファイル中のオブジェクト名が「obj1」と想定している。
\\
\begin{breakbox}
\begin{verbatim}
        fk_MeshTexture  texture;

        if(texture.readBMP("sample.bmp") == false) {
            fl_alert("Image File Read Error!");
        }

        if(texture.readMQOFile("sample.mqo", "obj1") == false) {
            fl_alert("Shape File Read Error!");
        }
\end{verbatim}
\end{breakbox}
~ \\
また、
fk\_MeshTexture クラスは複数のテクスチャ三角形平面によって構成されることに
なるが、putIndexFaceSet 関数を用いることによりその形状を
fk\_IndexFaceSet 型の形状として出力することが可能である。
\\
\begin{breakbox}
\begin{verbatim}
        fk_MeshTexture  texture;
        fk_IndexFaceSet ifset;

        texture.putIndexFaceSet(&ifset);
\end{verbatim}
\end{breakbox}

\subsection{テクスチャのレンダリング品質設定}
矩形テクスチャ、三角形テクスチャ、IFSテクスチャ、メッシュテクスチャの全てにおいて、
レンダリングの品質を設定することができる。やりかたは、
以下のように setTexRendMode() 関数で設定を行えばよい。
\\
\begin{screen}
\begin{verbatim}
        fk_RectTexture  texture;
                :
                :
        texture.setTexRendMode(FK_TEX_REND_SMOOTH);
\end{verbatim}
\end{screen}
~ \\
モードは、通常モードである「FK\_TEX\_REND\_NORMAL」と、
アンチエイリアシング処理で高品質なレンダリングを行う
「FK\_TEX\_REND\_SMOOTH」が指定できる。デフォルトでは
通常モード(FK\_TEX\_REND\_NORMAL)となっている。

上記の例は矩形テクスチャで行っているが、
fk\_RectTexture, fk\_TriTexture, fk\_IFSTexture のいずれの型でも
同様に利用できる。

\section{画像処理用クラス} \label{subsec:image}
第\ref{subsec:texture}節で述べたテクスチャは、画像をファイルから読み込むことを
前提としていたが、用途によってはプログラム中で画像を生成し、
それをテクスチャマッピングするという場合もある。そのような場合、
fk\_Image というクラスを用いて画像を生成することが可能である。
fk\_RectTexture、fk\_TriTexture、fk\_IFSTexture、fk\_MeshTexture にはそれぞれ
setImage() というメンバ関数が用意されており、fk\_Image クラスの
変数をこのメンバ関数で入力することによって、それぞれのテクスチャに
画像情報が反映されるようになっている。

以下のプログラムは、赤から青へのグラデーションを表す画像を生成し、
fk\_RectTexture に画像情報を反映させるプログラムである。
\\
\begin{breakbox}
\begin{verbatim}
        int             i, j;
        fk_RectTexture  texture;
        fk_Image        image;

        // 画像サイズを 256x256 に設定
        image.newImage(256, 256);

        // 各画素に色を設定
        for(i = 0; i < 256; i++) {
            for(j = 0; j < 256; j++) {
                image.setRGB(256-j, 0, j);
            }
        }

        // テクスチャに色を設定
        texture.setImage(&image);
\end{verbatim}
\end{breakbox}
~ \\
fk\_Image クラスのメンバ関数を以下に羅列する。
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void init(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像情報を初期化する。
	\end{tabular} \\ \\

\> \textbf{bool readBMP(const string fileName)} \\
	\> \> \begin{tabular}{p{15cm}}
		ファイル名が fileName である Windows Bitmap 形式の
		画像ファイルを読み込む。成功すれば true を、
		失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool readPNG(const string fileName)} \\
	\> \> \begin{tabular}{p{15cm}}
		ファイル名が fileName である PNG 形式の
		画像ファイルを読み込む。成功すれば true を、
		失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool readJPG(const string fileName)} \\
	\> \> \begin{tabular}{p{15cm}}
		ファイル名が fileName である JPEG 形式の
		画像ファイルを読み込む。成功すれば true を、
		失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool readBMPData(fk\_ImType *buffer)} \\
	\> \> \begin{tabular}{p{15cm}}
		buffer に Windows Bitmap 形式のデータが格納されている
		という仮定のもと、readBMP() 関数と同様の挙動を行う。
	\end{tabular} \\ \\

\> \textbf{bool readPNGData(fk\_ImType *buffer)} \\
	\> \> \begin{tabular}{p{15cm}}
		buffer に PNG 形式のデータが格納されている
		という仮定のもと、readPNG() 関数と同様の挙動を行う。
	\end{tabular} \\ \\

\> \textbf{bool writeBMP(const string fileName, bool transFlag)} \\
	\> \> \begin{tabular}{p{15cm}}
		現在格納されている画像情報を、Windows Bitmap 形式で
		ファイル名が fileName であるファイルに書き出す。
		transFlag を true にすると、透過情報を付加した
		32bit データとして出力し、false の場合通常の
		フルカラー 24bit 形式で出力する。
		書き出しに成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool writeBMP(const string fileName, bool transFlag)} \\
	\> \> \begin{tabular}{p{15cm}}
		現在格納されている画像情報を、PNG 形式で
		ファイル名が fileName であるファイルに書き出す。
		transFlag を true にすると、透過情報も合わせて出力する。
		false の場合は透過情報を削除したファイルを生成する。
		書き出しに成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool writeJPG(const string fileName, int quality)} \\
	\> \> \begin{tabular}{p{15cm}}
		現在格納されている画像情報を、JPEG 形式で
		ファイル名が fileName であるファイルに書き出す。
		quality は 0 から 100 までの整数値を入力し、
		画像品質を設定する。
		数値が低いほど圧縮率は高いが画像品質は低くなる。
		数値が高いほど圧縮率は悪くなるが画像品質は良くなる。
		書き出しに成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{void newImage(int w, int h)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像の大きさを横幅 w, 縦幅 h に設定する。これまでに
		保存されていた画像情報は失われる。
	\end{tabular} \\ \\

\> \textbf{void copyImage(const fk\_Image *image)} \\
	\> \> \begin{tabular}{p{15cm}}
		image の画像情報をコピーする。
	\end{tabular} \\ \\

\> \textbf{void copyImage(const fk\_Image *image, int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		現在の画像に対し、image の画像情報を
		左上が \((x, y)\) となる位置に上書きを行う。
		image はコピー先の中に完全に包含されている必要があり、
		はみ出てしまう場合には上書きは行われない。
	\end{tabular} \\ \\

\> \textbf{void subImage(const fk\_Image *image, int x, int y, int w, int h)} \\
	\> \> \begin{tabular}{p{15cm}}
		元画像 image に対し、
		左上が \((x, y)\)、横幅 w, 縦幅 h となるような
		部分画像をコピーする。
		x, y, w, h に不適切な値が与えられた場合は、
		コピーを行わない。
	\end{tabular} \\ \\

\> \textbf{int getWidth(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像の横幅を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{int getHeight(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像の縦幅を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{int getR(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素の赤要素の値を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{int getG(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素の緑要素の値を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{int getB(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素の青要素の値を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{int getA(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素の透明度要素の値を int 型で返す。
	\end{tabular} \\ \\

\> \textbf{fk\_Color getColor(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素の色要素を fk\_Color 型で返す。
	\end{tabular} \\ \\

\> \textbf{bool setRGBA(int x, int y, int r, int g, int b, int a)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		赤、緑、青、透明度をそれぞれ r, g, b, a に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setRGB(int x, int y, int r, int g, int b)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		赤、緑、青をそれぞれ r, g, b に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setR(int x, int y, int r)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		赤要素を r に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setG(int x, int y, int g)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		緑要素を g に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setB(int x, int y, int b)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		青要素を b に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setA(int x, int y, int a)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		透明度要素を a に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{bool setColor(int x, int y, const fk\_Color \&col)} \\
	\> \> \begin{tabular}{p{15cm}}
		(x, y) の位置にある画素に対し、
		色要素を col が表す色に設定する。
		成功すれば true を、失敗すれば false を返す。
	\end{tabular} \\ \\

\> \textbf{void fillColor(const fk\_Color \&col)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像中の全てのピクセルの色要素を col が表わす色に設定する。
	\end{tabular} \\ \\

\> \textbf{void fillColor(int r, int g, int b, int a)} \\
	\> \> \begin{tabular}{p{15cm}}
		画像中の全てのピクセルの色要素を、r を赤、b を青、
		b を緑、a を透明度として設定する。
	\end{tabular}
\end{tabbing}

\section{文字列板}
第\ref{subsec:texture}節でテクスチャマッピングを利用する方法を、
第\ref{subsec:image}節で画像データを扱う方法を述べたが、
FK システムではテクスチャマッピング画像として文字列板を自動生成することが
可能である。この機能を利用することで、3次元空間上に文字列板を簡単に
生成することができる。

文字列板を生成するには、大体以下のようなステップを踏むことになる。
\begin{enumerate}
 \item fk\_TextImage, fk\_RectTexture 型のオブジェクトを用意する。
 \item フォント情報を読み込む。
 \item 文字列板に対する各種設定を行う。
 \item 文字列情報を読み込む。
 \item fk\_RectTexture 型のオブジェクトに fk\_TextImage 型のオブジェクトを
	設定する。
\end{enumerate}
あとは、普通の fk\_RectTexture 型と同様にして表示が可能となる。これらの
項目は、次節以降でそれぞれを解説する。

\subsection{文字列板オブジェクトの生成}
文字列板を作成するには、最低でも fk\_TextImage 型のオブジェクトと
fk\_RectTexture 型のオブジェクトが必要となる。従って、まずはそれぞれの
変数を準備する。そして、fk\_RectTexture の setImage() メンバ関数を用いて
文字列板(の画像イメージ)を fk\_RextTexture オブジェクトに設定しておく。
\\
\begin{screen}
\begin{verbatim}
        fk_TextImage    textImage;
        fk_RectTexture  texture;

        texture.setImage(&textImage);
\end{verbatim}
\end{screen}

\subsection{フォント情報の読み込み}
次に、フォント情報の読み込みを行う。fk\_TextImage オブジェクトは、
TrueType 日本語フォントを読み込むことができるので、まずは TrueType
日本語フォントを準備する。大抵の場合、拡張子が「ttf」または
「ttc」となっているファイルである。
TrueType フォントが格納されている場所は OS によって異なるが、
検索することで容易に取得できると思われる\footnote{
Windows 系 OS の場合、MS 明朝が「msmincho.ttf」、MS ゴシックが
「msgothic.ttf」というファイル名で保存されている。}。

TrueType フォントファイルが準備できたら、あとはそのファイル名を
initFont() メンバ関数を使って設定する。
この関数は、フォントファイルの読み込みに成功したときは true を、
失敗したときは false を返す。プログラムは、以下のように記述しておくと
フォント読み込みの成功失敗を判定することができる。
(エラー表示には fl\_alert 関数を用いている。)
\\
\begin{screen}
\begin{verbatim}
        if(textImage.initFont("sample.ttf") == false) {
            fl_alert("Font Init Error!");
        }
\end{verbatim}
\end{screen}

\subsection{文字列板の各種設定}
次に、文字列板の各種設定を行う。設定できる項目として、以下のようなものが
fk\_TextImage のメンバ関数として提供されている。
なお、fk\_TextImage クラスは fk\_Image クラスの派生クラスなので、
以下のものに加えて第 \ref{subsec:image} 節で述べた fk\_Image クラスの
メンバ関数も全て利用することができる。

\subsubsection{フォントに関する設定}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setDPI(int dpi)} \\
\> \textbf{void setPTSize(int ptsize)} \\
	\> \> \begin{tabular}{p{15cm}}
		setDPI は文字列の解像度を設定し、setPTSize は文字の大きさを
		設定する。デフォルトは両方とも 48 である。
		現状の FK システムでは
		この2つには機能的な差異がなく、結果的に2つの数値の積が
		文字の精細さを表すことになっている。以後、
		この2つの数値の積 (解像度 \(\times\) 文字の大きさ) を
		「精細度」と呼ぶ。
	\end{tabular} \\ \\

\> \textbf{void setMonospaceMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字を等幅で表示するかどうかを設定する。
		true で等幅、false で非等幅となる。
		true の場合、元々のフォントが等幅でない場合でも
		等幅に補正して表示する。
		デフォルトでは true に設定されている。

\> \textbf{void setMonospaceSize(int size)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字を等幅で表示する場合の、
		文字幅を設定する。
		デフォルトでは 0 に設定されているので、
		この関数で幅を設定しないと表示自体が行われない。

\> \textbf{void setBoldStrength(int strength)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字の太さを数値に応じて太くする。
		初期状態を 1 とし、高い値を与えるほど太くなる。
		どの程度太くなるのかは精細度による。
	\end{tabular} \\ \\

\> \textbf{void setSmoothMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		出力される画像に対しアンチエイリアシング処理を
		行うかどうかを設定する。デフォルトでは true に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果を行うかどうかを設定する。
		デフォルトでは false に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setForeColor(fk\_Color col)} \\
\> \textbf{void setForeColor(float r, float g, float b, float a)} \\
\> \textbf{void setForeColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の文字色を指定する。デフォルトでは
		\((1, 1, 1, 1)\) つまり無透明な白に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setBackColor(fk\_Color col)} \\
\> \textbf{void setBackColor(float r, float g, float b, float a)} \\
\> \textbf{void setBackColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の背景色を指定する。デフォルトでは
		\((0, 0, 0, 1)\) つまり無透明な黒に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowColor(fk\_Color col)} \\
\> \textbf{void setShadowColor(float r, float g, float b, float a)} \\
\> \textbf{void setShadowColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果の影の色を指定する。デフォルトでは
		\((0, 0, 0, 1)\) つまり無透明な黒に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowOffset(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果の、影の相対位置を指定する。
		x が正の場合右、負の場合左にずれる。
		y が正の場合下、負の場合上にずれる。
		デフォルトの値は、両方とも 0 に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setCacheMode(bool mode)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字画像のキャッシュを保持するかどうかを設定する。
		true の場合、一度読み込んだ文字のビットマップを
		キャッシュとして保持するようになるため、再度その文字を
		利用する際に処理が高速になる。ただし、キャッシュを
		行う分システムが利用するメモリ量は増加することになる。
		なお、キャッシュはシステム全体で共有するため、
		異なるインスタンスで読み込んだ文字に関してもキャッシュが
		効くことになる。デフォルトでは false に設定されている。
	\end{tabular} \\ \\

\> \textbf{void clearCache(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		setCacheMode でキャッシュモードが有効であった場合に、
		保存されているキャッシュを全て解放する。
		この関数は static 宣言されているため、
		インスタンスがなくても
		「\verb+fk_TextImage::clearCache();+」とすることで
		利用可能である。
	\end{tabular} \\ \\

\end{tabbing}

\subsubsection{文字列配置に関する設定}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setAlign(fk\_TextAlign align)} \\
	\> \> \begin{tabular}{p{15cm}}
		テキストのアライメントを設定する。設定できるアライメントには
		以下のようなものがある。
			\begin{table}[H]
			\caption{文字列坂テキストのアライメント}
			\label{tbl:textAlign}
			\begin{center}
			\begin{tabular}{|c|l|}
			\hline
			FK\_ALIGN\_LEFT & 文字列を左寄せに配置する。\\ \hline
			FK\_ALIGN\_CENTER &
			文字列をセンタリング(真ん中寄せ)に配置する。\\ \hline
			FK\_ALIGN\_RIGHT & 文字列を右寄に配置する。\\ \hline
			\end{tabular}
			\end{center}
			\end{table}
		デフォルトでは FK\_ALIGN\_LEFT、つまり左寄せに設定されている。
	\end{tabular} \\ \\

\> \textbf{void setOffset(int up, int down, int left, int right)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の、縁と文字のオフセット(幅)を指定する。
		引数は順番に上幅、下幅、左幅、右幅となる。
		デフォルトでは全て 0 に設定されている。
		この値は、setCharSkip や setLineSkip と同様に、
		精細度に依存するものである。
	\end{tabular} \\ \\

\> \textbf{void setCharSkip(int skip)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字同士の横方向の間にある空白の幅を設定する。
		デフォルトでは 0、つまり横方向の空間は「なし」に
		設定されている。
		この値は、前述した精細度に依存するもので、精細度が高い場合には
		skip が表す数値の 1 あたりの幅は狭くなる。
		従って、精細度が高い場合には
		この数値を高めに設定する必要がある。
	\end{tabular} \\ \\

\> \textbf{void setLineSkip(int skip)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字同士の縦方向の間にある空白の高さを設定する。
		デフォルトでは 0、つまり縦方向の空間は「なし」に
		設定されている。
		この値も精細度に依存するので、
		setCharSkip() と同様のことが言える。
	\end{tabular} \\ \\

\> \textbf{void setSpaceLineSkip(int)} \\
	\> \> \begin{tabular}{p{15cm}}
		空行が入っていた場合、その空行の高さを指定する。
		デフォルトでは 0、つまり空行があった場合は
		結果的に省略される状態に設定されている。
		この値も精細度に依存するので、
		setCharSkip() と同様のことが言える。
	\end{tabular} \\ \\

\> \textbf{void setMinLineWidth(int width)} \\
	\> \> \begin{tabular}{p{15cm}}
		通常、画像の横幅はもっとも横幅が長い行と同一となる。
		この関数は、生成される画像の横幅の最小値を width に設定する。
		生成される画像の幅が width 以内であった場合、
		強制的に width に補正される。
	\end{tabular} \\ \\
\end{tabbing}

\subsubsection{文字送りに関する設定} \label{subsubsec:sendRef}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setSendingMode(fk\_TextSendingMode mode)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字送り(\ref{subsec:textSending}節を参照のこと)のモードを
		設定する。設定できるモードには以下のようなものがある。
			\begin{table}[H]
			\caption{文字送りのモード}
			\label{tbl:textSending}
			\begin{center}
			\begin{tabular}{|c|l|}
			\hline
			FK\_SENDING\_ALL &
			文字送りを行わず、全ての文字を一度に表示する。
			\\ \hline
			FK\_SENDING\_CHAR &
			一文字ずつ文字送りを行う。\\ \hline
			FK\_SENIDNG\_LINE &
			一行ずつ文字送りを行う。\\ \hline
			\end{tabular}
			\end{center}
			\end{table}
		デフォルトでは FK\_SENDING\_ALL に設定されている。
	\end{tabular}
\end{tabbing}

\subsection{文字列の設定} \label{subsec:strDef}
次に、表示する文字列を設定する。文字列を設定するには、
fk\_UniStr という型の変数を用いる。具体的には、次のようなコードとなる。
\\
\begin{screen}
\begin{verbatim}
        fk_UniStr       str;
                :
                :
        str.convert("サンプルの文字列です", FK_STR_SJIS);
\end{verbatim}
\end{screen} \\ ~ \\
このように、convert メンバ関数を用いて設定する。1番目の引数には文字列を、
2番目の引数にプログラムコードの文字コードに対応して以下のように設定する。
\begin{table}[H]
\caption{文字コード対応表}
\label{tbl:strCode}
\begin{center}
\begin{tabular}{|c|l|}
\hline
JIS コード & FK\_STR\_JIS \\ \hline
ShiftJIS コード & FK\_STR\_SJIS \\ \hline
EUC コード & FK\_STR\_EUC \\ \hline
ユニコード (UTF16) & FK\_STR\_UTF16 \\ \hline
\end{tabular}
\end{center}
\end{table}

文字列設定は、convert 関数の他に printf 関数がある。
これは、いわゆる標準の printf() 関数とほぼ同一の機能を持つ物で、
変数の値や計算結果などを書式付きで文字列に設定することができる。
ただし、第1引数に前述した文字コードが入る点だけが異なっている。
以下のコードは、str[0]〜str[9]に「0です」〜「9です」という文字列を格納する。
\begin{screen}
\begin{verbatim}
        fk_UniStr     str[10];

        for(int i = 0; i < 10; i++) {
            str[i].printf(FK_STR_SJIS, "%dです", i);
        }
\end{verbatim}
\end{screen}

fk\_UniStr 型変数に格納した文字列を
fk\_TextImage に設定するには、loadUniStr() メンバ関数を用いる。
\\
\begin{screen}
\begin{verbatim}
        fk_UniStr       str;
        fk_TextImage    image;
                :
                :
        str.convert("サンプルの文字列です", FK_STR_SJIS);
        image.loadUniStr(&str);
\end{verbatim}
\end{screen}
\subsection{文字列情報の読み込み}
文字列を設定する方法は、前述した fk\_UniStr 型を
用いる方法の他に、テキストファイルを読み込むという方法もある。
まず、文字列板に貼りたい文字列を事前に
テキストファイルをどこか別のファイルに保存しておく。
文字列を保存する際には、文字列板内で改行したい箇所と
テキストファイル内の改行は必ず合わせておく。あとは、そのファイル名を
fk\_TextImage オブジェクトに loadStrFile() メンバ関数を用いて入力する。
以下は、テキストファイル「str.txt」を入力する例である。
\\
\begin{screen}
\begin{verbatim}
        textImage.loadStrFile("str.txt", FK_STR_SJIS);
\end{verbatim}
\end{screen}
loadStrFile() 関数の2番目の引数は、テキストの文字コードによって
\ref{subsec:strDef} 節の表 \ref{tbl:strCode} に対応した値を入力する。

\subsection{文字列読み込み後の情報取得}
実際に文字列を読み込んだ後、様々な情報を得るためメンバ関数として
以下のようなものが提供されている。

\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{int getLineNum(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		読み込んだ文字列の行数を返す。
	\end{tabular} \\ \\
\> \textbf{int getAllCharNum(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列全体の文字数を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineCharNum(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の文字数を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineWidth(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行幅(単位ピクセル)を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineHeight(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の高さ(単位ピクセル)を返す。
	\end{tabular} \\ \\
\> \textbf{int getMaxLineWidth(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		生成された行のうち、
		もっとも行幅(単位ピクセル)が大きかったものの行幅を返す。
	\end{tabular} \\ \\
\> \textbf{int getMaxLineHeight(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		生成された各行のうち、
		もっとも行の高さ(単位ピクセル)が大きかった行の高さを返す。
	\end{tabular} \\ \\
\> \textbf{int getLineStartXPos(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の左上を表わす画素の \(x\) 方向の位置を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineStartYPos(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の左上を表わす画素の \(y\) 方向の位置を返す。
	\end{tabular}
\end{tabbing}

\subsection{文字列板表示のサンプル}
前節までで各項目の解説を述べたが、ここではこれまでの記述を踏まえて
典型的なコード例を示す。以下のコードは次のような条件を満たすような
コードである。
\begin{itemize}
 \item TrueType フォント名は「msmincho.ttf」。
 \item ソースコードの文字コードは ShiftJIS コード。
 \item 解像度、文字の大きさはそれぞれ 72, 72。
 \item 影付き効果を有効にする。
 \item 文字列の行間を「20」に設定。
 \item 文字色は「\((0.5, 1, 0.8)\)」で無透明にする。
 \item 背景色は「\((0.2, 0.7, 0.8)\)」で半透明にする。
 \item 影色は「\((0, 0, 0)\)」で無透明にする。
 \item 影の相対配置は「\((5, 5)\)」に設定。
 \item アラインはセンタリングにする。
\end{itemize}
~ \\
\begin{breakbox}
\begin{verbatim}
        fk_TextImage            textImage;
        fk_RectTexture          texture;
        fk_Model                model;
        fk_UniStr               str;

        texture.setImage(&textImage);

        if(textImage.initFont("msmincho.ttf") == false) {
            fl_alert("Font Init Error!");
        }
        textImage.setDPI(72);
        textImage.setPTSize(72);
        textImage.setShadowMode(true);
        textImage.setLineSkip(20);
        textImage.setForeColor(0.5, 1.0, 0.8, 1.0);
        textImage.setBackColor(0.2, 0.7, 0.8, 0.3);
        textImage.setShadowColor(0.0, 0.0, 0.0, 1.0);
        textImage.setShadowOffset(5, 5);
        textImage.setAlign(FK_ALIGN_CENTER);

        str.convert("サンプルです。", FK_STR_SJIS);
        textImage.loadUniStr(&str);

        model.setShape(&texture);
\end{verbatim}
\end{breakbox}

\subsection{文字送り} \label{subsec:textSending}
「文字送り」とは、読み込んだ文字列を最初は表示せず、一文字ずつ、あるいは
一行ずつ徐々に表示していく機能のことである。この制御のために
利用する関数は、簡単にまとめると以下のとおりである。
\begin{center}
\begin{tabular}{|l|l|}
\hline
setSendingMode() & 文字送りモード設定 \\ \hline
loadUniStr() & 新規文字列設定 \\ \hline
loadStrFile() & 新規文字列をファイルから読み込み \\ \hline
send() & 文字送り \\ \hline
finish() & 全文字出力 \\ \hline
clear() & 全文字消去 \\ \hline
\end{tabular}
\end{center}
以下に、詳細を述べる。

文字送りのモード設定に関しては、\ref{subsubsec:sendRef} 節で述べたように
setSendingMode() 関数を用いる。ここで \\
FK\_SENDING\_CHAR または
FK\_SENDING\_LINE が設定されていた場合、loadUniStr() 関数や
loadStrFile() 関数で文字列が入力された時点では文字は表示されない。

send() は、文字送りモードに応じて一文字(FK\_SENDING\_CHAR)、
一列(FK\_SENDING\_LINE)、あるいは文字列全体(FK\_SENDING\_ALL)を
テクスチャ画像に出力する。
既に読み込んだ文字を全て出力した状態で send() 関数を呼んだ場合、
特に何も起らずに false が返る。そうでない場合は一文字、一列、あるいは
文字列全体をモードに従って出力を行い、true を返す。
(つまり、最後の文字を send() で出力した時点では true が返り、
その後にさらに send() を呼び出した場合は false() が返る。)

finish() 関数は、文字送りモードに関わらずまだ表示されていない文字を
全て一気に出力する。返り値は bool 型で、意味は send() と同様である。

clear() 関数は、これまで表示していた文字を全て一旦消去し、
読み込んだ時点と同じ状態に戻す。いわゆる「巻き戻し」である。
1文字以上表示されていた状態で clear() を呼んだ場合 true が返り、
まだ1文字も表示されていない状態で clear() を呼んだ場合 false が返る。

具体的なプログラムは、以下のようになる。
このプログラムは、
描画ループが10回まわる度に一文字を表示し、
現在表示中の文字列で、文字が全て表示されていたら
str[] 配列中の次の文字列を読み込むというものである。
処理の高速化をはかるため、setCacheMode() でキャッシュを有効としている。
また、「c」キーを押した場合は表示されていた文字列を一旦消去し、
「f」キーを押した場合は現在表示途中の文字列を全て出力する。
(ウィンドウやキー操作に関しては、\ref{sec:window} 章を参照のこと。) \\

\begin{breakbox}
\begin{verbatim}
        fk_AppWindow    window;
        fk_TextImage    textImage;
        fk_UniStr       str[10];
        int             loopCount, strCount;
                :
                :
        textImage.setSendingMode(FK_SENDING_CHAR);
        textImage.setCacheMode(true);
        textImage.loadUniStr(&str[0]);


        loopCount = 1;
        strCount = 1;
        while(true) {
                        :
            if(window.getKeyStatus('c') == true) {
                // 「c」キーを押した場合
                textImage.clear();
            } else if(window.getKeyStatus('f') == true) {
                // 「f」キーを押した場合
                textImage.finish();
            } else if(loopCount % 10 == 0) {
                if(textImage.send() == false && strCount != 9) {
                    textImage.loadUniStr(&str[strCount]);
                    strCount++;
                }
            }
            loopCount++;
        }
\end{verbatim}
\end{breakbox}
