\chapter{文字列表示} \label{sec:stringimage}
第\ref{subsec:texture}節でテクスチャマッピングを利用する方法を、
第\ref{subsec:image}節で画像データを扱う方法を述べたが、
FK システムでは文字列を画面上にテクスチャマッピング画像として表示するクラスが用意されている。

文字列用テクスチャは 2 種類あり、容易に表示を実現する「fk\_SpriteModel」クラスと、
高度な機能を持つ「fk\_TextImage」クラスである。
この節では、まず fk\_SpriteModel について述べる。

\section{スプライトモデル}
まず、簡易に文字列表示を実現する fk\_SpriteModel クラスの利用方法を解説する。
このクラスによって表示する文字列(等)を「スプライトモデル」と呼ぶ
\footnote{本来の「スプライト」という単語は技術用語で、
1980年代頃のPCやゲーム機に搭載されていた機能であり、
現在のPCやゲーム機ではこの技術は用いられていない。
しかし、画面上の文字列やアイコンの表示に当時スプライト技術が用いられていた慣例から、
現在でも画面上に表示される文字やアイコンを「スプライト」と呼称することがある。}。



\section{高度な文字列表示}

文字列板を生成するには、大体以下のようなステップを踏むことになる。
\begin{enumerate}
 \item fk\_TextImage, fk\_RectTexture 型のオブジェクトを用意する。
 \item フォント情報を読み込む。
 \item 文字列板に対する各種設定を行う。
 \item 文字列情報を読み込む。
 \item fk\_RectTexture 型のオブジェクトに fk\_TextImage 型のオブジェクトを
	設定する。
\end{enumerate}
あとは、普通の fk\_RectTexture 型と同様にして表示が可能となる。これらの
項目は、次節以降でそれぞれを解説する。

\subsection{文字列板オブジェクトの生成}
文字列板を作成するには、最低でも fk\_TextImage 型のオブジェクトと
fk\_RectTexture 型のオブジェクトが必要となる。従って、まずはそれぞれの
変数を準備する。そして、fk\_RectTexture の setImage() メンバ関数を用いて
文字列板(の画像イメージ)を fk\_RextTexture オブジェクトに設定しておく。
\\
\begin{screen}
\begin{verbatim}
        fk_TextImage    textImage;
        fk_RectTexture  texture;

        texture.setImage(&textImage);
\end{verbatim}
\end{screen}

\subsection{フォント情報の読み込み}
次に、フォント情報の読み込みを行う。fk\_TextImage オブジェクトは、
TrueType 日本語フォントを読み込むことができるので、まずは TrueType
日本語フォントを準備する。大抵の場合、拡張子が「ttf」または
「ttc」となっているファイルである。
TrueType フォントが格納されている場所は OS によって異なるが、
検索することで容易に取得できると思われる\footnote{
Windows 系 OS の場合、MS 明朝が「msmincho.ttf」、MS ゴシックが
「msgothic.ttf」というファイル名で保存されている。}。

TrueType フォントファイルが準備できたら、あとはそのファイル名を
initFont() メンバ関数を使って設定する。
この関数は、フォントファイルの読み込みに成功したときは true を、
失敗したときは false を返す。プログラムは、以下のように記述しておくと
フォント読み込みの成功失敗を判定することができる。
(エラー表示には fl\_alert 関数を用いている。)
\\
\begin{screen}
\begin{verbatim}
        if(textImage.initFont("sample.ttf") == false) {
            fl_alert("Font Init Error!");
        }
\end{verbatim}
\end{screen}

\subsection{文字列板の各種設定}
次に、文字列板の各種設定を行う。設定できる項目として、以下のようなものが
fk\_TextImage のメンバ関数として提供されている。
なお、fk\_TextImage クラスは fk\_Image クラスの派生クラスなので、
以下のものに加えて第 \ref{subsec:image} 節で述べた fk\_Image クラスの
メンバ関数も全て利用することができる。

\subsubsection{フォントに関する設定}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setDPI(int dpi)} \\
\> \textbf{void setPTSize(int ptsize)} \\
	\> \> \begin{tabular}{p{15cm}}
		setDPI は文字列の解像度を設定し、setPTSize は文字の大きさを
		設定する。デフォルトは両方とも 48 である。
		現状の FK システムでは
		この2つには機能的な差異がなく、結果的に2つの数値の積が
		文字の精細さを表すことになっている。以後、
		この2つの数値の積 (解像度 \(\times\) 文字の大きさ) を
		「精細度」と呼ぶ。
	\end{tabular} \\ \\

\> \textbf{void setMonospaceMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字を等幅で表示するかどうかを設定する。
		true で等幅、false で非等幅となる。
		true の場合、元々のフォントが等幅でない場合でも
		等幅に補正して表示する。
		デフォルトでは true に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setMonospaceSize(int size)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字を等幅で表示する場合の、
		文字幅を設定する。
		デフォルトでは 0 に設定されているので、
		この関数で幅を設定しないと表示自体が行われない。
	\end{tabular} \\ \\

\> \textbf{void setBoldStrength(int strength)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字の太さを数値に応じて太くする。
		初期状態を 1 とし、高い値を与えるほど太くなる。
		どの程度太くなるのかは精細度による。
	\end{tabular} \\ \\

\> \textbf{void setSmoothMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		出力される画像に対しアンチエイリアシング処理を
		行うかどうかを設定する。デフォルトでは true に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowMode(bool flg)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果を行うかどうかを設定する。
		デフォルトでは false に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setForeColor(fk\_Color col)} \\
\> \textbf{void setForeColor(float r, float g, float b, float a)} \\
\> \textbf{void setForeColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の文字色を指定する。デフォルトでは
		\((1, 1, 1, 1)\) つまり無透明な白に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setBackColor(fk\_Color col)} \\
\> \textbf{void setBackColor(float r, float g, float b, float a)} \\
\> \textbf{void setBackColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の背景色を指定する。デフォルトでは
		\((0, 0, 0, 1)\) つまり無透明な黒に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowColor(fk\_Color col)} \\
\> \textbf{void setShadowColor(float r, float g, float b, float a)} \\
\> \textbf{void setShadowColor(double r, double g, double b, double a)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果の影の色を指定する。デフォルトでは
		\((0, 0, 0, 1)\) つまり無透明な黒に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setShadowOffset(int x, int y)} \\
	\> \> \begin{tabular}{p{15cm}}
		影付き効果の、影の相対位置を指定する。
		x が正の場合右、負の場合左にずれる。
		y が正の場合下、負の場合上にずれる。
		デフォルトの値は、両方とも 0 に設定されている。
	\end{tabular} \\ \\

\> \textbf{void setCacheMode(bool mode)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字画像のキャッシュを保持するかどうかを設定する。
		true の場合、一度読み込んだ文字のビットマップを
		キャッシュとして保持するようになるため、再度その文字を
		利用する際に処理が高速になる。ただし、キャッシュを
		行う分システムが利用するメモリ量は増加することになる。
		なお、キャッシュはシステム全体で共有するため、
		異なるインスタンスで読み込んだ文字に関してもキャッシュが
		効くことになる。デフォルトでは false に設定されている。
	\end{tabular} \\ \\

\> \textbf{void clearCache(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		setCacheMode でキャッシュモードが有効であった場合に、
		保存されているキャッシュを全て解放する。
		この関数は static 宣言されているため、
		インスタンスがなくても
		「\verb+fk_TextImage::clearCache();+」とすることで
		利用可能である。
	\end{tabular} \\ \\

\end{tabbing}

\subsubsection{文字列配置に関する設定}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setAlign(fk\_TextAlign align)} \\
	\> \> \begin{tabular}{p{15cm}}
		テキストのアライメントを設定する。設定できるアライメントには
		以下のようなものがある。
			\begin{table}[H]
			\caption{文字列坂テキストのアライメント}
			\label{tbl:textAlign}
			\begin{center}
			\begin{tabular}{|c|l|}
			\hline
			FK\_ALIGN\_LEFT & 文字列を左寄せに配置する。\\ \hline
			FK\_ALIGN\_CENTER &
			文字列をセンタリング(真ん中寄せ)に配置する。\\ \hline
			FK\_ALIGN\_RIGHT & 文字列を右寄に配置する。\\ \hline
			\end{tabular}
			\end{center}
			\end{table}
		デフォルトでは FK\_ALIGN\_LEFT、つまり左寄せに設定されている。
	\end{tabular} \\ \\

\> \textbf{void setOffset(int up, int down, int left, int right)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列板の、縁と文字のオフセット(幅)を指定する。
		引数は順番に上幅、下幅、左幅、右幅となる。
		デフォルトでは全て 0 に設定されている。
		この値は、setCharSkip や setLineSkip と同様に、
		精細度に依存するものである。
	\end{tabular} \\ \\

\> \textbf{void setCharSkip(int skip)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字同士の横方向の間にある空白の幅を設定する。
		デフォルトでは 0、つまり横方向の空間は「なし」に
		設定されている。
		この値は、前述した精細度に依存するもので、精細度が高い場合には
		skip が表す数値の 1 あたりの幅は狭くなる。
		従って、精細度が高い場合には
		この数値を高めに設定する必要がある。
	\end{tabular} \\ \\

\> \textbf{void setLineSkip(int skip)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字同士の縦方向の間にある空白の高さを設定する。
		デフォルトでは 0、つまり縦方向の空間は「なし」に
		設定されている。
		この値も精細度に依存するので、
		setCharSkip() と同様のことが言える。
	\end{tabular} \\ \\

\> \textbf{void setSpaceLineSkip(int)} \\
	\> \> \begin{tabular}{p{15cm}}
		空行が入っていた場合、その空行の高さを指定する。
		デフォルトでは 0、つまり空行があった場合は
		結果的に省略される状態に設定されている。
		この値も精細度に依存するので、
		setCharSkip() と同様のことが言える。
	\end{tabular} \\ \\

\> \textbf{void setMinLineWidth(int width)} \\
	\> \> \begin{tabular}{p{15cm}}
		通常、画像の横幅はもっとも横幅が長い行と同一となる。
		この関数は、生成される画像の横幅の最小値を width に設定する。
		生成される画像の幅が width 以内であった場合、
		強制的に width に補正される。
	\end{tabular} \\ \\
\end{tabbing}

\subsubsection{文字送りに関する設定} \label{subsubsec:sendRef}
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setSendingMode(fk\_TextSendingMode mode)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字送り(\ref{subsec:textSending}節を参照のこと)のモードを
		設定する。設定できるモードには以下のようなものがある。
			\begin{table}[H]
			\caption{文字送りのモード}
			\label{tbl:textSending}
			\begin{center}
			\begin{tabular}{|c|l|}
			\hline
			FK\_SENDING\_ALL &
			文字送りを行わず、全ての文字を一度に表示する。
			\\ \hline
			FK\_SENDING\_CHAR &
			一文字ずつ文字送りを行う。\\ \hline
			FK\_SENIDNG\_LINE &
			一行ずつ文字送りを行う。\\ \hline
			\end{tabular}
			\end{center}
			\end{table}
		デフォルトでは FK\_SENDING\_ALL に設定されている。
	\end{tabular}
\end{tabbing}

\subsection{文字列の設定} \label{subsec:strDef}
次に、表示する文字列を設定する。文字列を設定するには、
fk\_UniStr という型の変数を用いる。具体的には、次のようなコードとなる。
\\
\begin{screen}
\begin{verbatim}
        fk_UniStr       str;
                :
                :
        str.convert("サンプルの文字列です", FK_STR_SJIS);
\end{verbatim}
\end{screen} \\ ~ \\
このように、convert メンバ関数を用いて設定する。1番目の引数には文字列を、
2番目の引数にプログラムコードの文字コードに対応して以下のように設定する。
\begin{table}[H]
\caption{文字コード対応表}
\label{tbl:strCode}
\begin{center}
\begin{tabular}{|c|l|}
\hline
JIS コード & FK\_STR\_JIS \\ \hline
ShiftJIS コード & FK\_STR\_SJIS \\ \hline
EUC コード & FK\_STR\_EUC \\ \hline
ユニコード (UTF16) & FK\_STR\_UTF16 \\ \hline
\end{tabular}
\end{center}
\end{table}

文字列設定は、convert 関数の他に printf 関数がある。
これは、いわゆる標準の printf() 関数とほぼ同一の機能を持つ物で、
変数の値や計算結果などを書式付きで文字列に設定することができる。
ただし、第1引数に前述した文字コードが入る点だけが異なっている。
以下のコードは、str[0]〜str[9]に「0です」〜「9です」という文字列を格納する。
\begin{screen}
\begin{verbatim}
        fk_UniStr     str[10];

        for(int i = 0; i < 10; i++) {
            str[i].printf(FK_STR_SJIS, "%dです", i);
        }
\end{verbatim}
\end{screen}

fk\_UniStr 型変数に格納した文字列を
fk\_TextImage に設定するには、loadUniStr() メンバ関数を用いる。
\\
\begin{screen}
\begin{verbatim}
        fk_UniStr       str;
        fk_TextImage    image;
                :
                :
        str.convert("サンプルの文字列です", FK_STR_SJIS);
        image.loadUniStr(&str);
\end{verbatim}
\end{screen}
\subsection{文字列情報の読み込み}
文字列を設定する方法は、前述した fk\_UniStr 型を
用いる方法の他に、テキストファイルを読み込むという方法もある。
まず、文字列板に貼りたい文字列を事前に
テキストファイルをどこか別のファイルに保存しておく。
文字列を保存する際には、文字列板内で改行したい箇所と
テキストファイル内の改行は必ず合わせておく。あとは、そのファイル名を
fk\_TextImage オブジェクトに loadStrFile() メンバ関数を用いて入力する。
以下は、テキストファイル「str.txt」を入力する例である。
\\
\begin{screen}
\begin{verbatim}
        textImage.loadStrFile("str.txt", FK_STR_SJIS);
\end{verbatim}
\end{screen}
loadStrFile() 関数の2番目の引数は、テキストの文字コードによって
\ref{subsec:strDef} 節の表 \ref{tbl:strCode} に対応した値を入力する。

\subsection{文字列読み込み後の情報取得}
実際に文字列を読み込んだ後、様々な情報を得るためメンバ関数として
以下のようなものが提供されている。

\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{int getLineNum(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		読み込んだ文字列の行数を返す。
	\end{tabular} \\ \\
\> \textbf{int getAllCharNum(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		文字列全体の文字数を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineCharNum(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の文字数を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineWidth(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行幅(単位ピクセル)を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineHeight(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の高さ(単位ピクセル)を返す。
	\end{tabular} \\ \\
\> \textbf{int getMaxLineWidth(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		生成された行のうち、
		もっとも行幅(単位ピクセル)が大きかったものの行幅を返す。
	\end{tabular} \\ \\
\> \textbf{int getMaxLineHeight(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		生成された各行のうち、
		もっとも行の高さ(単位ピクセル)が大きかった行の高さを返す。
	\end{tabular} \\ \\
\> \textbf{int getLineStartXPos(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の左上を表わす画素の \(x\) 方向の位置を返す。
	\end{tabular} \\ \\
\> \textbf{int getLineStartYPos(int lineID)} \\
	\> \> \begin{tabular}{p{15cm}}
		最初の行を 0 行目としたときの、
		lineID 行目の行の左上を表わす画素の \(y\) 方向の位置を返す。
	\end{tabular}
\end{tabbing}

\subsection{文字列板表示のサンプル}
前節までで各項目の解説を述べたが、ここではこれまでの記述を踏まえて
典型的なコード例を示す。以下のコードは次のような条件を満たすような
コードである。
\begin{itemize}
 \item TrueType フォント名は「msmincho.ttf」。
 \item ソースコードの文字コードは ShiftJIS コード。
 \item 解像度、文字の大きさはそれぞれ 72, 72。
 \item 影付き効果を有効にする。
 \item 文字列の行間を「20」に設定。
 \item 文字色は「\((0.5, 1, 0.8)\)」で無透明にする。
 \item 背景色は「\((0.2, 0.7, 0.8)\)」で半透明にする。
 \item 影色は「\((0, 0, 0)\)」で無透明にする。
 \item 影の相対配置は「\((5, 5)\)」に設定。
 \item アラインはセンタリングにする。
\end{itemize}
~ \\
\begin{breakbox}
\begin{verbatim}
        fk_TextImage            textImage;
        fk_RectTexture          texture;
        fk_Model                model;
        fk_UniStr               str;

        texture.setImage(&textImage);

        if(textImage.initFont("msmincho.ttf") == false) {
            fl_alert("Font Init Error!");
        }
        textImage.setDPI(72);
        textImage.setPTSize(72);
        textImage.setShadowMode(true);
        textImage.setLineSkip(20);
        textImage.setForeColor(0.5, 1.0, 0.8, 1.0);
        textImage.setBackColor(0.2, 0.7, 0.8, 0.3);
        textImage.setShadowColor(0.0, 0.0, 0.0, 1.0);
        textImage.setShadowOffset(5, 5);
        textImage.setAlign(FK_ALIGN_CENTER);

        str.convert("サンプルです。", FK_STR_SJIS);
        textImage.loadUniStr(&str);

        model.setShape(&texture);
\end{verbatim}
\end{breakbox}

\subsection{文字送り} \label{subsec:textSending}
「文字送り」とは、読み込んだ文字列を最初は表示せず、一文字ずつ、あるいは
一行ずつ徐々に表示していく機能のことである。この制御のために
利用する関数は、簡単にまとめると以下のとおりである。
\begin{center}
\begin{tabular}{|l|l|}
\hline
setSendingMode() & 文字送りモード設定 \\ \hline
loadUniStr() & 新規文字列設定 \\ \hline
loadStrFile() & 新規文字列をファイルから読み込み \\ \hline
send() & 文字送り \\ \hline
finish() & 全文字出力 \\ \hline
clear() & 全文字消去 \\ \hline
\end{tabular}
\end{center}
以下に、詳細を述べる。

文字送りのモード設定に関しては、\ref{subsubsec:sendRef} 節で述べたように
setSendingMode() 関数を用いる。ここで \\
FK\_SENDING\_CHAR または
FK\_SENDING\_LINE が設定されていた場合、loadUniStr() 関数や
loadStrFile() 関数で文字列が入力された時点では文字は表示されない。

send() は、文字送りモードに応じて一文字(FK\_SENDING\_CHAR)、
一列(FK\_SENDING\_LINE)、あるいは文字列全体(FK\_SENDING\_ALL)を
テクスチャ画像に出力する。
既に読み込んだ文字を全て出力した状態で send() 関数を呼んだ場合、
特に何も起らずに false が返る。そうでない場合は一文字、一列、あるいは
文字列全体をモードに従って出力を行い、true を返す。
(つまり、最後の文字を send() で出力した時点では true が返り、
その後にさらに send() を呼び出した場合は false() が返る。)

finish() 関数は、文字送りモードに関わらずまだ表示されていない文字を
全て一気に出力する。返り値は bool 型で、意味は send() と同様である。

clear() 関数は、これまで表示していた文字を全て一旦消去し、
読み込んだ時点と同じ状態に戻す。いわゆる「巻き戻し」である。
1文字以上表示されていた状態で clear() を呼んだ場合 true が返り、
まだ1文字も表示されていない状態で clear() を呼んだ場合 false が返る。

具体的なプログラムは、以下のようになる。
このプログラムは、
描画ループが10回まわる度に一文字を表示し、
現在表示中の文字列で、文字が全て表示されていたら
str[] 配列中の次の文字列を読み込むというものである。
処理の高速化をはかるため、setCacheMode() でキャッシュを有効としている。
また、「c」キーを押した場合は表示されていた文字列を一旦消去し、
「f」キーを押した場合は現在表示途中の文字列を全て出力する。
(ウィンドウやキー操作に関しては、\ref{sec:window} 章を参照のこと。) \\

\begin{breakbox}
\begin{verbatim}
        fk_AppWindow    window;
        fk_TextImage    textImage;
        fk_UniStr       str[10];
        int             loopCount, strCount;
                :
                :
        textImage.setSendingMode(FK_SENDING_CHAR);
        textImage.setCacheMode(true);
        textImage.loadUniStr(&str[0]);


        loopCount = 1;
        strCount = 1;
        while(true) {
                        :
            if(window.getKeyStatus('c') == true) {
                // 「c」キーを押した場合
                textImage.clear();
            } else if(window.getKeyStatus('f') == true) {
                // 「f」キーを押した場合
                textImage.finish();
            } else if(loopCount % 10 == 0) {
                if(textImage.send() == false && strCount != 9) {
                    textImage.loadUniStr(&str[strCount]);
                    strCount++;
                }
            }
            loopCount++;
        }
\end{verbatim}
\end{breakbox}

