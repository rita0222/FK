\chapter{サンプルプログラム} \label{sec:sample}
\section{基本的形状の生成と親子関係}
次に掲載するプログラムは、原点付近に1個の直方体と2本の線分を作成し
表示するプログラムである。ただ表示するだけでは面白くないので、線分を
直方体の子モデルにし、直方体を回転させると線分も一緒に回転することを
試してみる。また、視点も最初は遠方に置いて段々近づけていき、ある程度まで
接近したらひねりを加えてみる。

\begin{itemize}
 \item 1 行目の include 文は、FK システムを使用する場合に必ず記述する。
 \item 5 行目において、メインウィンドウを生成している。
 \item 6 行目において、視点 (camera)、直方体 (blockModel)、
	照明 (lightModel)、線分2本 (lineModel[2]) を定義している。
 \item 8 〜 10 行目で、それぞれのオブジェクトの形状情報を生成している。
 \item 11 行目でシーンを、12 行目で FK システムのウィンドウを
	生成している。
 \item 15 行目で、fk\_Window のメインウィンドウへの登録を完了している。
 \item 16 行目で標準マテリアルの初期化を行っている。標準マテリアルを
	使用したい場合は、プログラムの最初にこの
	fk\_Material::initDefault() 関数を呼ぶ。
 \item 19 〜 22 行目まで、照明の設定を行っている。この場合は、
	\((1000, 1000, 1000)\) から原点へ向けて平行光源が設定される。
 \item 25 行目で blockModel に block の形状情報をリンクしている。
 \item 29 〜 36 行目で、線分形状を生成し lineModel[] にリンクしている。
	35 行目では \&pos[0] を代入することによって pos[0] と pos[1] が、
	36 行目では \&pos[2] を代入することによって pos[2] と pos[3] が
	それぞれ線分の端点となる。
 \item 39、40 行目で、線分に対して色設定を行っている。
	どのような形状であっても、線に対して色を設定する場合は
	setLineColor() を用いる。
 \item 43、44 行目で、線分を直方体の子モデルに設定している。これにより、
	直方体を移動すると線分も追従して移動していくようになる。
 \item 47 〜 51 行目で、各モデルをシーンへ登録している。
 \item 54 行目で、シーンをウィンドウへ登録している。
	これにより、window.drawWindow() によってシーンの
	中身が描画されるようになる。
 \item 57 〜 59 行目で、視点の位置を設定している。この場合は、位置を
	\((0, 0, 2000)\)、方向を原点に向け、ウィンドウの上方向が
	\((0, 1, 0)\) になるように設定している。
 \item 62 行目でメインウィンドウを、63 行目で FK システムのウィンドウを
	開いている。
 \item 67 〜 73 行目は、ウィンドウが開いているか閉じているか(アイコン化
	されているか)を判定し、閉じている場合は描画処理を行わないように
	なっている。
 \item 75 行目にて実際に描画を行っている。
 \item 75 〜 77 行目では、プログラムを終了するかどうかを判定している。
	画面上で「ESC」ボタンが押されていたり、ウィンドウが強制的に
	閉じられたかどうかの判定はここで行っている。
	ここを含め、67 〜 77 行目の記述は、FK システムでは常套の手段として
	用いられる記述である。
 \item 80 行目で、視点位置を \((0, 0, -1)\) 移動している。
 \item 83 行目で、直方体 (と子モデルである線分) を Y 軸中心に
	回転させている。回転角度は、\(\pi/300 = 0.6 ^{\circ}\) である。
 \item 86 〜 88 行目で、もし視点が原点を越えてしまった場合に注視点を
	原点に向かせるようにしている。
 \item 90 〜 94 行目で、描画カウント i が 1000 を超えた場合に
	視点にひねりを加えている。
\end{itemize}

\begin{breakbox}
\begin{verbatim}
  1: #include <FK/FK.h>
  2: 
  3: int main(int argc, char *argv[])
  4: {
  5:     Fl_Window       mainWindow(620, 620, "FK TEST");
  6:     fk_Model        camera, blockModel, lightModel, lineModel[2];
  7:     fk_Vector       pos[4];
  8:     fk_Line         line[2];
  9:     fk_Light        light;
 10:     fk_Block        block(50.0, 70.0, 40.0);
 11:     fk_Scene        scene;
 12:     fk_Window       window(10, 10, 600, 600);
 13:     int             i = 0;
 14: 
 15:     mainWindow.end();
 16:     fk_Material::initDefault();
 17: 
 18:     // 照明の設定
 19:     lightModel.setShape(&light);
 20:     lightModel.setMaterial(White);
 21:     lightModel.glMoveTo(0.0, 0.0, 0.0);
 22:     lightModel.glFocus(-1.0, -1.0, -1.0);
 23: 
 24:     // 直方体の設定
 25:     blockModel.setShape(&block);
 26:     blockModel.setMaterial(Yellow);
 27: 
 28:     // 線分の設定
 29:     pos[0].set(0.0, 100.0, 0.0);
 30:     pos[1].set(100.0, 0.0, 0.0);
 31:     pos[2] = -pos[0];
 32:     pos[3] = -pos[1];
 33:     line[0].setVertex(&pos[0]);
 34:     line[1].setVertex(&pos[2]);
 35:     lineModel[0].setShape(&line[0]);
 36:     lineModel[1].setShape(&line[1]);
 37: 
 38:     // 線分の色設定
 39:     lineModel[0].setLineColor(1.0f, 0.0f, 0.0f);
 40:     lineModel[1].setLineColor(0.0f, 1.0f, 0.0f);
 41: 
 42:     // 直方体を線分の親モデルに設定
 43:     lineModel[0].setParent(&blockModel);
 44:     lineModel[1].setParent(&blockModel);
 45: 
 46:     // 各モデルをディスプレイリストに登録
 47:     scene.entryCamera(&camera);
 48:     scene.entryModel(&blockModel);
 49:     scene.entryModel(&lightModel);
 50:     scene.entryModel(&lineModel[0]);
 51:     scene.entryModel(&lineModel[1]);
 52: 
 53:     // ウィンドウへディスプレイリストを登録
 54:     window.setScene(&scene);
 55: 
 56:     // 視点の位置と姿勢を設定
 57:     camera.glMoveTo(0.0, 0.0, 2000.0);
 58:     camera.glFocus(0.0, 0.0, 0.0);
 59:     camera.glUpvec(0.0, 1.0, 0.0);
 60: 
 61:     i = 0;
 62:     mainWindow.show();
 63:     window.show();
 64: 
 65:     while(true) {
 66: 
 67:         if(mainWindow.visible() == 0) {
 68:             if(Fl::wait() == 0) {
 69:                 break;
 70:             } else {
 71:                 continue;
 72:             }
 73:         }
 74: 
 75:         if(window.drawWindow() == 0) break;
 76:         if(Fl::check() == 0) break;
 77:         if(window.winOpenStatus() == false) continue;
 78: 
 79:         // 視点を原点に近づける
 80:         camera.glTranslate(0.0, 0.0, -0.1);
 81: 
 82:         // 直方体(と子モデルの線分)を Y 軸中心に回転
 83:         blockModel.glRotateWithVec(0.0, 0.0, 0.0, fk_Y, FK_PI/300.0);
 84: 
 85:         // 視点が原点を越えたら、向きをもう1度原点に向かせる。
 86:         if(camera.getPosition().z < -FK_EPS) {
 87:             camera.glFocus(0.0, 0.0, 0.0);
 88:         }
 89: 
 90:         if(i >= 1000) {
 91:             // i が 1000 以上なら、視点をひねっていく
 92:             camera.loRotateWithVec(0.0, 0.0, 0.0,
 93:                                    fk_Z, FK_PI/500.0);
 94:         }
 95: 
 96:         i++;
 97:     }
 98: 
 99:     return 0;
100: }
\end{verbatim}
\end{breakbox}

\section{LOD 処理とカメラ切り替え}
次のサンプルは、ボールが弾む様子を描いたプログラムである。このプログラムを
実行すると、ボールが2回弾む間は鳥瞰的なカメラ視点だが、その後に青色の
ブロックからボールを見る視点に切り替わる。プログラムのおおまかな流れは
自分で解析して頂きたいが、ここでは最初のサンプルにはなかった概念に
関して説明する。

まず、17 行目にて Ball クラスを定義し、この中で fk\_Model や fk\_Sphere の
オブジェクトを持つようにしている。このようなプログラミングスタイルは、
ややオブジェクト指向を意識したものと言えよう。

25 〜 27 行目にて球を分割数を変えて 3 種類定義しているが、これは
78 行目からの lod() メンバ関数内で Ball の実際の形状を動的に選択できるように
するためである。78 行目から実現している LOD 処理とは、視点とオブジェクトの
距離によって形状の精密さを動的に変化させるテクニックである。たとえば、
多くのポリゴンでできている形状は精密で迫力があるが、視点から
とても遠くて非常に小さく表示されているような場合は無駄に処理されている
ことになる。そこで、遠くにあって小さく表示されている場合は粗い形状を
表示して処理の高速化を計るのが LOD 処理の目的である。このサンプルの
LOD 処理はわかりやすくするために露骨に変化が見られるが、実際に
プログラムを作成するときはわかりにくくなるように視点距離との関係を
調整する。
\\
\begin{breakbox}
\begin{verbatim}
  1: #include <FK/FK.h>
  2: 
  3: const double    DOWN_ACCEL      = 1.0500;   // 降下時の加速度
  4: const double    RISE_ACCEL      = 1.0530;   // 上昇時の減速度
  5: const int       DOWN_MODE       = 0;        // 降下モード
  6: const int       RISE_MODE       = 1;        // 上昇モード
  7: const int       LOW_MODE        = 0;        // ブロック視点モード
  8: const int       HIGH_MODE       = 1;        // 鳥瞰モード
  9: const int       LOD4_HIGH       = 200;      // 4分割距離 (鳥瞰)
 10: const int       LOD3_HIGH       = 300;      // 3分割距離 (鳥瞰)
 11: const int       LOD4_LOW        = 90;       // 4分割距離 (ブロック)
 12: const int       LOD3_LOW        = 120;      // 3分割距離 (ブロック)
 13: const double    TOP_BALL_POS    = 300.0;    // ボール始点高さ
 14: const double    BTM_BALL_POS    = 18.0;     // ボール跳ね返り高さ
 15: const double    BALL_SIZE       = 12.0;     // ボール半径
 16: 
 17: class Ball {
 18: 
 19: private:
 20:     int         direction;      // ボールの状態(DOWN_MODE or RISE_MODE)
 21:     int         view_mode;      // 視点モード
 22:     int         bound_count;    // バウンド回数を数える変数
 23:     double      y_trs;          // ボールのy座標移動量
 24:     fk_Model    ball_model;     // ボールのモデル
 25:     fk_Sphere   BALL2;          // 2分割形状
 26:     fk_Sphere   BALL3;          // 3分割形状
 27:     fk_Sphere   BALL4;          // 4分割形状
 28: 
 29: public:
 30: 
 31:     Ball(void);
 32:     void        init(void);
 33:     fk_Model *  getModel(void);
 34:     fk_Vector   getPosition(void);
 35:     void        lod(fk_Vector);
 36:     void        accel(void);
 37:     void        bound(void);
 38:     int         draw(fk_Vector);
 39: };
 40: 
 41: // コンストラクタ
 42: Ball::Ball(void)
 43: {
 44:     init();
 45: }
 46: 
 47: // 初期化
 48: void Ball::init(void)
 49: {
 50:     direction    = DOWN_MODE;
 51:     y_trs        = 0.1;
 52:     view_mode    = HIGH_MODE;
 53:     bound_count  = 1;
 54:     BALL2.setRadius(BALL_SIZE);
 55:     BALL2.setDivide(2);
 56:     BALL3.setRadius(BALL_SIZE);
 57:     BALL3.setDivide(3);
 58:     BALL4.setRadius(BALL_SIZE);
 59:     BALL4.setDivide(4);
 60: 
 61:     ball_model.glMoveTo(0.0, TOP_BALL_POS, 0.0);
 62:     ball_model.setShape(&BALL2);
 63: }
 64: 
 65: // fk_Model を返す関数
 66: fk_Model * Ball::getModel(void)
 67: {
 68:     return &ball_model;
 69: }
 70: 
 71: // ボールの現在位置を返す関数
 72: fk_Vector Ball::getPosition(void)
 73: {
 74:     return ball_model.getPosition();
 75: }
 76: 
 77: // 視点からの距離によってボールの分割数を変える関数 (Level Of Detail)
 78: void Ball::lod(fk_Vector pos){
 79:     double    distance;
 80: 
 81:     distance = (ball_model.getPosition() - pos).dist();
 82: 
 83:     switch(view_mode) {
 84:       case HIGH_MODE:
 85: 
 86:         if(distance < LOD4_HIGH) {
 87:             ball_model.setShape(&BALL4);
 88:         } else if(distance < LOD3_HIGH) {
 89:             ball_model.setShape(&BALL3);
 90:         } else {
 91:             ball_model.setShape(&BALL2);
 92:         }
 93:         break;
 94: 
 95:       case LOW_MODE:
 96: 
 97:         if(distance < LOD4_LOW) {
 98:             ball_model.setShape(&BALL4);
 99:         } else if(distance < LOD3_LOW) {
100:             ball_model.setShape(&BALL3);
101:         } else {
102:             ball_model.setShape(&BALL2);
103:         }
104:         break;
105: 
106:       default:
107:         fl_alert("Err!! View Mode is wrong.");
108:         break;
109:     }
110: 
111:     return;
112: }
113: 
114: // ボールを加速させる関数
115: void Ball::accel(void)
116: {
117:     switch(direction) {
118:       case DOWN_MODE:
119:         y_trs *= DOWN_ACCEL;
120:         ball_model.glTranslate(0.0, -y_trs, 0.0);
121:         break;
122: 
123:       case RISE_MODE:
124:         y_trs /= RISE_ACCEL;
125:         ball_model.glTranslate(0.0, y_trs,0.0);
126:         break;
127:         
128:       default:
129:         fl_alert("Err!! Direction Mode is wrong.");
130:         break;
131:     }
132: }
133: 
134: // ボールの跳ね返り判定をする関数
135: void Ball::bound(void)
136: {
137:     if(ball_model.getPosition().y < BTM_BALL_POS) {
138:         direction = RISE_MODE;
139:     } else if(y_trs < 0.01) {
140:         if(direction == RISE_MODE) {
141:             if(bound_count % 4 < 2) {
142:                 view_mode = HIGH_MODE;
143:             } else {
144:                 view_mode = LOW_MODE;
145:             }
146:             bound_count++;
147:         }
148:         direction = DOWN_MODE;
149:     }
150: 
151:     return;
152: }
153: 
154: // ボールの運動に関する関数. 返り値は視点モード
155: int Ball::draw(fk_Vector pos)
156: {
157:     lod(pos);
158:     bound();
159:     accel();
160:     //４回跳ね返ると初期化
161:     if(bound_count > 4) init();
162:     return view_mode;
163: }
164: 
165: int main(int argc, char *argv[])
166: {
167:     fk_Scene        scene;
168:     int             view_mode = HIGH_MODE;
169:     Ball            ball;
170:     fk_Model        viewModel, lightModel, groundModel, blockModel;
171:     fk_Light        light;
172:     fk_Circle       ground(4, 100.0);
173:     fk_Block        block(10.0, 10.0, 10.0);
174: 
175: 
176:     // ### WINDOW ###
177:     Fl_Window        mainWin(620, 620, "BALL TEST");
178:     fk_Window        win(10, 10, 600, 600);
179:     mainWin.end();
180:     fk_Material::initDefault();
181: 
182:     // ### VIEW POINT ###
183:     // 上の方から見た視点
184:     viewModel.glMoveTo(0.0, 400.0, 80.0);
185:     viewModel.glFocus(0.0, 30.0, 0.0);
186:     viewModel.glUpvec(0.0, 1.0, 0.0);
187: 
188:     // ### LIGHT ###
189:     light.setLightType(FK_POINT_LIGHT);
190:     light.setAttenuation(0.0, 0.0);
191:     lightModel.setShape(&light);
192:     lightModel.setMaterial(White);
193:     lightModel.glTranslate(-60.0, 60.0, 0.0);
194: 
195:     // ### GROUND ###
196:     groundModel.setShape(&ground);
197:     groundModel.setMaterial(LightGreen);
198:     groundModel.setSmoothMode(true);
199:     groundModel.loRotateWithVec(0.0, 0.0, 0.0, fk_X, -FK_PI/2.0);
200: 
201:     // ### VIEW BLOCK ###
202:     blockModel.setShape(&block);
203:     blockModel.setMaterial(Blue);
204:     blockModel.glMoveTo(60.0, 30.0, 0.0);
205:     blockModel.setParent(&groundModel);
206: 
207:     // ### BALL ###
208:     ball.getModel()->setMaterial(Red);
209:     ball.getModel()->setSmoothMode(true);
210:     
211:     // ### Model Entry ###
212:     scene.entryCamera(&viewModel);
213:     scene.entryModel(&lightModel);
214:     scene.entryModel(ball.getModel());
215:     scene.entryModel(&groundModel);
216:     scene.entryModel(&blockModel); 
217:     win.setScene(&scene);
218: 
219:     mainWin.show();
220:     win.show();
221: 
222:     // ### MAIN LOOP ###
223:     while(true) {
224: 
225:         if(mainWin.visible() == 0) {
226:             if(Fl::wait() == 0) {
227:                 break;
228:             } else {
229:                 continue;
230:             }
231:         }
232:         if(win.drawWindow() == 0) break;
233:         if(Fl::check() == 0) break;
234:         if(win.winOpenStatus() == false) continue;
235: 
236:         // ボールを弾ませて, カメラの状態を取得。
237:         view_mode = ball.draw(viewModel.getPosition());
238: 
239:         if(view_mode == HIGH_MODE) {
240:             // カメラを上からの視点にする。
241:             viewModel.glMoveTo(0.0, 400.0, 80.0);
242:             viewModel.glFocus(0.0, 30.0, 0.0);
243:             viewModel.glUpvec(0.0, 1.0, 0.0);
244:             scene.entryModel(&blockModel);
245:         } else {
246:             // カメラをブロックからの視点にする。
247:             viewModel.glMoveTo(blockModel.getInhPosition());
248:             viewModel.glTranslate(0.0, 10.0, 0.0);
249:             viewModel.glFocus(ball.getPosition());
250:             viewModel.glUpvec(0.0, 1.0, 0.0);
251:             scene.removeModel(&blockModel);
252:         }
253: 
254:         // 地面をくるくる回転させましょう。
255:         groundModel.glRotateWithVec(0.0, 0.0, 0.0, fk_Y, 0.02);
256:     }
257: 
258:     return 0;
259: }
\end{verbatim}
\end{breakbox}
\section{FLTK を用いた GUI 構築}
本節で説明するサンプルは、GUI (Graphical User Interface) を用いた
立体ビューワーである。ウィンドウの章でも少し触れたが、FK システムは
内部で FLTK と呼ばれる GUI ツールキットを用いている。ここでは、その
FLTK を用いて GUI を作成し、FK システムと併用するサンプルを紹介する。
なお、本書では FLTK の詳細な解説は掲載しないが、FLTK の解説は
\verb+http://www.fltk.org/+ という URL に詳しく記載されている。

ボールのサンプルと同じく、プログラム行のそれぞれの意味はコメントで
記述しているので、全体の流れを通して幾つかわかりにくい部分を記述する。
\begin{itemize}

 \item 最初に include するファイルが FK/FK だけでなく、FLTK 用の
	様々なファイルが多くある。FLTK を用いる場合は、このように適宜
	必要なファイルを include しなければならない。

 \item 10 行目から始まる GUISet クラスは、GUI の部品を管理するための
	ものである。このクラスのコンストラクタ (41 〜 115 行目) 内で
	様々な部品を作成するようにしてあるので、GUISet オブジェクトの
	宣言 (264 行目) をするだけでコンストラクタが呼び出され、GUI が
	作成されるようになっている。

 \item 122 行目からある getFileName メンバ関数は、Fl\_File\_Chooser クラスを
	用いてファイル名を取得するための関数である。まず 128、129 行目で
	ファイル取得用ダイアログを生成し、131 行目の while 文でダイアログが
	終了されるまで処理を行う。もしダイアログ中でキャンセルされていた
	場合は、135 行目の fCharP に NULL が入るため、136 行目の if 文に
	該当する。そうでない場合は、143 行目まで進んで文字列(ファイル名)を
	返す。

 \item 161 行目では数学関数の pow を用いている。pow(a, b) は a の b 乗を
	返す関数なので、scaleRoller の値が実際には
	2 であれば \(100 (= 10^2)\) を、
	3 であれば \(1000 (= 10^3)\) を、
	-1 であれば \(0.1 (= 10^{-1})\) を返す。

 \item 314、315 行目では照明を Y 軸中心に少しだけ回転させている。
	形状を回転させずに立体感を出す方法として、このように照明を回転
	させることも有効な手段である。

 \item 318、319 行目で、GUI のスライダーやローラーで設定された
	値を実際に反映させている。

 \item 325 行目にて、fl\_color\_chooser によってカラー設定ウィンドウを
	呼び出している。この関数の 2 〜 4 番目の引数は実は参照呼び出しに
	なっている。従って、colorR, colorG, colorB の3変数は色設定の
	後に値がちゃんと反映されている。

\end{itemize}
\begin{breakbox}
\begin{verbatim}
  1: #include <FK/FK.h>
  2: #include <FL/Fl_Value_Slider.h>
  3: #include <FL/Fl_Roller.h>
  4: #include <FL/Fl_Group.h>
  5: #include <FL/Fl_Check_Button.h>
  6: #include <FL/Fl_Color_Chooser.h>
  7: #include <FL/Fl_File_Chooser.h>
  8: #include <FL/fl_ask.h>
  9: 
 10: class GUISet {
 11: private:
 12: 
 13:     Fl_Value_Slider *headSlider;             // ヘディング角用スライダー
 14:     Fl_Value_Slider *pitchSlider;            // ピッチ各用スライダー
 15:     Fl_Roller       *scaleRoller;            // スケーリング用ローラー
 16: 
 17:     Fl_Group        *materialGroup;          // ラジオボタンのグループ
 18:     Fl_Check_Button *ambientButton;          // Ambient 用ボタン
 19:     Fl_Check_Button *diffuseButton;          // Diffuse 用ボタン
 20:     Fl_Check_Button *specularButton;         // Specular 用ボタン
 21:     Fl_Check_Button *emissionButton;         // Emission 用ボタン
 22:     Fl_Button       *colorChooser;           // カラー設定呼び出しボタン
 23: 
 24:     Fl_Button       *fileOpenButton;         // ファイル選択呼び出しボタン
 25:     Fl_Button       *exitButton;             // 終了ボタン
 26: 
 27: public:
 28:     GUISet(void);                            // コンストラクタ
 29:     ~GUISet();                               // デストラクタ
 30: 
 31:     string          getFileName(void);       // ファイル名取得
 32:     double          getHead(void);           // ヘディング角取得
 33:     double          getPitch(void);          // ピッチ角取得
 34:     double          getScale(void);          // スケール取得
 35:     int             materialSelect(void);    // マテリアル種類取得
 36:     bool            toggleColorChooser(void);// カラー設定呼出判定
 37:     bool            toggleFileOpen(void);    // ファイル取得呼出判定
 38:     bool            toggleExit(void);        // 終了判定
 39: };
 40: 
 41: GUISet::GUISet(void)
 42: {
 43:     // ヘディング角用スライダー各種設定
 44:     headSlider = new Fl_Value_Slider(130, 330, 180, 20, "Head Angle");
 45:     headSlider->type(FL_HOR_NICE_SLIDER);  // ナイスなスライダー
 46:     headSlider->minimum(-FK_PI);           // 最小値は -3.14
 47:     headSlider->maximum(FK_PI);            // 最高値は 3.14
 48:     headSlider->value(0.0);                // 初期値は 0
 49:     headSlider->labelsize(12);             // ラベル文字のサイズを 12pt に
 50:     headSlider->textsize(12);              // カウンタのサイズも 12 に
 51: 
 52:     // ピッチ角用スライダー各種設定
 53:     pitchSlider = new Fl_Value_Slider(130, 370, 180, 20, "Pitch Angle");
 54:     pitchSlider->type(FL_HOR_NICE_SLIDER);
 55:     pitchSlider->minimum(-FK_PI);
 56:     pitchSlider->maximum(FK_PI);
 57:     pitchSlider->value(0.0);
 58:     pitchSlider->labelsize(12);
 59:     pitchSlider->textsize(12);
 60: 
 61:     // スケーリング用ローラー各種設定
 62:     scaleRoller = new Fl_Roller(160, 410, 120, 20, "Scale");
 63:     scaleRoller->type(FL_HORIZONTAL);       // ローラーは横向き
 64:     scaleRoller->minimum(-100.0);
 65:     scaleRoller->maximum(100.0);
 66:     scaleRoller->value(0.0);
 67:     scaleRoller->labelsize(12);
 68: 
 69:     // 左側のマテリアル関係のボタンをグループ化しておく。
 70:     materialGroup = new Fl_Group(10, 320, 100, 170);
 71:     materialGroup->box(FL_THIN_UP_FRAME);   // ちょっと盛り上げる
 72: 
 73:     // Ambient 用ラジオボタン
 74:     ambientButton = new Fl_Check_Button(10, 320, 100, 30, "Ambient");
 75:     ambientButton->type(FL_RADIO_BUTTON);
 76:     ambientButton->down_box(FL_DIAMOND_DOWN_BOX);
 77: 
 78:     // Diffuse 用ラジオボタン
 79:     diffuseButton = new Fl_Check_Button(10, 350, 100, 30, "Diffuse");
 80:     diffuseButton->type(FL_RADIO_BUTTON);
 81:     diffuseButton->down_box(FL_DIAMOND_DOWN_BOX);
 82: 
 83:     // Specular 用ラジオボタン
 84:     specularButton = new Fl_Check_Button(10, 380, 100, 30, "Specular");
 85:     specularButton->type(FL_RADIO_BUTTON);
 86:     specularButton->down_box(FL_DIAMOND_DOWN_BOX);
 87: 
 88:     // Emission 用ラジオボタン
 89:     emissionButton = new Fl_Check_Button(10, 410, 100, 30, "Emission");
 90:     emissionButton->type(FL_RADIO_BUTTON);
 91:     emissionButton->down_box(FL_DIAMOND_DOWN_BOX);
 92: 
 93:     // カラー設定呼出ボタン
 94:     colorChooser = new Fl_Button(20, 450, 80, 30, "ColorChange");
 95:     colorChooser->type(0);        // 普通のボタンとして扱う
 96:     colorChooser->labelsize(12);
 97: 
 98:     // MaterialGroup のグループの終了
 99:     materialGroup->end();
100: 
101:     // とりあえず Ambient にチェックを入れる。
102:     ambientButton->value(1);
103: 
104:     // ファイル取得呼出ボタン
105:     fileOpenButton = new Fl_Button(120, 460, 90, 30, "File Open");
106:     fileOpenButton->type(0);
107:     fileOpenButton->labelsize(12);
108: 
109:     // 終了ボタン
110:     exitButton = new Fl_Button(220, 460, 90, 30, "Exit");
111:     exitButton->type(0);
112:     exitButton->labelsize(12);
113: 
114:     return;
115: }
116: 
117: GUISet::~GUISet()
118: {
119:     return;
120: }
121: 
122: string GUISet::getFileName(void)
123: {
124:     Fl_File_Chooser       *fc;
125:     const char            *fCharP;
126:     string                fileName;
127: 
128:     fc = new Fl_File_Chooser(".", "*.wrl", Fl_File_Chooser::SINGLE,
129:                              "VRML File Select");
130:     fc->show();
131:     while(fc->visible()) {
132:         Fl::wait();
133:     }
134: 
135:     fCharP = fc->value(1);
136:     if(fCharP == (const char *)NULL) {
137:         delete fc;
138:         return fileName;
139:     }
140: 
141:     fileName = fCharP;
142:     delete fc;
143:     return fileName;
144: }
145: 
146: 
147: double GUISet::getHead(void)
148: {
149:     return headSlider->value();
150: }
151: 
152: double GUISet::getPitch(void)
153: {
154:     return pitchSlider->value();
155: }
156: 
157: double GUISet::getScale(void)
158: {
159:     // 10 の (scaleRoller->value()) 乗 を返す。
160: 
161:     return pow(10.0, scaleRoller->value());
162: }
163: 
164: int GUISet::materialSelect(void)
165: {
166:     // どのラジオボタンが選択されているかを取得
167: 
168:     if(ambientButton->value() == 1) return 1;
169:     if(diffuseButton->value() == 1) return 2;
170:     if(specularButton->value() == 1) return 3;
171:     if(emissionButton->value() == 1) return 4;
172: 
173:     return -1;
174: }
175: 
176: bool GUISet::toggleColorChooser(void)
177: {
178:     if(colorChooser->value() == 1) return true;
179:     return false;
180: }
181: 
182: bool GUISet::toggleFileOpen(void)
183: {
184:     if(fileOpenButton->value() == 1) {
185:         fileOpenButton->value(0);
186:         return true;
187:     }
188:     return false;
189: }
190: 
191: bool GUISet::toggleExit(void)
192: {
193:     if(exitButton->value() == 1) return true;
194:     return false;
195: }
196: 
197: void getMaterial(int index, fk_Material *mat, double *r, double *g, double *b)
198: {
199:     // Index によってマテリアルの各種属性を (R, G, B) に代入
200: 
201:     switch(index) {
202:       case 1:
203:         *r = mat->getAmbient()->getR();
204:         *g = mat->getAmbient()->getG();
205:         *b = mat->getAmbient()->getB();
206:         break;
207:       case 2:
208:         *r = mat->getDiffuse()->getR();
209:         *g = mat->getDiffuse()->getG();
210:         *b = mat->getDiffuse()->getB();
211:         break;
212:       case 3:
213:         *r = mat->getSpecular()->getR();
214:         *g = mat->getSpecular()->getG();
215:         *b = mat->getSpecular()->getB();
216:         break;
217:       case 4:
218:         *r = mat->getEmission()->getR();
219:         *g = mat->getEmission()->getG();
220:         *b = mat->getEmission()->getB();
221:         break;
222:       default:
223:         break;
224:     }
225:     return;
226: }
227: 
228: void setMaterial(int index, fk_Material *mat, double r, double g, double b)
229: {
230:     // Index によって (R, G, B) を各種マテリアルに設定
231: 
232:     switch(index) {
233:       case 1:
234:         mat->setAmbient(r, g, b);
235:         break;
236:       case 2:
237:         mat->setDiffuse(r, g, b);
238:         break;
239:       case 3:
240:         mat->setSpecular(r, g, b);
241:         break;
242:       case 4:
243:         mat->setEmission(r, g, b);
244:         break;
245:       default:
246:         break;
247:     }
248: 
249:     return;
250: }
251: 
252: int main(int argc, char *argv[])
253: {
254:     double          colorR, colorG, colorB;
255:     fk_Material     material;
256:     fk_IndexFaceSet shape;
257:     fk_Light        light;
258:     fk_Model        shapeModel, lightModel[2], camera;
259:     fk_Scene        scene;
260:     string          fileName;
261: 
262:     Fl_Window       mainWindow(320, 500, "VRML Viewer");
263:     fk_Window       viewWin(10, 10, 300, 300);
264:     GUISet          gui;
265: 
266:     mainWindow.end();
267: 
268:     fk_Material::initDefault();
269: 
270:     // 光源の設定。今回は2つの平行光源
271:     lightModel[0].setShape(&light);
272:     lightModel[1].setShape(&light);
273:     lightModel[0].setMaterial(White);
274:     lightModel[1].setMaterial(White);
275:     lightModel[0].glFocus(-1.0, -1.0, 0.0);
276:     lightModel[1].glFocus(1.0, -1.0, 0.0);
277: 
278:     // ソリッドモデルの初期マテリアルに Yellow を用いる。
279:     material = Yellow;
280:     shapeModel.setShape(&shape);
281:     shapeModel.setMaterial(material);
282: 
283:     // 視点の設定
284:     camera.glTranslate(0.0, 100.0, 1000.0);
285:     camera.glFocus(0.0, 0.0, 0.0);
286:     camera.glUpvec(0.0, 1.0, 0.0);
287: 
288:     // ディスプレイリストへソリッド、光源、視点を登録
289:     scene.entryModel(&shapeModel);
290:     scene.entryModel(&lightModel[0]);
291:     scene.entryModel(&lightModel[1]);
292:     scene.entryCamera(&camera);
293: 
294:     // ViewWin にディスプレイリストを登録
295:     viewWin.setScene(&scene);
296: 
297:     mainWindow.show();
298:     viewWin.show();
299: 
300:     while(true) {
301: 
302:         if(mainWindow.visible() == 0) {
303:             if(Fl::wait() == 0) {
304:                 break;
305:             } else {
306:                 continue;
307:             }
308:         }
309:         if(viewWin.drawWindow() == 0) break;
310:         if(Fl::check() == 0) break;
311:         if(viewWin.winOpenStatus() == false) continue;
312: 
313:         // ライトを Y 軸中心に回転
314:         lightModel[0].glRotateWithVec(0.0, 0.0, 0.0, fk_Y, FK_PI/100.0);
315:         lightModel[1].glRotateWithVec(0.0, 0.0, 0.0, fk_Y, FK_PI/100.0);
316: 
317:         // スライダーやローラーに従ってソリッドモデルの姿勢と大きさを決定
318:         shapeModel.glAngle(gui.getHead(), gui.getPitch(), 0.0);
319:         shapeModel.setScale(gui.getScale());
320: 
321:         if(gui.toggleColorChooser() == true) {
322:             // カラー設定モード
323:             getMaterial(gui.materialSelect(), &material,
324:                         &colorR, &colorG, &colorB);
325:             fl_color_chooser("COLOR SET", colorR, colorG, colorB);
326:             setMaterial(gui.materialSelect(), &material,
327:                         colorR, colorG, colorB);
328:             shapeModel.setMaterial(material);
329:         }
330: 
331:         if(gui.toggleFileOpen() == true) {
332:             // ファイル取得モード
333:             fileName = gui.getFileName();
334:             if(fileName != "") {
335:                 // キャンセルを押されたのでないなら
336:                 if(shape.readVRMLFile(fileName, true, false) == false) {
337:                     // VRML ファイルではなかったら
338:                     fl_alert(" is not VRML2.0 file.", fileName.c_str());
339:                 } else {
340:                     shapeModel.setMaterialMode(FK_PARENT_MODE);
341:                 }
342:             }
343:         }
344: 
345:         if(gui.toggleExit() == true) {
346:             // 終了ボタンが押されたら while ループを抜ける。
347:             break;
348:         }
349:     }
350: 
351:     return 0;
352: }
\end{verbatim}
\end{breakbox}
\section{マルチウィンドウ}
次のサンプルは、マルチウィンドウを用いて複数の視点を同時に表示する
プログラムである。このプログラムは、同一シーンで異なる3つの
ウィンドウが表示される。それぞれの視点は左から順に、車の運転者視点、
建物から見た視点、車を斜め後ろから見下ろした鳥瞰視点を表して
いる。

このプログラムでは、116 〜 126 行目で3つのウィンドウを同時に
処理している以外は、特に目新しい部分はない。このように、特別な
処理を施す必要なくマルチウィンドウプログラムを作成することが
可能である。
\\
\begin{breakbox}
\begin{verbatim}
  1: #include <FK/FK.h>
  2: 
  3: const double    BUILDWIDTH  = 25.0;     // 建物幅の基本単位
  4: const double    SPEED       = 2.0;      // 車のスピード
  5: const double    CIRCUITX    = 150.0;    // コースの X 方向幅
  6: const double    CIRCUITY    = 250.0;    // コースの Y 方向幅
  7: const double    EPS         = 0.001;    // 誤差判定用数値
  8: 
  9: class Car {
 10: private:
 11:     fk_Model    carModel;       // 車全体モデル
 12:     fk_Model    bodyModel;      // 車体モデル
 13:     fk_Model    tireModel[4];   // 各タイヤモデル
 14:     fk_Model    driverModel[2]; // 運転者モデル
 15:     fk_Model    birdModel;      // 鳥瞰視点モデル
 16: 
 17:     fk_Block    body;           // 車体形状
 18:     fk_Circle   tire;           // タイヤ形状
 19:     fk_Sphere   driver;         // 運転者形状
 20: 
 21: public:
 22:     Car(void) {     // コンストラクタ
 23:         init();
 24:     }
 25: 
 26:     void        init(void);
 27:     void        entryScene(fk_Scene *, bool);   
 28:     fk_Vector   getCarPosition(void);
 29:     fk_Model *  getBirdModel(void);
 30:     void        forward(void);
 31:     void        rotate(fk_Model *, fk_Vector, fk_Vector);
 32: };
 33: 
 34: class World {
 35: private:
 36:     fk_Model    buildModel[6], groundModel, lightModel[2];
 37:     fk_Block    buildShape, groundShape;
 38:     fk_Light    lightShape;
 39: 
 40:     void        defLight(int, double, double, double);
 41:     void        makeBuild(int, double, double, double, fk_Material *);
 42: 
 43: public:
 44:     World(void) {
 45:         init();
 46:     }
 47: 
 48:     void        init(void);
 49:     void        entryScene(fk_Scene *, bool);
 50: };
 51: 
 52: int main(int argc, char *argv[])
 53: {
 54:     Car             carObj;
 55:     World           worldObj;
 56:     Fl_Window       mainWindow(940, 320, "FK TEST");
 57:     fk_Scene        carViewScene, buildViewScene, birdViewScene;
 58:     fk_Window       carViewWindow(10, 10, 300, 300);
 59:     fk_Window       buildViewWindow(320, 10, 300, 300);
 60:     fk_Window       birdViewWindow(630, 10, 300, 300);
 61:     fk_Color        bgColor(0.2, 0.7, 1.0);
 62: 
 63:     fk_Model        buildViewModel, birdViewModel;
 64: 
 65:     mainWindow.end();
 66:     fk_Material::initDefault();
 67: 
 68:     carObj.init();
 69:     worldObj.init();
 70: 
 71: 
 72:     // 各ウィンドウにバックグラウンドカラー設定
 73:     carViewScene.setBGColor(bgColor);
 74:     buildViewScene.setBGColor(bgColor);
 75:     birdViewScene.setBGColor(bgColor);
 76: 
 77: 
 78:     // 各モデルをディスプレイリストに登録
 79:     worldObj.entryScene(&carViewScene, false);
 80:     worldObj.entryScene(&buildViewScene, true);
 81:     worldObj.entryScene(&birdViewScene, false);
 82: 
 83:     carObj.entryScene(&carViewScene, false);
 84:     carObj.entryScene(&buildViewScene, true);
 85:     carObj.entryScene(&birdViewScene, true);
 86: 
 87:     // 建物ウィンドウの視点設定
 88:     buildViewModel.glMoveTo(-250.0, 100.0, 100.0);
 89:     buildViewModel.glFocus(carObj.getCarPosition());
 90:     buildViewModel.glUpvec(0.0, 0.0, 1.0);
 91:     buildViewScene.entryCamera(&buildViewModel);
 92: 
 93:     // 鳥瞰ウィンドウの視点設定
 94:     birdViewScene.entryCamera(carObj.getBirdModel());
 95: 
 96:     // ウィンドウへディスプレイリストを登録
 97:     carViewWindow.setScene(&carViewScene);
 98:     buildViewWindow.setScene(&buildViewScene);
 99:     birdViewWindow.setScene(&birdViewScene);
100: 
101:     mainWindow.show();
102:     carViewWindow.show();
103:     buildViewWindow.show();
104:     birdViewWindow.show();
105: 
106:     while(true) {
107: 
108:         if(mainWindow.visible() == 0) {
109:             if(Fl::wait() == 0) {
110:                 break;
111:             } else {
112:                 continue;
113:             }
114:         }
115: 
116:         if(carViewWindow.drawWindow() == 0 ||
117:            buildViewWindow.drawWindow() == 0 ||
118:            birdViewWindow.drawWindow() == 0) break;
119: 
120:         if(Fl::check() == 0) break;
121: 
122:         if(carViewWindow.winOpenStatus() == false ||
123:            buildViewWindow.winOpenStatus() == false ||
124:            birdViewWindow.winOpenStatus() == false) {
125:             continue;
126:         }     
127: 
128:         carObj.forward();
129:         buildViewModel.glFocus(carObj.getCarPosition());
130:         buildViewModel.glUpvec(0.0, 0.0, 1.0);
131:     }
132:     
133:     return 0;
134: }
135: 
136: void Car::init(void)
137: {
138:     int     i;
139: 
140:     body.setSize(7.0, 6.0, 20.0);
141:     tire.setRadius(2.0);
142:     tire.setDivide(2);
143:     driver.setRadius(2.0);
144:     driver.setDivide(2);
145: 
146:     bodyModel.setShape(&body);
147:     bodyModel.glMoveTo(0.0, 5.0, 0.0);
148:     bodyModel.setMaterial(Yellow);
149:     bodyModel.setParent(&carModel);
150: 
151: 
152:     tireModel[0].glMoveTo(-4.0, 1.0, -8.0);
153:     tireModel[0].glVec(1.0, 0.0, 0.0);
154:     tireModel[1].glMoveTo(4.0, 1.0, -8.0);
155:     tireModel[1].glVec(-1.0, 0.0, 0.0);
156:     tireModel[2].glMoveTo(-4.0, 1.0, 8.0);
157:     tireModel[2].glVec(1.0, 0.0, 0.0);
158:     tireModel[3].glMoveTo(4.0, 1.0, 8.0);
159:     tireModel[3].glVec(-1.0, 0.0, 0.0);
160: 
161:     for(i = 0; i < 4; i++) {
162:         tireModel[i].setShape(&tire);
163:         tireModel[i].setMaterial(Gray2);
164:         tireModel[i].setParent(&carModel);
165:     }
166: 
167:     driverModel[0].setShape(&driver);
168:     driverModel[1].setShape(&driver);
169:     driverModel[0].glMoveTo(-2.0, 10.0, 0.0);
170:     driverModel[1].glMoveTo(2.0, 10.0, 0.0);
171:     driverModel[0].setMaterial(Cream);
172:     driverModel[1].setMaterial(Cream);
173:     driverModel[0].setSmoothMode(true);
174:     driverModel[1].setSmoothMode(true);
175:     driverModel[0].setParent(&carModel);
176:     driverModel[1].setParent(&carModel);
177: 
178:     birdModel.glMoveTo(0.0, 100.0, 200.0);
179:     birdModel.glFocus(0.0, 5.0, 0.0);
180:     birdModel.glUpvec(0.0, 1.0, 0.0);
181:     birdModel.setParent(&carModel);
182: 
183:     carModel.glMoveTo(CIRCUITX, CIRCUITY, 0.0);
184:     carModel.glVec(0.0, -1.0, 0.0);
185:     carModel.glUpvec(0.0, 0.0, 1.0);
186: 
187:     return;
188: }
189: 
190: void Car::entryScene(fk_Scene *scene, bool viewFlag)
191: {
192:     int     i;
193: 
194:     scene->entryModel(&bodyModel);
195: 
196:     for(i = 0; i < 4; i++) {
197:         scene->entryModel(&tireModel[i]);
198:     }
199: 
200:     scene->entryModel(&driverModel[0]);
201:     if(viewFlag == true) {
202:         scene->entryModel(&driverModel[1]);
203:     } else {
204:         scene->entryCamera(&driverModel[1]);
205:     }
206: 
207:     return;
208: }
209: 
210: fk_Vector Car::getCarPosition(void)
211: {
212:     return carModel.getPosition();
213: }
214: 
215: fk_Model * Car::getBirdModel(void)
216: {
217:     return &birdModel;
218: }
219: 
220: void Car::forward(void)
221: {
222:     fk_Vector   carPosition, carVelocity;
223:     fk_Vector   Xplus(1.0, 0.0, 0.0), Xminus(-1.0, 0.0, 0.0);
224:     fk_Vector   Yplus(0.0, 1.0, 0.0), Yminus(0.0, -1.0, 0.0);
225:     double      X = CIRCUITX;
226:     double      Y = CIRCUITY;
227: 
228:     carPosition = carModel.getPosition();
229:     carVelocity = carModel.getVec();
230:     carModel.loTranslate(0.0, 0.0, -SPEED); // 前進
231: 
232:     // サーキットの外にでた場合、回転する。
233:     if(carPosition.x > X) {
234:         rotate(&carModel, carVelocity, Xplus);
235:     }
236:     if(carPosition.x < -X) {
237:         rotate(&carModel, carVelocity, Xminus);
238:     }
239:     if(carPosition.y > Y) {
240:         rotate(&carModel, carVelocity, Yplus);
241:     }
242:     if(carPosition.y < -Y) {
243:         rotate(&carModel, carVelocity, Yminus);
244:     }
245: 
246:     return;
247: }
248: 
249: void Car::rotate(fk_Model *model, fk_Vector velocity, fk_Vector orgVec)
250: {
251:     // velocity と orgVec の内積値が正、つまり角度が 90 度以内の場合回転
252:     if(velocity * orgVec > EPS) {
253:         model->loAngle(FK_PI/100.0, 0.0, 0.0);
254:     }
255:     return;
256: }
257: 
258: void World::defLight(int lightID, double x, double y, double z)
259: {
260:     lightModel[lightID].setShape(&lightShape);
261:     lightModel[lightID].setMaterial(White);
262:     lightModel[lightID].glTranslate(0.0, 0.0, 0.0);
263:     lightModel[lightID].glFocus(x, y, z);
264: 
265:     return;
266: }
267: 
268: void World::makeBuild(int buildID, double x, double y,
269:                       double heightScale, fk_Material *buildMat)
270: {
271:     buildModel[buildID].setShape(&buildShape);
272:     buildModel[buildID].setScale(heightScale, fk_Z);
273:     buildModel[buildID].glMoveTo(x, y, (BUILDWIDTH * heightScale)/2.0);
274:     buildModel[buildID].setMaterial(*buildMat);
275: 
276:     return;
277: }
278: 
279: void World::init(void)
280: {
281:     // 照明の設定
282:     defLight(0, 1.0, 1.0, -1.0);
283:     defLight(1, -1.0, -1.0, -1.0);
284: 
285:     // 建物の設定
286:     buildShape.setSize(BUILDWIDTH, BUILDWIDTH, BUILDWIDTH);
287:     makeBuild(0, -250.0, 100.0, 5.0, &Red);
288:     makeBuild(1, -150.0, 400.0, 2.0, &DimYellow);
289:     makeBuild(2, 50.0, 250.0, 4.0, &Blue); 
290:     makeBuild(3, 300.0, 200.0, 3.0, &Gray1); 
291:     makeBuild(4, 250.0, -250.0, 0.5, &Green);
292:     makeBuild(5, -50.0, -350.0, 6.0, &Orange);
293: 
294:     // 地面の設定
295:     groundShape.setSize(1000, 1000, 2.0);
296:     groundModel.setShape(&groundShape);
297:     groundModel.glTranslate(0.0, 0.0, -1.0);
298:     groundModel.setMaterial(Brown);
299: 
300:     return;
301: }
302: 
303: void World::entryScene(fk_Scene *scene, bool buildFlag)
304: {
305:     int     i;
306: 
307:     scene->entryModel(&groundModel);
308: 
309:     for(i = 0; i < 2; i++) {
310:         scene->entryModel(&lightModel[i]);
311:     }
312: 
313:     for(i = 0; i < 6; i++) {
314:         scene->entryModel(&buildModel[i]);
315:     }
316: 
317:     if(buildFlag == true) scene->removeModel(&buildModel[0]);
318:     return;
319: }
\end{verbatim}
\end{breakbox}
\section{形状の簡易表示とアニメーション} \label{sec:sampleviewer}
次のサンプルは、fk\_ShapeViewer クラスの典型的な利用法を示したものである。
\begin{itemize}
 \item まず、13 〜 19 行目で 11 行 11 列の行列として並んでいる状態の
	座標を計算している。その際、\(z = \dfrac{x^2 - y^2}{10}\)
	として \(z\) 成分は計算されている。

 \item 次に、22 〜 29 行目でインデックスフェースセットを表す
	配列を作成している。インデックスフェースセットに関しては、
	第 \ref{subsec:solidGen1} 節を参照すること。

 \item 32 行目で実際に形状を生成する。この部分の解説も、
	第 \ref{subsec:solidGen1} 節に記述がある。

 \item 35 行目では、作成した形状を描画形状として登録している。ID には
	0 が選択されているが、特にどのような整数値でも構わない。

 \item 38,39 行目では、表裏の両面及び稜線や頂点を描画するように設定している。

 \item 42 行目では while ループ中で描画が行われるよう記述されている。
	これにより、43 〜 56 行目が実行される度に描画処理が行われるようになる。

 \item 46,47 行目では、アニメーションの際の頂点移動量が計算されている。
	移動は \(z\) 方向のみ行われ、移動量は
	\(\sin\frac{counter + 10j}{5\pi}\)である。counter はループの度に
	56 行目で 10 ずつ追加されているので、描画の度に移動量が異なる
	ことになる。

 \item 50 行目で初期位置に移動量が足され、53 行目で実際に各頂点を移動している。
\end{itemize}

\begin{breakbox}
\begin{verbatim}
 1: #include <FK/FK.h>
 2: 
 3: int main()
 4: {
 5:     fk_ShapeViewer   viewer(300, 360);
 6:     fk_IndexFaceSet  shape;
 7:     fk_Vector        pos[121], moveVec, movePos;
 8:     int              IFSet[4*100];
 9:     int              i, j, counter;
10:     double           x, y;
11: 
12:     // 各頂点位置の設定
13:     for(i = 0; i <= 10; i++) {
14:         for(j = 0; j <= 10; j++) {
15:             x = double(i - 5);    
16:             y = double(j - 5);
17:             pos[i*11 + j].set(x, y, (x*x - y*y)/10.0);
18:         }
19:     }
20: 
21:     // インデックスフェースセットの生成
22:     for(i = 0; i < 10; i++) {
23:         for(j = 0; j < 10; j++) {
24:             IFSet[(i*10 + j)*4 + 0] = i*11 + j;
25:             IFSet[(i*10 + j)*4 + 1] = (i+1)*11 + j;
26:             IFSet[(i*10 + j)*4 + 2] = (i+1)*11 + j+1;
27:             IFSet[(i*10 + j)*4 + 3] = i*11 + j+1;
28:         }
29:     }
30: 
31:     // 形状の生成
32:     shape.makeIFSet(100, 4, IFSet, 121, pos);
33: 
34:     // fk_ShapeViewer へ形状を設定
35:     viewer.setShape(0, &shape);
36: 
37:     // 各種設定
38:     viewer.setDrawMode(FK_FRONTBACK_POLYMODE | FK_LINEMODE);
39:     viewer.setScale(10.0);
40: 
41:     counter = 0;
42:     while(viewer.draw() == true) {
43:         for(i = 0; i <= 10; i++) {
44:             for(j = 0; j <= 10; j++) {
45:                 // 各頂点の移動量計算
46:                 moveVec.set(0.0, 0.0,
47:                             sin(double(counter+j*40)*0.05/FK_PI));
48: 
49:                 // 各頂点を移動場所を計算
50:                 movePos = moveVec + pos[i*11 + j];
51: 
52:                 // 各頂点を実際に移動
53:                 shape.moveVPosition(i*11 + j, movePos);
54:             }
55:         }
56:         counter += 10;
57:     }
58: 
59:     return 0;
60: }
\end{verbatim}
\end{breakbox}
\section{パーティクルアニメーション}
パーティクルアニメーションとは、粒子の移動によって気流や水流などを
表現する手法である。FK システムでは、パーティクルアニメーションを作成する
ためのクラスとして fk\_Particle 及び fk\_ParticleSet クラスを用意している。
これらの細かな仕様に関しては\ref{subsec:particle} 節に記述してあるが、
ここではサンプルプログラムを用いておおまかな利用法を説明する。

fk\_ParticleSet クラスは、これまで紹介したクラスとはやや利用手法が
異なっている。まず、fk\_ParticleSet クラスを継承したクラスを作成し、
いくつかの仮想関数に対して再定義を行う。あとは、getShape() 関数を
利用して fk\_Model に形状として設定したり、fk\_ShapeViewer を利用して
描画することができる。

ここでは、サンプルとして円柱の周囲を流れる水流のシミュレーションの様子を
描画するプログラムを紹介する。
\begin{itemize}
 \item 8 〜 15 行目は、fk\_ParticleSet クラスを継承した「MyParticle」という
	クラスを定義している。定義の際、仮想関数である genMethod()、
	allMethod()、indivMethod() の各関数の宣言を必ず行う。

 \item 19 〜 29 行目は MyParticle クラスのコンストラクタである。ここで、
	パーティクルの初期設定を行う。

 \item 21 行目の setMaxSize() 関数は fk\_ParticleSet クラスのメンバ関数で
	パーティクル個数の最大値を設定する。もしパーティクルの個数が
	この値と等しくなったとき、newParticle() メソッドを呼んでも
	パーティクルは新たに生成されなくなる。

 \item 23,24 行目はそれぞれ個別処理、全体処理に対するモード設定である。
	ここで true に設定しない場合、allMethod() や indivMethod() の
	記述は無視される。

 \item 27 行目は、パーティクル全体の色パレットを設定しているものである。
	ここでは緑色を ID 1 として登録している。

 \item 33 〜 40 行目では、新たにパーティクルが生成された際の処理を記述する。
	引数の p に新パーティクルのオブジェクトが入っており、これに対して
	様々な設定を行う。36 行目では初期位置を、38 行目では色 ID を設定
	している。

 \item 43 〜 54 行目では、allMethod() メンバ関数を再定義している。
	allMethod() 関数には、パーティクル集合全体に対しての処理を記述する。
	ここではランダムにパーティクルの生成を行っているだけであるが、
	パーティクル全体に対して一括の処理を記述することもできる。

 \item 57 〜 82 行目では、indivMethod() メンバ関数を再定義している。
	indivMethod 関数には、個別のパーティクルに対する処理を記述する。

 \item indivMethod() 中では、65 〜 74 行目で速度ベクトルの入力を行っている。
	中心が原点で、\(z\) 軸に平行な半径 \(R\) の円柱の周囲を
	速度 \((-V_x, 0, 0)\) の水流が流れているとする。このとき、各地点
	\((x, y, z)\) での水流を表す偏微分方程式は以下のようなものである。
	\[
		\frac{\partial}{\partial t}\bP =
		\bV + \frac{R^3}{2}
		\left(\frac{\bV}{r^3} -
		\frac{3 \bV \cdot \bP}{r^5} \bP \right)
	\]
	ただし、
	\[
		\bV = (-V_x, 0, 0), \qquad
		\bP = (x, y, 0), \qquad r = |\bP|
	\]
	今回は、\(V_x = 0.2\)(60行目の「water」変数)、
	\(R = 15\)(61行目の「R」変数) として算出している。この式から、
	各パーティクルの速度ベクトルを算出し、74 行目で設定している。

 \item 77 〜 79 行目でパーティクル削除判定を行っている。
	パーティクルが \(x = -50\) よりも左へ流れてしまった場合には
	78 行目で削除を行っている。

 \item 93 行目では、パーティクル集合を fk\_ShapeViewer で表示するために
	getShape() 関数を用いている。

 \item 98 行目にあるように、handle() メンバ関数を用いることで
	パーティクル全体に 1 ステップ処理が行われる。その際には、設定した
	速度や加速度にしたがって各パーティクルが移動する。特に再設定
	しない限り、加速度は処理終了後も保存される。

\end{itemize}

\begin{breakbox}
\begin{verbatim}
 1: #include <FK/FK.h>
 2: 
 3: double myRandom(void)
 4: {
 5:     return double(rand())/double(RAND_MAX);
 6: }
 7:  
 8: class MyParticle: public fk_ParticleSet {
 9: protected:
10:     void        genMethod(fk_Particle *);
11:     void        allMethod(void);
12:     void        indivMethod(fk_Particle *);
13: public:
14:     MyParticle(void);
15: };
16:  
17: // コンストラクタ。
18: // ここに、様々な設定を記述しておく。
19: MyParticle::MyParticle(void)
20: {
21:     setMaxSize(1000);   // パーティクルの最大数設定。
22:     srand(time(0));     // 乱数の初期化。
23:     setIndivMode(true); // 個別処理 (indivMethod) を ON にしておく。
24:     setAllMode(true);   // 全体処理 (allMethod) を ON にしておく。
25:  
26:     // パレットに色を設定しておく。
27:     setColorPalette(1, 0.0, 1.0, 0.6);
28:     return;
29: }
30:  
31: // ここにパーティクル生成時の処理を記述する。
32: // p に新たなパーティクル要素が入っている。
33: void MyParticle::genMethod(fk_Particle *p)
34: {
35:     // 生成時の位置を設定
36:     p->setPosition(50.0, myRandom()*50.0 - 25.0, myRandom()*50.0 - 25.0);
37:     // パーティクルの色 ID を設定
38:     p->setColorID(1);
39:     return;
40: }
41:  
42: // ここに毎ループ時の全体処理処理を記述する
43: void MyParticle::allMethod(void)
44: {
45:     for(int i = 0; i < 5; i++) {
46:         if(myRandom() < 0.3) {
47:             // 新たなパーティクルを生成。
48:             // 生成時に genMethod() が呼ばれる。
49:             newParticle();
50:         }
51:     }
52:  
53:     return;
54: }
55:  
56: // ここに毎ループ時の各パーティクルへの処理を記述する。
57: void MyParticle::indivMethod(fk_Particle *p)
58: {
59:     fk_Vector       pos, vec, tmp1, tmp2;
60:     fk_Vector       water(-0.2, 0.0, 0.0);
61:     double          R = 15.0;
62:     double          r;
63:  
64:     // パーティクルの位置を取得。
65:     pos = p->getPosition();
66:     pos.z = 0.0;
67:     r = pos.dist(); // |p| を r に代入。
68:  
69:     // パーティクルの速度ベクトルを計算
70:     tmp1 = water/(r*r*r);
71:     tmp2 = ((3.0 * (water * pos))/(r*r*r*r*r)) * pos;
72:     vec = water + ((R*R*R)/2.0) * (tmp1 - tmp2);
73:     // パーティクルの速度ベクトルを代入
74:     p->setVelocity(vec);
75:  
76:     // パーティクルの x 成分が -50 以下になったら消去。
77:     if(pos.x < -50.0) {
78:         removeParticle(p);
79:     }
80:  
81:     return;
82: }
83:  
84: int main()
85: {
86:     fk_ShapeViewer      viewer(600, 600);
87:     MyParticle          particle;
88:     fk_Prism            prism(40, 15.0, 15.0, 50.0);
89:
90:     viewer.setShape(3, &prism);
91:     viewer.setPosition(3, 0.0, 0.0, 25.0);
92:     viewer.setDrawMode(3, FK_POLYMODE);
93:     viewer.setShape(2, particle.getShape());
94:     viewer.setDrawMode(2, FK_POINTMODE);
95:     viewer.setScale(10.0);
96: 
97:     while(viewer.draw() == true) {
98:         particle.handle(); // パーティクルを 1 ステップ実行する。
99:     }
100:    return 0;
101:}
\end{verbatim}
\end{breakbox}
