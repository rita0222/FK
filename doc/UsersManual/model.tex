\chapter{モデルの制御} \label{chap:model} ~

この章では、fk\_Model というモデルを司るクラスの使用法を述べる。「モデル」
という単語は非常に曖昧な意味を持っている。FK でいうモデルとは、
位置や方向を持った1個のオブジェクトとしての存在のことを指す。
例えば、FK システムの中で
建物や車や地形といったものを創造したいならば、それらをひとつのモデル
として定義して扱うことになる。fk\_Shape クラスの派生クラス群による
形状は、このモデルに代入されて初めて意味を持つことになる。形状は、
形状でしかない。逆に、モデルにとって形状は1つのステータスである。

形状が、モデルのステータスであることは重要な意味を持つ。もし、モデルに
不変の形状が存在してしまうなら、そのモデルの形状を変化させる手段は
直接形状を変化させる以外にない。しかし、ある条件によってモデルの持つ
形状を\bou{入れ換えたい}と思うことはよくあることである。

例えば、視点から遠くにあるオブジェクトが大変細かなディティールで表現
されていたとしても、処理速度の面から考えれば明らかに無駄である。
それよりも、普段は非常に簡素な形状で表現し、視点から近くなったときに
初めてリアルな形状が表現できればよい。このとき、モデルに対して形状を
簡単に代入できる機能は大変重宝することになる。あるいは、アニメーション
機能などの実現も容易に行なうことが可能であろう。
\section{形状の代入}
形状の代入法は大変単純である。次のように行なえばよい。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector sPos(100.0, 0.0, 0.0), ePos(0.0, 0.0, 0.0);
        fk_Line line;
        fk_Model model;

        line.setVertex(0, sPos);
        line.setVertex(1, ePos);

        model.setShape(&line);
\end{verbatim}
\end{breakbox}
~ \\
つまり前章で示した形状を持つオブジェクトのポインタを、setShape() メンバ
関数の引数として与えてやればよい。この例では fk\_Line 型のオブジェクト
を用いたが、fk\_Shape クラスから派生したクラスのオブジェクトならば
なんでもよい。

setShape() によって形状の設定を行った後に、
形状そのものに対し編集を行った場合、
その編集結果は setShape() によって設定したモデルに直ちに反映する。
次のプログラムを見てほしい。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Block block(100.0, 50.0, 200.0);
        fk_Model model;

        model.setShape(&block);
                :
                :               // 様々な処理が行われている。
                :
        block.setSize(100.0, fk_Y);
\end{verbatim}
\end{breakbox}
~ \\
このプログラムの最後の行で、block の持つ形状が変化するわけだが、
同時に model の持つ形状も変化することを意味する。

この考えを発展させれば、1つの形状に対して複数のモデルに設定することが
可能であることがわかる。次のプログラムはそれを示している。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere  sphere(4, 100.0);
        fk_Model   model[4];
        int i;

        for(i = 0; i < 4; i++) {
                model[i].setShape(&sphere);
        }
\end{verbatim}
\end{breakbox}
~ \\
このような手法は、プログラムの効率を上げるためにも効果的なものである。
従って同じ形状を持つモデルは、同じ変数に対して setShape() による
設定を行うべきである。球などは、その最も好例であると言える。

ただし、この方式には落し穴がある。次のようなプログラムは、
一見正常に動作するようかのように見えるが、実はそうではない。
\\
\begin{breakbox}
\begin{verbatim}
        main()
        {
                fk_Model *model;
                model = retBlockModel(100.0, 100.0, 100.0)
                delete model;
        }

        fk_Model *retBlockModel(double x, double y, double z)
        {
                fk_Block block(x, y, z);
                fk_Model *model = new fk_Model;
        
                model->setShape(&block);
        
                return model;
        }
\end{verbatim}
\end{breakbox}
~ \\
なぜならば、retBlockModel 関数が終了した時点で関数内の block オブジェクト
も自動的に消滅してしまうからである。このとき、model のもつ形状ポインタは
行き場を失ってしまう。しかも、コンパイラが事前にチェックすることは
不可能なため、複雑なプログラムになってくると無意識にこのようなコーディング
をしてしまい、泥沼にはまりかねない。実際、コンパイラがどのような挙動を
起こすのかは予想できない。FK システムでは、多くの部分でこのような設計を行って
いるので、オブジェクトの存在の管理には常に気を配らなければならない。
\section{色の設定}
モデルは、色を表すマテリアルステータスを持っている。色の指定には
setMaterial というメンバ関数を用いるが、引数には \ref{chap:material} 章で述べた
fk\_Material 型のオブジェクトを用いる。
\\
\begin{screen}
\begin{verbatim}
        fk_Model model;
        fk_Material material;
                :                       // この部分で material を
                :                       // 作成しておく。
        model.setMaterial(material);
\end{verbatim}
\end{screen}
~ \\
あるいは、付録 A に記述されているマテリアルオブジェクトをそのまま
代入してもよい。
\\
\begin{screen}
\begin{verbatim}
        model.setMaterial(Green);
\end{verbatim}
\end{screen}
~ \\
このとき、(setShape 関数とは異なり)値は実際に model の中に確保された
メモリー内に全てコピーされるので、マテリアルオブジェクトが途中で
消滅してしまっても問題はない。なお、一度設定した色を初期化したい
場合には deleteMaterial(void) 関数を呼ぶとよい。

\section{描画モードと描画状態の制御} \label{sec:drawmode}
モデルに与えられた形状が例えば球 (fk\_Sphere) であった場合
通常は面表示がなされるが、これをワイヤーフレーム表示や点表示に
切り替えたい場合、setDrawMode メンバ関数を用いることで実現する
ことができる。例えば球をワイヤーフレーム表示したい場合は、
以下のようにすればよい。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere       Sphere(4, 10.0);
        fk_Model        SphereModel;

        SphereModel.setShape(&Sphere);
        SphereModel.setDrawMode(FK_LINEMODE);
\end{verbatim}
\end{breakbox}
~ \\
現在選択できる描画モードは、以下の通りである。
\begin{table}[H]
\caption{選択できる描画モード一覧}
\label{tbl:drawmode}
\begin{center}
\begin{tabular}{|c|l|}
\hline
FK\_POINTMODE & 形状の頂点を描画する。\\ \hline
FK\_LINEMODE & 形状の稜線を描画する。\\ \hline
FK\_POLYMODE & 形状の面のうち、表面のみを描画する。\\ \hline
FK\_BACK\_POLYMODE & 形状の面のうち、裏面のみを描画する。\\ \hline
FK\_FRONTBACK\_POLYMODE & 形状の面のうち、表裏両面を描画する。\\ \hline
\end{tabular}
\end{center}
\end{table}

点表示したい場合は FK\_POINTMODE、ワイヤーフレーム表示したい場合は
FK\_LINEMODE、面表示したい場合は FK\_POLYMODE を引数として与えることで、
モデルの表示を切り替えることができる。ただし、形状が fk\_Point で
ある場合に FK\_LINEMODE を与えたり、fk\_Line である場合に FK\_POLYMODE
を与えるといったような、表示状態が解釈できないような場合は何も
表示されなくなるので注意が必要である。

また、この描画モードは1つのモデルに対して複数のモードを同時に設定することが
できる。例えば面表示とワイヤーフレーム表示を同時に行いたい場合は、
次のように各モードを「\verb+|+」で続けて記述することで実現できる。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere       Sphere(4, 10.0);
        fk_Model        Solid;
        fk_Scene        Scene;

        Solid.setShape(&Sphere);
        Solid.setDrawMode(FK_POLYMODE | FK_LINEMODE);
        Scene.entryModel(&Solid);
\end{verbatim}
\end{breakbox}
~ \\
なお、FK\_POINTMODE と FK\_LINEMODE では光源設定は意味がない。
線や点に対する色設定に関しては、\ref{sec:pointlinemat} を参照してほしい。

\section{線や点の色付け(マテリアル)} \label{sec:pointlinemat}
線や点に対して色を設定するには、それぞれ setPointColor()、setLineColor()
というメンバ関数を用いる。それぞれの関数は引数として fk\_Color のポインタか、
RGB を表すfloat 型の実数3個のいずれかを代入する。次の例は、
1つの球を面の色が黄色、線の色が赤、点の色が緑に表示されるように
設定したものである。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere       Sphere(4, 10.0);
        fk_Model        Model;

        fk_Material::initDefault();
        Model.setShape(&Shape);
        Model.setDrawMode(FK_POLYMODE | FK_LINEMODE | FK_POINTMODE);
        Model.setMaterial(Yellow);     
        Model.setLineColor(1.0, 0.0, 0.0);
        Model.setPointColor(0.0, 1.0, 0.0);
\end{verbatim}
\end{breakbox}

\section{線の太さや点の大きさの制御} \label{sec:widthsize}
描画モードで FK\_POINTMODE か FK\_LINEMODE を選択した場合、
デフォルトでは描画される点の pixel における大きさ、線の幅は
ともに 1 に設定されている。これをもっと大きく(太く)したい場合は、
それぞれ setSize()、setWidth() メンバ関数を用いることで実現できる。
次の例は、球に対して点描画と線描画を同時に行うモデルを作成し、
点の大きさや線幅を制御しているものである。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere       Sphere(4, 10.0);
        fk_Model        Model;

        Model.setShape(&Sphere);
        Model.setDrawMode(FK_POINTMODE | FK_LINEMODE);
        Model.setSize(3.0);
        Model.setWidth(5.0);
\end{verbatim}
\end{breakbox}

線の太さや点の大きさに関しては、環境による制限が生じる場合がある。
例えば、ある太さ・大きさで固定されてしまう場合や、
一定以上の太さ・大きさでは描画されないといった現象が起きることがある。
この原因は主にグラフィックスハードウェア側の機能によるもので、
プログラムで直接制御することは難しい場合が多い。

\section{スムースシェーディング} \label{sec:smooth}
FK システムでは、隣り合う面同士をスムースに描画する機能を保持している。
これは、fk\_Model 中の setSmoothMode() というメンバ関数を用いることで
制御が可能である。これを用いると、例えば球などの本来は曲面で表現されている
形状をよりリアルに表示することが可能となる。次のように、関数の引数に
true を与えることによってそのモデルはスムースシェーディングを用いて
描画される。
\\
\begin{screen}
\begin{verbatim}
        fk_Model        Model;

        Model.setSmoothMode(true);      // スムースモード ON
        Model.setSmoothMode(false);     // スムースモード OFF
\end{verbatim}
\end{screen}
~ \\
なお、この設定は後述するモデル間の継承関係の影響を受けない。
\section{ピックモード}
FK システムでは、第 \ref{chap:window} 章で詳しく後述するが
ピックによるオブジェクトの選択が可能である。このとき、どの
モデルに対してピック選択の候補とするかを制御することが可能である。
全てのモデルを闇雲に候補にした場合、ピック時に動作が非常に遅くなる
可能性があるので、必要なモデルのみを候補にすべきである。

モデルに対してピック候補にするには、次のように setPickMode() メンバ関数で
引数に true を与えればよい。
\\
\begin{screen}
\begin{verbatim}
        fk_Model        Model;

        Model.setPickMode(true);
\end{verbatim}
\end{screen}
~ \\
引数に false を与えれば、そのモデルはピック選択の候補から外される。
デフォルトでは false になっているため、明示的に setPickMode(true) を
呼ばない限りはモデルがピック候補になることはない。

この設定もスムースシェーディングと同様に、モデル間の継承関係の影響を
受けない。
\section{モデルの位置と姿勢}
通常 3 次元のアプリケーションを作成する場合には、とても厄介な座標変換に
悩まされる。これは、平行移動や回転を行列によって表現し、それらの合成
によって状況を構築しなければならないからである。どのような 3 次元
アプリケーションも結果的には行列によって視点やオブジェクトの位置や姿勢を
表現するのだが、直接的に扱う場合は多くの困難な壁がある。

もう少し直感的な手段として、位置と姿勢を表現する方法が2つ存在する。
1つはベクトルを用いた方法であり、もう1つはオイラー角を用いた方法である。
ベクトルを用いる場合、次の 3 つのステータスをオブジェクトは保持する。
\begin{itemize}
 \item 位置ベクトル
 \item 前方向を表すベクトル (方向ベクトル)
 \item 上方向を表すベクトル (アップベクトル)
\end{itemize}
この表現は多くの開発者にとって直感的であろう。特に LookAt ---
オブジェクトがある位置からある位置を向く --- の実装と大変相性が良い。
この手段を用いた場合には最終的にはすべてを回転変換で表現できる
ような変換式を用いる。このとき問題となるのが、オブジェクトが真上と真下を
見た場合に、変換式が不定になってしまうことである。

もう1つの手段としてのオイラー角は、普段から聞きなれた言葉ではない。
オイラー角とは、実際には 3 つの角度から構成されている。それぞれ
ヘディング角、ピッチ角、バンク角(しばしばロール角とも表現される)と
呼ばれる。簡単に述べると、ヘディング角は東西南北のような緯度方向を、
ピッチ角は高度を示す経度方向を、バンク角は視線そのものを回転軸とした
回転角を表す。

この表現はすべての状況に矛盾を起こさないとても便利な手段である。しかし
アプリケーションを作成する側から見ると、LookAt のような機能の実装には
球面逆三角関数方程式と呼ばれる式を解かねばならず、
骨が折れることだろう。また、この場合でも変換の際には解が不定となる
場合が存在するので、根本的な解決とはならない。

FK システムでは、独自の方法でこれを回避している。FK システムは、
モデルの各々が次のようなステータスを保持している。
\begin{itemize}
 \item 位置
 \item 方向ベクトルとアップベクトル
 \item オイラー角
 \item 行列
\end{itemize}
実はこの方法では同じ意味を違う方法で 3 通りにも渡って表現していることになる。
ここでは詳しく述べないが、この 3 通りもの表現は、
互いに弱点を補間しあっており、あるステータスが不定になるような場合には
他のステータスが適用されるようにできている。

一方で、fk\_Model クラスではメンバ関数によってこれらの制御を行うので
あるが、FK システムを用いた開発ではさきほど述べたようなわずらわしさからは
一切解放される。これらはすべて内部的に行われ、ベクトル表現、オイラー角表現、
行列表現のいずれもが常に整合性を保ち続けることを保証している。

次節からは、モデルに対しての具体的な位置と姿勢の操作を行うためのメンバ関数
を、具体的な説明を交えながら述べていく。数は多いが、体系的なものなので
理解はさほど難しくないだろう。
\section{グローバル座標系とローカル座標系}
3 次元アプリケーションの持つ座標系の重要な概念として、グローバル座標系
とローカル座標系が挙げられる。グローバル座標系は、しばしばワールド座標系
とも呼ばれる。平易な言葉で述べるなら、グローバル座標系は客観的な
視点であり、ローカル座標系は主観的な視点である。

理解しやすくするために、車の運転を例にとって説明する。車が走っている
場面をある場所から傍観しているとしよう。車は、背景の中を運転者の
気の向くままに挙動している。つまり、3 次元座標内を前方向に前進
しているということになる。一定時間が経てば、車の位置は進行方向に
ある程度進んでいることだろう。グローバル座標系は、このような
運動を扱うときに用いられる。グローバル座標系はすべてのモデルが
共通して持つ座標系であり、静的なモデル --- この例では背景 --- の
位置座標は変化しない。

今度は車の運転者の立場を考えよう。運転者にとっては、前進することによって
背景が後ろに過ぎ去っていくように見える。ハンドルを切れば、背景が回転
しているように見える。もし北に向かって走っていれば右方向は東になるが、
西に向かっていれば右は北になる。このとき、運転者にとっての前後左右が
ローカル座標系である。それに対し、東西南北にあたるものがグローバル
座標系となる。

FK システムにおけるモデルの制御では、一部の例外を除いて常にグローバル座標系
とローカル座標系のどちらを使用することもできる。グローバル座標系は、
次のような制御に適している。
\begin{itemize}
 \item 任意の位置への移動。
 \item グローバル座標系で指定された軸による回転。
 \item グローバル座標系による方向指定。
\end{itemize}
それに対し、ローカル座標系は次のような制御に適している。
\begin{itemize}
 \item 前進、方向転換。
 \item オブジェクトを中心とした回転。
 \item ローカル座標系による方向指定。
\end{itemize}
かなり直観的な表現を使うと、グローバル座標系は東西南北を指定するときに
用いられ、ローカル座標系は前後左右を指定するときに用いられると考えられる。
どちらも、それぞれに適した場面が存在する。具体的な使用例は、
\ref{chap:sample} 章の
プログラム例に委ねることにする。この章での目的は、実際の機能の紹介にある。

FK システムでは、グローバル座標系を扱うメンバ関数では
プレフィックスとして gl を冠し、ローカル座標系を扱う
メンバ関数は lo を冠するよう統一されている。以上のことを念頭において、
ここからの記述を参照されたい。ちなみに、FK システムでは次のような
左手座標系を採用しており、ローカル座標系もこれにならう。
\begin{enumerate}
 \item モデルにとって、前は \(-z\) 方向を指す。
 \item モデルにとって、上は \(+y\) 方向を指す。
 \item モデルにとって、右は \(+x\) 方向を指す。
\end{enumerate}
\section{モデルの位置と姿勢の参照}
モデルの位置を参照したいときには、getPosition メンバ関数を用いる。
この関数は fk\_Vector 型の返り値を持つ。
\\
\begin{screen}
\begin{verbatim}
        fk_Model model;
        fk_Vector position;
                :
                :
        position = model.getPosition();
\end{verbatim}
\end{screen}
~ \\
同様にして、モデルの方向ベクトルとアップベクトルもそれぞれ
getVec 関数と getUpvec 関数で参照できる。
\\
\begin{screen}
\begin{verbatim}
        fk_Model model;
        fk_Vector vec, upvec;
                :
                :
        vec = model.getVec();
        upvec = model.getUpvec();
\end{verbatim}
\end{screen}
~ \\
したがって、あるモデルの位置と姿勢を別のモデルにそっくりコピーしたい
ときは、この 3 つのステータスを代入すればよい。(代入法に関しては
後述する。)

その他、モデルの持つオイラー角や行列も参照できる。それぞれ、
getAngle、getMatrix という名のメンバ関数を用いる。
\\
\begin{screen}
\begin{verbatim}
        fk_Model model;
        fk_Angle angle;
        fk_Matrix matrix;
                :
                :
        angle = model.getAngle();
        matrix = model.getMatrix();
\end{verbatim}
\end{screen}
~ \\
fk\_Angle 型は、オイラー角を表現するクラスである。位置と方向ベクトルと
アップベクトルを用いてモデルの状態をコピーすることを前述したが、
これは位置とオイラー角を用いても可能である。単にコピーするだけならば、
オイラー角を用いた方が便利であろう。ある法則を持ってずらして移動させる
(たとえば元モデルの後部に位置させるなど)ような高度な制御を行うような
場合には、ベクトル表現を用いて処理する方が良いときも多い。適宜選択
するとよい。
\section{平行移動による制御}
モデルの方向を変化させず、モデルを移動させる手段として、fk\_Model クラス
では 6 種類のメンバ関数を用意している。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> void glTranslate(fk\_Vector); \\
\> void glTranslate(double, double, double); \\
\> void loTranslate(fk\_Vector); \\
\> void loTranslate(double, double, double); \\
\> void glMoveTo(fk\_Vector); \\
\> void glMoveTo(double, double, double); \\
\end{tabbing}
\end{bf}
\subsection{glTranslate}
glTranslate 関数は、モデルの移動ベクトルをグローバル座標系で
与えるためのメンバ関数である。例えば、
\\
\begin{breakbox}
\begin{verbatim}
        fk_Vector vec(1.0, 0.0, 0.0);
        fk_Model model;
        int i;

        for(i = 0; i < 10; i++) {
                model.glTranslate(vec);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
というプログラムは、ループの1周毎に model を \(x\) 方向に 1 ずつ
移動させる。glTranslate 関数は多重定義されており、ベクトルの各要素を
直接代入してもよい。
\\
\begin{screen}
\begin{verbatim}
        model.glTranslate(1.0, 0.0, 0.0);
\end{verbatim}
\end{screen}
~ \\
オブジェクトに対して非常に静的な制御を行う場合には、むしろこの方が
便利であろう。
\subsection{loTranslate}
loTranslate 関数は、ローカル座標系で移動を制御する。最も多用される
表現は、前進を表す次の記述である。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Model model;
        double length;
        int i;

        for(i = 0; i < 10; i++) {
                length = double(i)*10.0;
                model.loTranslate(0.0, 0.0, length);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
これにより、等加速度運動が表現されている(length は 10 ずつ増加しているから)。
また(向いている方向によらずに)モデルを自身の右へ平行移動させることも、
次の記述で可能である。
\\
\begin{breakbox}
\begin{verbatim}
        for(int i = 0; i < 10; i++) {
                model.loTranslate(0.0, 10.0, 0.0);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
例では述べられていないが、引数として fk\_Vector 型のオブジェクトをとることも
許されている。
\subsection{glMoveTo}
glTranslate 関数が移動量を与えるのに対して、glMoveTo 関数は
実際に移動する位置を直接指定する関数である。したがってこの関数に
おいては、現在位置がどこであってもまったく関係がない。
glMoveTo 関数を用いた移動表現は、Translate 関数群を用いるよりも
直接的なものとなる。
\\
\begin{breakbox}
\begin{verbatim}
        for(int i = 0; i < 10; i++) {
                model.glMoveTo(0.0, 0.0, double(i)*10.0);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
このプログラムは、次のプログラムと同じ挙動をする。
\\
\begin{breakbox}
\begin{verbatim}
        model.glMoveTo(0.0, 0.0, 0.0);
        for(int i = 0; i < 10; i++) {
                model.glTranslate(0.0, 0.0, 10.0);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
大抵の場合は工夫次第で同じ動作を多種に渡る表現によって実現可能である
ことは多い。できるだけ素直な表現を選択するよう努めるとよいだろう。
よほど多くのモデルを相手にするのでなければ、選択による
パフォーマンスの差は問題にならない程度である。

なお、loMoveTo 関数は loTranslate で代用できるため、loVec 関数と
同一の理由で提供されていない。
\section{方向ベクトルとアップベクトルの制御}
FK システムにおいて、モデルの姿勢を制御する手法は大別すると
方向ベクトルとアップベクトルを用いるもの、オイラー角を用いるもの、
回転変換を用いるものの 3 種類がある。この節では、このうち
方向ベクトルとアップベクトルを用いて制御するために提供されている
メンバ関数を紹介する。3 種類のうち、この手法がもっとも直接的
(Primitive) である。

この節では次の 8 種類のメンバ関数を紹介する。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> void glFocus(fk\_Vector); \\
\> void glFocus(double, double, double); \\
\> void loFocus(fk\_Vector); \\
\> void loFocus(double, double, double); \\
\> void glVec(fk\_Vector); \\
\> void glVec(double, double, double); \\
\> void glUpvec(fk\_Vector); \\
\> void glUpvec(double, double, double); \\
\> void loUpvec(fk\_Vector); \\
\> void loUpvec(double, double, double); \\
\end{tabbing}
\end{bf}
このうち、多重定義されている関数は移動関数群と同じように fk\_Vector によるか、
3 次元ベクトルを表す 3 つの実数を代入するかの違いでしかないので、
実質的には 4 種類となる。
\subsection{glFocus}
glFocus 関数は簡単に述べてしまうと、任意の位置を代入することによって
その位置の方にモデルを向けさせる関数である。これは、あるモデルが別の
モデルの方向を常に向いているというような制御を行いたいときに、
特に真価を発揮する。次のプログラムは、それを容易に実現していることを
示すものである。
\\
\begin{breakbox}
\begin{verbatim}
  // modelA は、常に modelB に向いている。

        fk_Model modelA, modelB;

        for(;;) {
                        :       // ここで、modelA と modelB の移動が
                        :       // 行われているとする。
                        :
                modelB.glFocus(modelA.getPosition());
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
この関数で注意しなければならないのは、直接方向ベクトルを指定するものでは
ないということである。
直接指定するような処理を行いたい場合には、glVec 関数を用いればよい。
\subsection{loFocus}
loFocus 関数は、glFocus のローカル座標系版である。lo 関数群に共通の、
主観的な制御には好都合な関数である。例えば、
\\
\begin{breakbox}
\begin{verbatim}
        model.loFocus(0.0, 0.0, 1.0);          // 後ろを向く。
        model.loFocus(1.0, 0.0, 0.0);           // 右を向く。
        model.loFocus(-1.0, 0.0, 0.0);          // 左を向く。
        model.loFocus(0.0, 1.0, 0.0);           // 上を向く。
        model.loFocus(0.0, -1.0, 0.0);          // 下を向く。
        model.loFocus(1.0, 1.0, 0.0);           // 右上を向く。
        model.loFocus(-1.0, 1.0, -1.0);          // 左前上方を向く。
        model.loFocus(0.01, 0.0, -1.0);          // わずかに右を向く。
        model.loFocus(0.0, 0.01, -1.0);          // わずかに上を向く。
\end{verbatim}
\end{breakbox}
~ \\
といったような扱い方が代表的なものである。
\subsection{glVec}
この関数は、モデルの方向ベクトルを直接指定するものである。
この関数を用いた場合、アップベクトルの方向が前の状態とは
関係なく自動的に算出されるため、モデルの姿勢を glUpvec 等を
用いて制御しない場合、思わぬ姿勢になることがある。

この関数は、もちろん glUpvec 等と併用してモデルの姿勢を定義する
のに有効だが、特に光源 (fk\_Light) や円盤 (fk\_Circle) のように
アップベクトルの方向に意味がないモデルを簡単に制御するのに向いているといえる。

なお、loVec 関数は提供されていない。なぜならば loVec 関数は
意味的には loFocus 関数とまったく同じ機能を持つので、そのまま代用が
可能となるからである。
\subsection{glUpvec}
この関数は、アップベクトルを直接代入する。アップベクトルは本来
方向ベクトルと直交している必要があるが、与えられたベクトルが
方向ベクトルと平行であったり零ベクトルであったりしない限り、
適当な演算が施されるので心配はいらない。逆に、この関数は
方向ベクトルに依存して与えたアップベクトルを書き換えてしまうので、
非常に融通の利かない関数ともいえる。
実際この関数は、モデルのアップベクトルを常に固定しておく以外にはあまり
使用することはない。アップベクトルを直接扱うことはある程度難解である。
大抵の場合は、後述の回転変換を用いれば解決してしまう。ブランコのような
表現や、コマのような表現も、回転変換を用いた方が明らかに簡単である。
\subsection{loUpvec}
察しの通り、この関数は glUpvec のローカル座標系版である。この関数は
アップベクトルが方向ベクトルと直交していなければならないという
理由から、\(z\) 方向の値は意味を持たない。この関数は glFocus 関数と
比べてもさらに特殊な状況でしか扱われないであろう。ここでは紹介程度に
とどめておく。
\section{オイラー角による姿勢の制御}
この節では、オイラー角による制御を提供する 4 種類の関数に関しての
紹介が記述されている。4 つの関数は、次に示す通りである。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> void glAngle(fk\_Angle); \\
\> void glAngle(double, double, double); \\
\> void loAngle(fk\_Angle); \\
\> void loAngle(double, double, double); \\
\end{tabbing}
\end{bf}
それぞれ多重定義がなされているが、3 つの実数を引数にとる2つの関数は
これまでのようにベクトルを意味しているのではなくオイラー角の 3 要素を
示しており、3 つの引数はそれぞれヘディング角、ピッチ角、バンク角を
表している。fk\_Angle クラスはオイラー角を表現するためのクラスであり、
次のように定義されている。
\\
\begin{screen}
\begin{verbatim}
  class fk_Angle {
    public:
        double h;                // ヘディング角
        double p;                // ピッチ角
        double b;                // バンク角
  };
\end{verbatim}
\end{screen}
~ \\
従って、ベクトルの場合と同様に直接メンバへのアクセスが可能である。

fk\_Angle のメンバにしても、glAngle(double, double, double) や
loAngle(double, double, double) にしても、値はすべて弧度法(ラジアン)による。
つまり、直角の値は \(\frac{\pi}{2} \doteq 1.570796\) となる。
\subsection{glAngle}
glAngle 関数はオイラー角を直接設定する関数である。相対的な変化量では
なく絶対的なオイラー角の値をここでは代入する。そういった点では、これは
glTranslate 関数よりも glMoveTo 関数に近い。

オイラー角による表現は非常に手軽である反面、慣れないと把握が難しい。
また、制御をベクトルによって行うかオイラー角によって行うかは
アプリケーションそのものの設計にも深く関わってくる。あまり明示的な
動作の指定や位置座標の指定を多用しないアプリケーションなら、
オイラー角を用いた方が効果的な場合もある。しかし、glFocus と
glAngle を getAngle を用いずに併用することは、明らかに混乱を巻き起こすだろう。

glAngle 関数の効果的な使用法の1つとして、姿勢の初期化が上げられる。
初期状態の姿勢を fk\_Angle 型のオブジェクトに保管しておくことによって、
いつでも姿勢を初期化できる。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Model model;
        fk_Vector init_pos;
        fk_Angle init_angle;
                :
                :
        init_pos = model.getPosition();         // 位置のスナップショット
        init_angle = model.getAngle();          // 姿勢のスナップショット
                :
                :
        model.glMoveTo(init_pos);               // スナップショットを行った
        model.glAngle(init_angle);              // 状態に戻す。
\end{verbatim}
\end{breakbox}
~ \\
また、オイラー角の変化による立体の回転はアプリケーションのユーザにとって
直観的であるため、ユーザインターフェースを介して立体を意のままに動かすような
アプリケーションにも威力を発揮するであろう。
\subsection{loAngle}
オイラー角による制御は、glAngle 関数よりもむしろローカル座標系関数である
loAngle で真骨頂を発揮する。loAngle 関数では、先に述べた loFocus 関数と
非常によく似た機能を持つが、バンク角の要素を持つために loFocus よりも
応用性は高い。ここにその機能を羅列してみる。(FK\_PI は円周率である。)
\\
\begin{breakbox}
\begin{verbatim}
        model.loAngle(FK_PI, 0.0, 0.0);              // 後ろを向く。
        model.loAngle(FK_PI/2.0, 0.0, 0.0);          // 右を向く。
        model.loAngle(-FK_PI/2.0, 0.0, 0.0);         // 左を向く。
        model.loAngle(0.0, FK_PI/2.0, 0.0);          // 上を向く。
        model.loAngle(0.0, -FK_PI/2.0, 0.0);         // 下を向く。
        model.loAngle(FK_PI/2.0, FK_PI/4.0, 0.0);    // 右上を向く。
        model.loAngle(-FK_PI/4.0, FK_PI/4.0, 0.0);   // 左前上方を向く。
        model.loAngle(FK_PI/100.0, 0.0, 0.0);        // わずかに右を向く。
        model.loAngle(0.0, FK_PI/100.0, 0.0);        // わずかに上を向く。
        model.loAngle(0.0, 0.0, FK_PI);              // 視線を軸に半回転。
        model.loAngle(0.0, 0.0, FK_PI/2.0);          // モデルを右に傾ける。
        model.loAngle(0.0, 0.0, FK_PI/100.0);        // わずかに右に傾ける。
\end{verbatim}
\end{breakbox}
~ \\
loFocus と比較してみてほしい。この loAngle の特徴は、回転を角度代入
によって行うことにある。こちらのほうが、開発者は
直観的に定量的な変化を行うことが可能であろう。また、loFocus と違って
アップベクトルの挙動の予想もできる。loFocus の乱用は、時としてアップベクトル
に対して予想と食い違った処理を施す可能性もある。loAngle ではその心配は
ない。
\section{回転による制御}
前節のオイラー角による制御が姿勢を定義するためのものであるならば、
ここで述べる関数群は位置を回転によって制御するためのものといえる。
ここで述べられる関数は全部で 16 種類ある。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> void glRotate(fk\_Vector, fk\_Axis, double); \\
\> void glRotate(double, double, double, fk\_Axis, double); \\
\\
\> void glRotate(fk\_Vector, fk\_Vector, double); \\
\> void glRotate(double, double, double, double, double, double, double); \\
\\
\> void loRotate(fk\_Vector, fk\_Axis, double); \\
\> void loRotate(double, double, double, fk\_Axis, double); \\
\\
\> void loRotate(fk\_Vector, fk\_Vector, double); \\
\> void loRotate(double, double, double, double, double, double, double); \\
\\
\> void glRotateWithVec(fk\_Vector, fk\_Axis, double); \\
\> void glRotateWithVec(double, double, double, fk\_Axis, double); \\
\\
\> void glRotateWithVec(fk\_Vector, fk\_Vector, double); \\
\> void glRotateWithVec(double, double, double,
	double, double, double, double); \\
\\
\> void loRotateWithVec(fk\_Vector, fk\_Axis, double); \\
\> void loRotateWithVec(double, double, double, fk\_Axis, double); \\
\\
\> void loRotateWithVec(fk\_Vector, fk\_Vector, double); \\
\> void loRotateWithVec(double, double, double,
	double, double, double, double); \\
\end{tabbing}
\end{bf}
この関数群も、実質 8 種類の関数が
引数として fk\_Vector 型をとるものと 3 つの実数をとるもので
多重定義がなされている。行間なく記されているもの同士が対応している。
\subsection{glRotate と glRotateWithVec}
glRotate 関数は、大きく2つの機能を持っている。次の引数を持つ場合、
モデルはグローバル座標軸を中心に回転する。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Model model;
        fk_Vector pos(0.0, 0.0, 0.0);
                :
                :
        model.glRotate(pos, fk_X, FK_PI/4.0);
\end{verbatim}
\end{breakbox}
~ \\
このうち、最初の引数には回転の中心となる軸上の点を指定する。例の場合は
原点を指定している。次の引数は回転軸をどの軸に平行な直線にするかを指定
するもので、fk\_X、fk\_Y、fk\_Z から選択する。最後の引数は
回転角を弧度法で入力する。中心は原点でなくてもよい。

一方ベクトル2つと実数1つを引数に取る場合には、glRotate 関数は
任意軸回転演算として働く。回転軸直線上の 2 点を代入すればよい。
最後の引数は回転角である。実数 7 つをとる場合も、1 番目から 3 番目、
4 番目から 6 番目がそれぞれ2点の位置ベクトルを表す。次のプログラムは、モデルを
\((100, 50, 0), (50, 100, 0)\)を通る回転軸を中心に1回転させる
ものである。
\\
\begin{breakbox}
\begin{verbatim}
        for(int i = 0; i < 200; i++) {
                model.glRotate(100.0, 50.0, 0.0, 50.0, 100.0, 0.0, FK_PI/100.0);
                        :
                        :
        }
\end{verbatim}
\end{breakbox}
~ \\
glRotate 関数はあくまでモデルの位置を回転移動するためのものであり、
姿勢や方向ベクトルはまったく変化しない。したがって、回転軸が
モデルの位置を通る場合には、位置の移動がないために変化がない。
回転移動の際に、方向ベクトルも同じように回転してほしい場合には
glRotateWithVec 関数を用いるとよい。この関数は位置の回転とともに
姿勢の回転も行われる。また回転軸がモデルの位置を通るように
設定すれば、モデルは移動せずに方向だけ回転させることができる。
これらの関数はモデルの挙動を予想しやすいので、安心して使用する
ことができるであろう。
\subsection{loRotate と loRotateWithVec}
loRotate メンバ関数と loRotateWithVec メンバ関数は、ローカル座標系版である
ことを除けば glRotate や glRotateWithVec となんら変わりはない。特に
loRotateWithVec は、loAngle 関数と多くの機能が重複している。その例を
表\ref{tbl:fkAngle1}に示す。ただし、origin は原点を、angle は回転角度を指す。

\begin{table}[H]
\caption{RotateWithVec と loAngle の比較}
\label{tbl:fkAngle1}
\begin{center}
\begin{tabular}{|c|c|}
\hline
RotateWithVec による表現 & loAngle による表現 \\ \hline \hline
loRotateWithVec(origin, fk\_X, angle) & loAngle(0.0, angle, 0.0) \\ \hline
loRotateWithVec(origin, fk\_Y, angle) & loAngle(angle, 0.0, 0.0) \\ \hline
loRotateWithVec(origin, fk\_Z, angle) & loAngle(0.0, 0.0, angle) \\ \hline
\end{tabular}
\end{center}
\end{table}

回転の中心や軸の方向を任意にできることから、loRotate の方が loAngle よりも
柔軟であるといえるだろう。
\section{モデルの拡大縮小}
FK システムでは、モデルに対して拡大や縮小を行うことが可能であり、
次のようなメンバ関数が提供されている。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> void setScale(double); \\
\> void setScale(double, fk\_Axis); \\
\> void setScale(double, double, double); \\
\\
\> void prdScale(double); \\
\> void prdScale(double, fk\_Axis); \\
\> void prdScale(double, double, double); \\
\end{tabbing}
\end{bf}
setScale() メンバ関数はモデルの絶対倍率を設定するための関数である。
引数として double 1個のみをとる関数は、モデルの拡大や縮小を単純に
行う。fk\_Axis を引数にとる場合、指定された軸方向に対して拡大や
縮小を行う。具体的には、次のように記述を行う。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Model        Model;

        Model.setScale(2.0, fk_X);      // X 方向に 2 倍に拡大
        Model.setScale(0.4, fk_Y);      // Y 方向に 0.4 倍に縮小
        Model.setScale(2.5, fk_Z);      // Z 方向に 2.5 倍に拡大
\end{verbatim}
\end{breakbox}
~ \\
また、引数が double 3個のものはそれぞれ x 方向、y 方向、z 方向への
拡大率を示す。上の例は、次のように書き換えられる。
\\
\begin{screen}
\begin{verbatim}
        fk_Model        Model;

        Model.setScale(2.0, 0.4, 2.5);
\end{verbatim}
\end{screen}
~ \\
setScale() は、現在のモデルの拡大率に対して相対的な拡大率を設定する
ものではなく、リンクされた形状に対する絶対的な拡大率を設定するための
関数である。もし相対的な指定を行いたい場合は、setScale() ではなく
prdScale() を用いる。引数の意味は setScale() と同様である。

また、現在の拡大率を調べたい場合は次のような拡大率が用意されている。
\begin{bf}
\begin{tabbing}
xxxxxxx \= \kill
\> double getScale(void); \\
\> double getScale(fk\_Axis); \\
\end{tabbing}
\end{bf}
引数がない場合、全体の拡大率が返る。fk\_Axis 型の引数を入れた場合、
その引数が示す軸方向の拡大率が返る。

\section{モデルの親子関係と継承}
\subsection{モデル親子関係の概要}
モデルに関する最後のトピックは継承に関してのものである。

FK システムを利用した開発者が車をデザインしたいと思ったとしよう。車は多くの
部品から成り立っている。それらを最初から形状モデラで作成し、1つの
fk\_Solid として読み込むのも1つの手である。しかしその他のプリミティブな
形状、例えば fk\_Block や fk\_Sphere 等を利用して簡単な疑似自動車を
デザインするような場合を考える。当然プリミティブな立体から車を
デザインすることも容易な作業ではないが、問題はその後である。
タイヤにあたる部分は車の中心から4つの隅方に地面に接して並んでいる。
問題は、車が回転するような運動を行なった時にタイヤ自体は非常に
複雑な動作をすることにある。これはベクトルの合成を用いて解決する
ことは可能だが、プログラムが複雑になることに変わりはない。

そこで、FK システムでは複数のモデルをまとめて1つのモデルとして扱えるような
機能を用意している。もし車体とタイヤの全てをグルーピングし、1つの
モデルとして制御できるのならば何の問題もない。これは、\textbf{継承}と
呼ばれる手法を用いて実現することができるのである。

車の場合を考えよう。まず車体を準備する。次に 4 つのタイヤを車体に
対して適当な位置に設定する。この相対的な位置関係が固定されれば、
自動車は1つのモデルとして扱えるわけである。そこで、4 つのタイヤ
に対して自分の\textbf{親モデル}が車体であることを教えてやるのである。
こうすれば、親の動きに合わせて\textbf{子モデル}は相対的な位置を保つよう
な挙動を起こす。もう少し厳密に言うならば、子モデルは親モデルの
ローカル座標を固定されているわけである。

この機能は、fk\_Model の持つ setParent メンバ関数によって実現されている。
引数として親モデルのポインタを与える。このときに子モデルの持っていた
グローバル座標系での位置と姿勢は、親モデルのローカル座標系でのそれとして
扱われるようになる。具体的なプログラムをここに示す。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Sphere sphere(4, 50.0);
        fk_Block block(300.0, 100.0, 500.0);
        fk_Model CarBody;
        fk_Model CarTire[4];
        int i;

        CarBody.setShape(&block);
        CarBody.glTranslate(0.0, 100.0, 500.0);
        for(i = 0; i < 4; i++) CarTire[i].setShape(&sphere);

        CarTire[0].glMoveTo(150.0, -50.0, 150.0);
        CarTire[1].glMoveTo(-150.0, -50.0, 150.0);
        CarTire[2].glMoveTo(150.0, -50.0, -150.0);
        CarTire[3].glMoveTo(-150.0, -50.0, -150.0);

        for(i = 0; i < 4; i++) CarTire[i].setParent(&CarBody);
\end{verbatim}
\end{breakbox}
~ \\
プログラムを簡易なものにするため車体を fk\_Block、タイヤを fk\_Sphere で
表現している。まず、CarBody モデルを glTranslate によってある程度
移動させる。次にタイヤの位置を、親モデルとの相対位置になる地点に
CarTire を持ってくる。上記例の場合は球なので方向は関係ないが、必要ならば
このときに姿勢を定義しておく。そして、親モデルが CarBody であることを
示すために setParent 関数を呼んでいる。

このプログラムは、以後に CarBody を動作させるとそれに付随して
CarTire も動作するようになる。もし CarTire に対して移動を行う
メンバ関数を呼ぶとどうなるか? このとき、CarTire は CarBody に
対しての相対位置が変更される。これは、例のプログラムにおいて
{\tt CarTire[i].setShape()} と {\tt CarTire[i].glMoveTo()} の
順序を反転させても支障がないことを示す。

また、既にあるモデルの子モデルとなっているモデルに対し、
さらにその子モデル(元の親モデルからすれば、いわゆる「孫モデル」)を
指定できる。
例えば、タイヤをさらにリアルにするためにボルトを付加させることも
できる。このときには、やはりボルトを(タイヤに対して)相対的な位置に
設定しておけばよい。

また、継承は座標系だけではなく、モデルの
マテリアル属性にも反映される。もし子モデルのマテリアルが未定義であった場合、
親モデルの色が設定される。子モデルにすでに色が設定されて
いる場合には子モデルのマテリアルが優先される。

\subsection{親子関係とモデル情報取得}
モデルが親子関係を持った場合、モデルの情報取得は単純な話ではなくなる。
例えば、モデルの位置を取得する getPosition 関数やオイラー角を得る
getAngle 関数の場合を考えてみる。

通常、これらの値はグローバル座標系における自身の
座標ベクトルやオイラー角が返ってくるのだが、子モデルとなっている場合には
親モデルに対する相対座標ベクトルや相対オイラー角が返り値となっている。

これは多くの場合は都合が悪い。これらのみを用いる場合、
子モデルの中心が実際にグローバル座標系で
どこに位置するのかを知ることができない。
そこで、子モデルのグローバル座標系における位置や姿勢等を得たいときのために、
fk\_Model は getInhPosition (Inh は Inheritance -- 継承の略)
というメンバ関数を持っている。この関数は
getPosition 関数とまったく同様の使用法ではあるが、例え親モデルを
持っていても正確なグローバル座標系による位置が返ってくる。
これと同様にして getAngle に対応した
getInhAngle、getVec に対応した getInhVec、getUpvec に対応した
getInhUpvec、getMatrix に対応した getInhMatrix といったメンバ関数を
fk\_Model クラスは持っている。

もしモデルが親を持っていたとき、
表\ref{tbl:fkInh1}に示す
関数群は親に対する相対的な値を返す。

\begin{table}[H]
\caption{相対的な値を返す関数群}
\label{tbl:fkInh1}
\begin{center}
\begin{tabular}{|c|l|}
\hline
返り値の型 & 関数名 \\ \hline \hline
fk\_Vector & getPosition \\ \hline
fk\_Vector & getVec \\ \hline
fk\_Vector & getUpvec \\ \hline
fk\_Angle & getAngle \\ \hline
fk\_Matrix & getMatrix \\ \hline
\end{tabular}
\end{center}
\end{table}

それに対し、表\ref{tbl:fkInh2}の関数群は絶対的なグローバル座標を返す。

\begin{table}[H]
\caption{絶対的な値を返す関数群}
\label{tbl:fkInh2}
\begin{center}
\begin{tabular}{|c|l|}
\hline
返り値の型 & 関数名 \\ \hline \hline
fk\_Vector & getInhPosition \\ \hline
fk\_Vector & getInhVec \\ \hline
fk\_Vector & getInhUpvec \\ \hline
fk\_Angle & getInhAngle \\ \hline
fk\_Matrix & getInhMatrix \\ \hline
\end{tabular}
\end{center}
\end{table}


\section{親子関係とグローバル座標系} \label{sec:modelglobal}
通常、モデル同士に親子関係を設定したとき、子モデルは位置・姿勢共に
変化する。これは前述したように、元々子モデルが持っていた位置や姿勢が、
親モデルからの相対的なものとして扱われるようになるためである。

しかし、モデル間の親子関係は結びたいが、
子モデルの位置や姿勢は変化させたくないというケースもある。同様に、
親子関係を解消しても、子モデルの位置や姿勢を変化させたくないということも
ありえる。このような要求に応えるため、setParent 関数は 2 番目に bool 型の
引数と取ることで制御することが可能である。
\\
\begin{breakbox}
\begin{verbatim}
        fk_Model    modelA, modelB;

        modelA.glMoveTo(10.0, 0.0, 0.0);
        modelB.setParent(&modelA, true);
\end{verbatim}
\end{breakbox}
~ \\
上記のプログラムで、通常では setParent によって modelB も
グローバル座標系では移動するのであるが、setParent 関数の
2番目の引数に「true」を指定すると、setParent による設定後も
modelB は元の位置・姿勢を保つ。2番目の引数に「false」を指定した場合、
または 2 番目の引数を省略した場合、元の位置や姿勢や modelA からの
相対的なものとして扱われるため、結果的に modelB は移動することになる。

\subsection{親子関係に関する関数} 
以下に、親子関係に関する fk\_Model のメンバ関数を羅列する。
\begin{tabbing}
xx \= xxxx \= \kill
\> \textbf{void setParent(fk\_Model *p, bool flag)} \\
	\> \> \begin{tabular}{p{15cm}}
		p を親モデルとして設定する。flag が true の場合、
		設定後も元モデルのグローバル座標系での位置・姿勢が
		変化しない。false の場合は、元の位置・姿勢が p の
		相対的な位置・姿勢として扱われる。2 番目の引数を
		省略した場合、false と同じとなる。
	\end{tabular} \\ \\

\> \textbf{void deleteParent(bool flag)} \\
	\> \> \begin{tabular}{p{15cm}}
		設定してあった親モデルとの関係を解除する。
		元々親モデルが設定されていなかった場合は何も起こらない。
		flag に関しては、setParent() 関数と同様。
	\end{tabular} \\ \\

\> \textbf{void entryChild(fk\_Model *c, bool flag)} \\
	\> \> \begin{tabular}{p{15cm}}
		c を子モデルの1つとして設定する。
		flag に関しては、setParent() 関数と同様。
	\end{tabular} \\ \\

\> \textbf{void deleteChild(fk\_Model *c, bool flag)} \\
	\> \> \begin{tabular}{p{15cm}}
		c が子モデルであった場合、親子関係を解除する。
		c が子モデルではなかった場合は何も起こらない。
		flag に関しては、setParent() 関数と同様。
	\end{tabular} \\ \\

\> \textbf{void deleteChildren(bool flag)} \\
	\> \> \begin{tabular}{p{15cm}}
		自身に設定されている全ての子モデルに対し、
		親子関係を解除する。
		flag に関しては、setParent() 関数と同様。
	\end{tabular} \\ \\

\> \textbf{fk\_Model * getParent(void)} \\
	\> \> \begin{tabular}{p{15cm}}
		自身に設定されている親モデルを返す。
		親モデルが設定されていない場合、nullptrを返す。
	\end{tabular} \\ \\

\> \textbf{fk\_Model * foreachChild(fk\_Model *c)} \\
	\> \> \begin{tabular}{p{15cm}}
		自身に設定されている子モデルを順番に返す。
		まず c に nullptr が入力されたとき、最初に設定された子モデル
		が返る。ただし、子モデルが登録されていなかった場合は
		nullptr が返ってくる。

		次に、1番目に返ってきたモデルを引数として入力したとき、
		2番目に設定された子モデルが返ってくる。このようにして、
		設定されている子モデルを順番に参照することができる。
		最後の子モデルが引数に入力されたとき、nullptr が返る。
	\end{tabular}
\end{tabbing}

\section{干渉・衝突判定}
ゲームのようなアプリケーションの場合、物体同士の衝突を検出することは重要な処理である。
FKでは、モデル同士の干渉や衝突を検出する機能を利用することができる。
ここではまず、本書における用語の定義を行う。
\begin{description}
 \item[干渉判定:] ~ \\
	ある瞬間において、物体同士の干渉部分が存在するかどうかを判定する処理のこと。

 \item[衝突判定:] ~ \\
	ある瞬間から一定時間の間に、物体同士が衝突するかどうかを判定する処理のこと。
\end{description}

干渉判定は、あくまで「ある瞬間」の時点での干渉状態を調べるものである。
それに対し衝突判定は、「ある瞬間」において干渉状態になかったとしても、
それから一定時間の間に衝突するようなケースも考慮することになる。
文献によっては、両者を区別することがなかったり、干渉判定のことを
「衝突判定」と呼称しているものも多いが、本書においては両者は厳密に区別する。

\subsection{境界ボリューム}
3次元形状は多くの三角形(ポリゴン)によって構成されており、
これら全てに対し干渉判定や衝突判定に必要な幾何計算を行うことは、
莫大な処理時間を要することがある。
そのため、通常は判定する物体に対し簡略化された形状によって近似的に
干渉・衝突判定を行うことが多い。このときの簡略化形状を
\textbf{境界ボリューム}と呼ぶ。図\ref{fig:boundary}に境界ボリュームのイメージ図を示す。

\myfig{fig:boundary}{./Fig/Boundary.eps}{width=8truecm}
	{境界ボリューム}{0mm}

以下、FKで利用可能な境界ボリュームを紹介する。

\subsection{境界球}
最も簡易な境界ボリュームとして\textbf{境界球}がある。
球同士の干渉判定は他の境界ボリュームと比べて最も高速であり、
またFK上で衝突判定を行える唯一の境界ボリュームである。
その反面、長細い形状などでは判定の誤差が大きくなるという難点がある。

\subsection{軸平行境界ボックス (AABB)}
「\textbf{軸平行境界ボックス}」(Axis Aligned Boundary Box, 以下「\textbf{AABB}」)
は、境界球と並んで処理の高速な干渉判定手法である。
AABB では図形を直方体で囲み、その直方体同士で判定を行う。
ただし、境界となる直方体の各辺は必ず \(x,y,z軸\)のいずれかと平行となるように配置する。

直方体は、一般的に球よりも物体の近似性が高いため、物体の姿勢が常に変化せずに
移動のみを行う場合はしばしば最適な手法となる。しかしながら、物体が回転する場合は
注意が必要である。それは、物体が回転した場合に AABB の大きさも変化するためである。
その様子を図\ref{fig:aabb}に示す。

\myfig{fig:aabb}{./Fig/AABB.eps}{width=5truecm}
	{回転によるAABBの変化}{0mm}

\subsection{有向境界ボックス (OBB)}
「\textbf{有向境界ボックス}」(Oriented Bounding Box, 以下「\textbf{OBB}」)
は、AABBと同様に直方体による境界ボリュームであるが、
モデルの回転に伴ってボックスも追従して回転する。
モデルが回転してもボックスの大きさは変わらないので、
非常に扱いやすい境界ボリュームである。
図\ref{fig:obb}にモデルの回転と追従するボックスの様子を示す。

\myfig{fig:obb}{./Fig/OBB.eps}{width=5truecm}
	{モデル回転に追従するOBB}{0mm}

しかしながら、OBBの干渉判定処理は実際にはかなり複雑であり、
全境界ボリューム中最も処理時間を要する。
モデルが少ない場合は支障はないが、多くのモデル同士の干渉判定を行う場合は
処理時間について注意が必要である。

\subsection{カプセル型}
「\textbf{カプセル型}」とは、円柱に対し上面と下面に同半径の半球が合わさった形状である。
モデルが回転した場合は、OBBと同様に方向は追従する。図\ref{fig:capsule}は、
カプセル型境界ボリュームがモデルの回転に追従する様子である。

\myfig{fig:capsule}{./Fig/Capsule.eps}{width=5truecm}
	{カプセル型の境界ボリューム}{0mm}

カプセル型は、形状は複雑に感じられるが、干渉判定の処理速度は OBB よりもかなり高速である。
境界球では誤差が大きく、
境界ボリューム自体もモデルの回転に追従してほしいが、多くのモデル同士の干渉判定が
必要となる場面では、カプセル型が最も適していると言える。

\subsection{干渉判定の方法}
干渉判定を行うには、大きく以下の手順を行う。
\begin{enumerate}
 \item どの境界ボリュームを利用するかを決める。
 \item 境界ボリュームの大きさを設定する。
 \item (モデルに対し干渉判定関係の設定を行う。)
 \item 実際に他のモデルとの干渉判定を行う。
\end{enumerate}
まずはどの境界ボリュームを利用するかを検討しよう。
境界ボリューム今のところ 4 種類あり、
それぞれ長所と短所があるので、モデルの形状や利用用途を考えて決定しよう。
ここでは借りに「OBB」を利用すると想定する。
境界ボリュームの種類設定は、setBMode() で行う。
以降、サンプルプログラム中の「modelA」、「modelB」という変数は
共に fk\_Model 型であるとする。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.setBMode(FK_B_OBB);
\end{verbatim}
\end{breakbox}
~ \\
setBMode() の引数の種類は、以下の通りである。
\begin{table}[H]
\caption{境界ボリュームの設定値}
\label{tbl:bmode}
\begin{center}
\begin{tabular}{|c|l|}
\hline
FK\_B\_SPHERE & 境界球 \\ \hline
FK\_B\_AABB & 軸平行境界ボックス (AABB) \\ \hline
FK\_B\_OBB & 有向境界ボックス (OBB) \\ \hline
FK\_B\_CAPSULE & カプセル型 \\ \hline
\end{tabular}
\end{center}
\end{table}

次に、境界ボリュームの大きさを設定する。
これは自分自身で具体的な数値を設定する方法と、
既にモデルに設定してある形状から自動的に大きさを算出する方法がある。
自身で設定する場合は、fk\_Model クラスの基底クラスとなっている
fk\_Boundary クラスのメンバ関数を利用することになるので、
そちらのリファレンスマニュアルを参照してほしい。
自動的に設定する場合は、あらかじめ setShape() で形状を設定しておき、
以下のように adjustOBB() を呼び出すだけでよい。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.setShape(&shape);
    modelA.adjustOBB();
\end{verbatim}
\end{breakbox}
~ \\
あとは、他のモデルを引数として isInter() 関数を用いれば干渉判定ができる。
(もちろん、modelB の方も事前に上記の各種設定をしておく必要がある。)
\\
\begin{breakbox}
\begin{verbatim}
    if(modelA.isInter(&modelB) == true) {
        // modelA と modelB は干渉している。
    }
\end{verbatim}
\end{breakbox}

\subsection{干渉継続モード}
通常、干渉判定はその瞬間において干渉しているかどうかを判定するものであるが、
「過去に他のモデルと干渉したことがあるか」を知りたいという場面は多い。
そのようなときは、ここで紹介する「\textbf{干渉継続モード}」を利用するとよい。
この機能を用いると、(明示的にリセットするまでは)過去の干渉判定の際に
一度でも干渉があったかどうかを取得することができる。

干渉継続モードを有効とするには、setInterMode() 関数で true を引数に入力する。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.setInterMode(true);
\end{verbatim}
\end{breakbox}
~ \\
その後、干渉が生じたことがある場合は getInterStatus() で true が返ってくる。
\\
\begin{breakbox}
\begin{verbatim}
    if(modelA.getInterStatus() == true) {
        // 過去に干渉があった場合
    }
\end{verbatim}
\end{breakbox}
~ \\
この情報をリセットしたい場合は、resetInter() を用いる。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.resetInter();
\end{verbatim}
\end{breakbox}
~ \\
なお、このモードを利用するときに注意することとして、
「過去に干渉があった」というのはあくまで「isInter() を用いて干渉と判断された」
ということを意味するということである。実際には他モデルと干渉していたとしても、
そのときに isInter() を用いて判定を行っていなかった場合は、
このモードで「過去に干渉があった」とはみなされないので、注意が必要である。

\subsection{干渉自動停止モード}
他の物体と接触したときに、自動的に動きを停止するという制御がしばしば用いられる。
例えば、動く物体が障害物に当たった場合に、その障害物にめり込まないようにするという場合である。
そのような処理を自動的に実現する方法として「\textbf{干渉自動停止モード}」がある。
このモードでは、あらかじめ干渉判定を行う他のモデルを事前に登録しておき、
内部で常に干渉判定処理を行うので、自身で干渉判定を行う必要はない。

まずは事前に境界ボリュームの設定を行っておく。その上で、
干渉判定を行いたいモデルを entryInterModel() で登録しておく。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.entryInterModel(&modelB);
\end{verbatim}
\end{breakbox}
~ \\
その後、setInterStopMode() で true を引数に与えることで、干渉自動停止モードが ON となる。
\\
\begin{breakbox}
\begin{verbatim}
    modelA.setInterStopMode(true);
\end{verbatim}
\end{breakbox}
~ \\
このモデルは、今後移動や回転を行った際に登録した他モデルと干渉してしまう場合、
その移動や回転が無効となり、物体は停止する。この判定に関しての詳細は
fk\_Model::setInterStopMode() のリファレンスマニュアルに掲載されている。

このモードは便利ではあるが、状況次第ではモデルがまったく動かせなくなってしまう恐れもあるので、
状況に応じて OFF にするなどの工夫が必要となることもあるので、注意してほしい。

\subsection{衝突判定}
衝突判定は、干渉判定と比べると複雑な処理を行うことになるが、
物体同士の衝突を厳密に判定できるという利点がある。
衝突判定を利用するには、以下のような手順を行う。
\begin{enumerate}
 \item 境界球の大きさを設定しておく。
 \item 衝突判定を行うモデルで事前に snapShot() を呼んでおく。
 \item モデルの移動や回転を行う。
 \item isCollision() を用いて衝突判定を行う。
 \item 衝突していた場合、restore() を衝突した瞬間の位置にモデルを移動させる。
\end{enumerate}

まず、モデルに対し境界球の大きさを設定する。これも半径を直接指定する方法と、
adjustSphere() を用いて自動的に設定する方法がある。

次に、衝突判定を行うモデルに対し、毎回のメインループの中で snapShot() を呼ぶ。
\\
\begin{breakbox}
\begin{verbatim}
    while(true) {
                :
        modelA.snapShot();
        modelB.snapShot();
                :
    }
\end{verbatim}
\end{breakbox}
~ \\
その後、モデルの移動や回転などを行った後に、isCollision() で他モデルとの衝突判定を行う。
isCollision() 関数は返値として衝突判定結果を返すが、衝突があった場合は
第二引数にその時間を返すようになっている。
もし衝突していた場合に restore() を呼ぶようにしておく。
\\
\begin{breakbox}
\begin{verbatim}
    double   t;

    while(true) {
                :
        if(modelA.isCollision(&modelB, &t) == true) {
            modelA.restore(t);
        }
                :
    }
\end{verbatim}
\end{breakbox}
~ \\
restore() では、引数を省略すると 0 を入力したときと同じ意味となり、
その場合は snapShot() を用いた時点での位置と姿勢に戻る。
自身のプログラム中での挙動として、適している方を用いること。
